################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
# Generated on: 2025-11-03 09:07:19
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\admin_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
# Generated on: 2025-10-27 15:28:42
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
      case 'EVENING_FEEDBACK': {
        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
      case 'AI_SUMMARY': {
        // ğŸ¯ ×–×” ×”×—×œ×§ ×©×ª×§×•×¢!
        console.log('ğŸ§  [Manual Email] Loading AI insights...');
        
        // ×˜×¢×Ÿ AI insights ×¢× timeout × ×•×¡×£
        try {
          // âœ… ×”×•×¡×£ timeout ×¡×¤×¦×™×¤×™ ×œ-AI
          await Promise.race([
            SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('AI insights timeout')), 40000)
            ),
          ]);
          
          console.log('âœ… [Manual Email] AI insights loaded successfully');
        } catch (aiError) {
          console.error('âŒ [Manual Email] AI insights failed:', aiError);
          // ×× AI × ×›×©×œ, × ××©×™×š ×‘×œ×™ AI insights
          console.warn('âš ï¸ [Manual Email] Continuing without AI insights');
        }

        email = await SmartEngagementOrchestrator['getAiSummaryEmail'](profile, dict);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator['getPhotoNudgeEmail'](profile, dict);
        } else {
          email = await SmartEngagementOrchestrator['getQuestionnaireNudgeEmail'](profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator['getAlmostDoneEmail'](profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator['getValueEmail'](profile, dict);
        break;
      }
      case 'ONBOARDING': {
        email = await SmartEngagementOrchestrator['getOnboardingEmail'](profile, dict);
        break;
      }
      default:
        throw new Error('Unsupported email type');
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for engagement_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
case 'EVENING_FEEDBACK': {
        // --- ×ª×—×™×œ×ª ×”×ª×™×§×•×Ÿ ---
        console.log('ğŸŒ™ [Manual Email] Evening Feedback requires AI. Loading insights...');
        // ×˜×¢×™× ×ª ×ª×•×‘× ×•×ª ×”-AI ×‘××•×¤×Ÿ ×™×–×•× ×œ×ª×•×š ××•×‘×™×™×§×˜ ×”×¤×¨×•×¤×™×œ
        await SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language);
        console.log(`âœ… [Manual Email] AI insights ${profile.aiInsights ? 'loaded' : 'not available'}.`);
        // --- ×¡×•×£ ×”×ª×™×§×•×Ÿ ---

        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
            case 'AI_SUMMARY': {
        console.log('ğŸ§  [Manual Email] Generating AI Summary email...');
        email = await SmartEngagementOrchestrator.testGetAiSummaryEmail(profile, dict, user.language as Language);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator.testGetPhotoNudgeEmail(profile, dict);
        } else {
          email = await SmartEngagementOrchestrator.testGetQuestionnaireNudgeEmail(profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator.testGetAlmostDoneEmail(profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator.testGetValueEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_DAY_1': {
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      case 'ONBOARDING_PHOTOS': {
        email = await SmartEngagementOrchestrator.testGetOnboardingPhotosEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_AI_TEASER': {
        console.log('ğŸ§  [Manual Email] Generating Onboarding AI Teaser email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingAiTeaserEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING_QUESTIONNAIRE_WHY': {
        email = await SmartEngagementOrchestrator.testGetOnboardingQuestionnaireWhyEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_VALUE_ADD': {
        console.log('ğŸ’ [Manual Email] Generating Onboarding Value Add email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingValueAddEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING': { // Fallback for old value
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      default:
        throw new Error(`Unsupported email type: ${emailType}`);
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

