################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
# Generated on: 2026-02-04 11:16:51
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\questionnaire_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/questionnaire/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
export const dynamic = 'force-dynamic';
function isPrismaError(
  error: unknown
): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

const WORLD_IDS = [
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
] as const;

const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const baseAnswerSchema = z.object({
  questionId: z.string().min(1),
  worldId: WorldId,
  // --- 注 砖 value ---
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
    z.object({ // 住驻转 拽 砖 住
      text: z.string(),
      lang: z.string(),
    }),
  ]),

  answeredAt: z.string().datetime(),
  isVisible: z.boolean().optional().default(true), // 住驻转 砖 砖 注 专专转 
});

type QuestionAnswer = z.infer<typeof baseAnswerSchema>;

const QuestionnaireAnswer = baseAnswerSchema;

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional(),
  currentQuestionIndices: z.record(WorldId, z.number()).optional(), // <--- 住祝 转 砖专 
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

function groupAnswersByWorld(answers: QuestionnaireSubmission['answers']) {
  return answers.reduce<Record<string, QuestionAnswer[]>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer: QuestionAnswer = {
      questionId: answer.questionId,
      worldId: answer.worldId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      isVisible: answer.isVisible, // 注专转 砖
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);

    return acc;
  }, {});
}

function validateSubmissionData(
  data: unknown
): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);

  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '专砖转 转专转' }, { status: 401 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    const transformedData = questionnaire
      ? {
          ...questionnaire,
          valuesAnswers: questionnaire.valuesAnswers || [],
          personalityAnswers: questionnaire.personalityAnswers || [],
          relationshipAnswers: questionnaire.relationshipAnswers || [],
          partnerAnswers: questionnaire.partnerAnswers || [],
          religionAnswers: questionnaire.religionAnswers || [],
        }
      : null;

    return NextResponse.json({
      success: true,
      data: transformedData,
    });
  } catch (error: unknown) {
    console.error('Error fetching questionnaire:', {
      message: isError(error) ? error.message : 'Unknown error occurred',
      stack: process.env.NODE_ENV === 'development' ? error : undefined,
    });

    return NextResponse.json(
      {
        error: '专注 砖 注转 砖',
        details: process.env.NODE_ENV === 'development' ? error : undefined,
      },
      { status: 500 }
    );
  }
}

type Answer = {
  questionId: string;
  worldId: WorldId;
  value: string | number | string[] | number[] | Record<string, number> | { text: string; lang: string };
  answeredAt: string;
  isVisible?: boolean; // 住驻转 砖
};

type MergedAnswers = {
  valuesAnswers: Answer[];
  personalityAnswers: Answer[];
  relationshipAnswers: Answer[];
  partnerAnswers: Answer[];
  religionAnswers: Answer[];
};

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '专砖转 转专转' }, { status: 401 });
    }

    const rawBody = await req.json();

    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json({ error: '砖转砖  爪' }, { status: 404 });
    }

    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers:
        rawBody.answers?.filter(
          (answer: Answer) =>
            answer &&
            answer.questionId &&
            answer.worldId &&
            answer.value !== undefined &&
            answer.value !== null &&
            answer.value !== ''
        ) ?? [],
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json(
        {
          error: '砖转 爪',
          details: isError(error) ? error.message : 'Unknown validation error',
        },
        { status: 400 }
      );
    }

    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    const result = await prisma.$transaction(async (prisma) => {
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' },
      });

      const mergedAnswers: MergedAnswers = {
        valuesAnswers: [
          ...((existingResponse?.valuesAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.valuesAnswers || []),
        ],
        personalityAnswers: [
          ...((existingResponse?.personalityAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.personalityAnswers || []),
        ],
        relationshipAnswers: [
          ...((existingResponse?.relationshipAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.relationshipAnswers || []),
        ],
        partnerAnswers: [
          ...((existingResponse?.partnerAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.partnerAnswers || []),
        ],
        religionAnswers: [
          ...((existingResponse?.religionAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.religionAnswers || []),
        ],
      };

      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof MergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce(
            (acc: Answer[], curr: Answer) => {
              const existingIndex = acc.findIndex(
                (a) => a.questionId === curr.questionId
              );
              if (existingIndex >= 0) {
                if (
                  new Date(curr.answeredAt) >
                  new Date(acc[existingIndex].answeredAt)
                ) {
                  acc[existingIndex] = curr;
                }
              } else {
                acc.push(curr);
              }
              return acc;
            },
            []
          );
          mergedAnswers[worldKey as keyof MergedAnswers] = uniqueAnswers;
        }
      }

      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
           currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),

        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),
        },
      });
await prisma.user.update({
  where: { id: session.user.id },
  data: { updatedAt: new Date() }
});

      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: 'ACTIVE' },
        });
      }

      return savedQuestionnaire;
    });

    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error: unknown) {
    const errorMessage = isError(error)
      ? error.message
      : 'Unknown error occurred';
    const errorStack = isError(error) ? error.stack : undefined;

    console.error('Error details:', {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined,
    });

    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json(
            {
              error: '砖 砖专转 砖 - 砖转砖  拽',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 400 }
          );
        case 'P2002':
          return NextResponse.json(
            {
              error: '砖 砖专转 砖 - 专砖 专 拽转',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 409 }
          );
        default:
          return NextResponse.json(
            {
              error: '砖 砖专转 砖',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 500 }
          );
      }
    }

    return NextResponse.json(
      {
        error: '专注 砖 砖专转 砖',
        details:
          process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "专砖转 转专转" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const requiredWorlds = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;
    const allWorldsCompleted = requiredWorlds.every(
      world => validatedData.worldsCompleted.includes(world)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "  注转 砖"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: " 爪 砖 砖"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
     prisma.user.update({
  where: { id: session.user.id },
  data: { 
    status: "ACTIVE",
    updatedAt: new Date() //  住祝
  }
})

    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "砖转 爪",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "专注 砖 砖转 砖"
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/questionnaire/world/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';

const WorldId = z.enum([
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
]);
type WorldId = z.infer<typeof WorldId>;

const answerSchema = z.object({
  questionId: z.string().min(1),
  value: z
    .union([
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined(),
    ])
    .optional(),
  answeredAt: z
    .string()
    .datetime()
    .transform((str) => new Date(str)),
  isVisible: z.boolean().optional().default(true), // 住驻转 砖
});

const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(answerSchema),
});


export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const body = await req.json();
    const validationResult = worldAnswersSchema.safeParse(body);
    if (!validationResult.success) {
      console.error(
        'Validation error in /questionnaire/world:',
        validationResult.error
      );
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.flatten(),
        },
        { status: 400 }
      );
    }
    const { worldId, answers: newAnswers } = validationResult.data;

    const dbAnswersKey =
      `${worldId.toLowerCase()}Answers` as keyof Prisma.QuestionnaireResponseCreateInput;
    const dbCompletedKey =
      `${worldId.toLowerCase()}Completed` as keyof Prisma.QuestionnaireResponseCreateInput;

    const updatedQuestionnaire = await prisma.$transaction(async (tx) => {
      const existingResponse = await tx.questionnaireResponse.findFirst({
        where: { userId },
      });
   await tx.profile.update({
        where: { userId },
        data: { needsAiProfileUpdate: true }
      });
      await tx.user.update({
  where: { id: userId },
  data: { updatedAt: new Date() }
});

      const newAnswersJson = newAnswers.map((ans) => ({
        ...ans,
        answeredAt: ans.answeredAt.toISOString(),
      })) as unknown as Prisma.JsonArray;

      const questionnaire = await tx.questionnaireResponse.upsert({
        where: { id: existingResponse?.id || 'new-response-placeholder' },
        create: {
          userId,
          startedAt: new Date(),
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: [worldId],
        },
        update: {
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: {
            push: worldId,
          },
        },
      });
      return questionnaire;
    });

    return NextResponse.json({
      success: true,
      message: `Successfully saved answers for world: ${worldId}`,
      data: updatedQuestionnaire,
    });
  } catch (error: unknown) {
    console.error('Error in PUT /api/questionnaire/world:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }

    const errorMessage =
      error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

