################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
# Generated on: 2026-02-04 11:16:31
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\profile_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UserProfile } from "@/types/next-auth";

// הגדרה זו מבטיחה שה-Route Handler ירוץ תמיד מחדש ולא ישמר ב-Cache.
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    // ודא שהמשתמש מחובר. נדרש סשן כדי לגשת לכל פרופיל.
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    // קבע עבור איזה משתמש נשלפים הנתונים:
    const targetUserId = requestedUserId || session.user.id;
    
    // ✨ FIX: Check if the requester is the owner of the profile
    const isOwner = session.user.id === targetUserId;

    // שלוף את המשתמש יחד עם כל המידע המקושר שלו
    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      include: {
        profile: {
          include: {
            testimonials: {
              orderBy: {
                createdAt: 'desc',
              }
            }
          }
        },
        images: {
            orderBy: {
                isMain: 'desc' 
            }
        },
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    // בנה את אובייקט התגובה המלא שישלח חזרה ללקוח
    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: dbProfile.birthDate ? new Date(dbProfile.birthDate) : new Date(), // Fallback if missing, though integrity check exists
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering,
      kippahType: dbProfile.kippahType,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      
      about: dbProfile.about || "",
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      
      manualEntryText: dbProfile.manualEntryText || undefined,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      testimonials: dbProfile.testimonials || [],
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,

      matchingNotes: dbProfile.matchingNotes || "",
      internalMatchmakerNotes: dbProfile.internalMatchmakerNotes || "", // ✅ FIX: Added missing field
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: dbProfile.preferredServiceTypes || [],
      preferredHeadCoverings: dbProfile.preferredHeadCoverings || [],
      preferredKippahTypes: dbProfile.preferredKippahTypes || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
            preferredPartnerHasChildren: dbProfile.preferredPartnerHasChildren || undefined,

      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],

      contactPreference: dbProfile.contactPreference || undefined,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender,

      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      contentUpdatedAt: dbProfile.contentUpdatedAt ? new Date(dbProfile.contentUpdatedAt) : null, 
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      // ✨ FIX: Allow owner to see details even if hidden
      medicalInfoDetails: (isOwner || dbProfile.isMedicalInfoVisible)
        ? dbProfile.medicalInfoDetails ?? undefined 
        : undefined,      
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      cvUrl: dbProfile.cvUrl,
      cvSummary: dbProfile.cvSummary,
      aiProfileSummary: dbProfile.aiProfileSummary,

      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
        phone: userWithProfile.phone,
      }
    };
    
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}

// ========================================================================
// ✨ PUT/PATCH Handler - Update Profile
// ========================================================================
export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body = await req.json();
    const updateData = { ...body };

    // ✅ FIX: Clean medical fields if hasMedicalInfo is false
    if (updateData.hasMedicalInfo === false) {
      updateData.medicalInfoDetails = null;
      updateData.medicalInfoDisclosureTiming = null;
      updateData.isMedicalInfoVisible = false;
    }

    // Remove fields that shouldn't be updated directly
    delete updateData.id;
    delete updateData.userId;
    delete updateData.createdAt;
    delete updateData.updatedAt;
    delete updateData.user;
    delete updateData.testimonials;

    // Convert Date strings to Date objects if needed
    if (updateData.birthDate && typeof updateData.birthDate === 'string') {
      updateData.birthDate = new Date(updateData.birthDate);
    }
    if (updateData.availabilityUpdatedAt && typeof updateData.availabilityUpdatedAt === 'string') {
      updateData.availabilityUpdatedAt = new Date(updateData.availabilityUpdatedAt);
    }

    // Update the profile
    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        ...updateData,
        updatedAt: new Date(),
        contentUpdatedAt: new Date(),
      },
      include: {
        testimonials: {
          orderBy: {
            createdAt: 'desc',
          }
        }
      }
    });

    // Get the full user data for response
    const userWithProfile = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: {
        profile: {
          include: {
            testimonials: {
              orderBy: {
                createdAt: 'desc',
              }
            }
          }
        },
        images: {
          orderBy: {
            isMain: 'desc'
          }
        }
      }
    });

    if (!userWithProfile?.profile) {
      return NextResponse.json(
        { success: false, message: 'Profile not found after update' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    // Build response (same structure as GET)
    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: dbProfile.birthDate ? new Date(dbProfile.birthDate) : new Date(),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering,
      kippahType: dbProfile.kippahType,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      
      about: dbProfile.about || "",
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      
      manualEntryText: dbProfile.manualEntryText || undefined,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      testimonials: dbProfile.testimonials || [],
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,

      matchingNotes: dbProfile.matchingNotes || "",
       internalMatchmakerNotes: dbProfile.internalMatchmakerNotes || "", 
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: dbProfile.preferredServiceTypes || [],
      preferredHeadCoverings: dbProfile.preferredHeadCoverings || [],
      preferredKippahTypes: dbProfile.preferredKippahTypes || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],

      contactPreference: dbProfile.contactPreference || undefined,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender,

      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
            contentUpdatedAt: new Date(), // או להשתמש בערך מה-updatedProfile אם שלפת אותו

      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      cvUrl: dbProfile.cvUrl,
      cvSummary: dbProfile.cvSummary,
      aiProfileSummary: dbProfile.aiProfileSummary,
  priorityScore: dbProfile.priorityScore,
  priorityCategory: dbProfile.priorityCategory,
  redFlags: dbProfile.redFlags || [],
  greenFlags: dbProfile.greenFlags || [],
  difficultyScore: dbProfile.difficultyScore,
  readinessLevel: dbProfile.readinessLevel,
  missingFields: dbProfile.missingFields || [],
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };

    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile update error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while updating profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}

// PATCH is an alias for PUT in this case
export async function PATCH(req: Request) {
  return PUT(req);
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

// ✅ חדש: GET handler לשליפת הסטטוס
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const profile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: {
        availabilityStatus: true,
        availabilityNote: true,
      }
    });

    return NextResponse.json({
      success: true,
      availabilityStatus: profile?.availabilityStatus || 'AVAILABLE',
      availabilityNote: profile?.availabilityNote || null,
    });

  } catch (error) {
    console.error("Error fetching availability:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch status" },
      { status: 500 }
    );
  }
}

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      // ✅ מחזיר רק את מה שצריך
      select: {
        availabilityStatus: true,
        availabilityNote: true,
      }
    });

    await prisma.user.update({
      where: { id: session.user.id },
      data: { updatedAt: new Date() }
    });

    return NextResponse.json({
      success: true,
      availabilityStatus: updatedProfile.availabilityStatus,
      availabilityNote: updatedProfile.availabilityNote,
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\cv
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\cv\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/cv/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
import aiService from '@/lib/services/aiService';
import profileAiService from '@/lib/services/profileAiService';
import mammoth from 'mammoth';

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// --- POST Handler for uploading a CV ---
export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }
  const userId = session.user.id;
  const userLocale = session.user.language || 'he';

  try {
    const formData = await req.formData();
    const file = formData.get('cv') as File | null;

    if (!file) {
      return NextResponse.json({ success: false, message: 'No file provided' }, { status: 400 });
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    // 1. Upload file to Cloudinary
    const uploadResult = await new Promise<any>((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
            {
                resource_type: 'raw',
                folder: `users/${userId}/cvs`,
                public_id: file.name, 
                overwrite: true, 
            },
            (error, result) => {
                if (error) reject(error);
                resolve(result);
            }
        );
        uploadStream.end(buffer);
    });
    
    if (!uploadResult?.secure_url) {
        throw new Error('Cloudinary upload failed');
    }

    // --- AI DEEP ANALYSIS ---
    let cvSummaryMarkdown: string | null = null;
    try {
        console.log(`[CV Route] Extracting text from CV for user ${userId}. File type: ${file.type}`);
        
        let extractedCvText: string | null = null;

        // Check if file is Word (.docx) - PDF temporarily disabled
        if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
            console.log("[CV Route] Parsing DOCX file.");
            const { value } = await mammoth.extractRawText({ buffer });
            extractedCvText = value;
        } else if (file.type === 'application/pdf') {
            console.log("[CV Route] PDF parsing temporarily disabled. Please upload DOCX for AI analysis.");
            // TODO: Implement PDF parsing with alternative library
        } else {
            console.warn(`[CV Route] Unsupported file type for text extraction: ${file.type}`);
        }

        if (extractedCvText && extractedCvText.trim().length > 50) {
            console.log(`[CV Route] Sending CV text to AI for deep analysis in locale: ${userLocale}.`);
            const analysisResult = await aiService.analyzeCvInDepth(extractedCvText, userLocale);
            
            if (analysisResult) {
                const parts = [
                    `### סיכום מנהלים\n${analysisResult.executiveSummary}`,
                    `### תובנות אישיותיות\n- ${analysisResult.personalityInsights.join('\n- ')}`,
                    `### תובנות ערכיות\n- ${analysisResult.valuesInsights.join('\n- ')}`,
                    `### מסלול קריירה\n**נרטיב:** ${analysisResult.careerTrajectory.narrative}\n\n**אבני דרך:**\n` +
                    analysisResult.careerTrajectory.milestones.map(m => `  - **${m.title} (${m.period}):** ${m.keyLearnings}`).join('\n'),
                ];
                if (analysisResult.redFlags.length > 0) {
                    parts.push(`### נקודות לבירור (שדכן)\n- ${analysisResult.redFlags.join('\n- ')}`);
                }
                cvSummaryMarkdown = parts.join('\n\n');
                console.log(`[CV Route] AI deep analysis generated successfully for user ${userId}.`);
            }
        }
    } catch (aiError) {
        console.error(`[CV Route] AI processing failed for user ${userId}:`, aiError);
    }

    // 3. Update database
    const updatedProfile = await prisma.profile.update({
      where: { userId },
      data: {
        cvUrl: uploadResult.secure_url,
        cvSummary: cvSummaryMarkdown,
        needsAiProfileUpdate: true,
      },
    });

    // 4. Trigger background update
    profileAiService.updateUserAiProfile(userId).catch(err => {
        console.error(`[CV Route] Background AI profile vector update failed for user ${userId}:`, err);
    });

    return NextResponse.json({ success: true, profile: updatedProfile });

  } catch (error) {
    console.error('CV Upload API Error:', error);
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}

// --- DELETE Handler for deleting a CV ---
export async function DELETE(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
  
    try {
        const profile = await prisma.profile.findUnique({
            where: { userId },
            select: { cvUrl: true },
        });

        if (profile?.cvUrl) {
            try {
                const urlParts = profile.cvUrl.split('/');
                const fileNameWithExt = urlParts[urlParts.length - 1];
                if (fileNameWithExt) {
                    const publicId = `users/${userId}/cvs/${decodeURIComponent(fileNameWithExt)}`;
                    console.log(`[CV Delete] Attempting to delete from Cloudinary with public_id: ${publicId}`);
                    await cloudinary.uploader.destroy(publicId, { resource_type: 'raw' });
                }
            } catch(e) {
                console.error(`[CV Delete] Could not parse public_id from URL: ${profile.cvUrl}`, e);
            }
        }

        const updatedProfile = await prisma.profile.update({
            where: { userId },
            data: {
                cvUrl: null,
                cvSummary: null,
                needsAiProfileUpdate: true,
            },
        });

        profileAiService.updateUserAiProfile(userId).catch(err => {
            console.error(`[CV Delete] Background AI profile vector update failed for user ${userId}:`, err);
        });

        return NextResponse.json({ success: true, profile: updatedProfile });
    } catch (error) {
        console.error('CV Delete API Error:', error);
        return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';

export const dynamic = 'force-dynamic';

// 1. קונפיגורציה של Cloudinary
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// 2. פונקציית עזר להעלאה (עוטפת את ה-Stream ב-Promise)
function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: 'profile-images',
        resource_type: 'image',
        // ניתן להוסיף כאן טרנספורמציות בסיסיות אם רוצים, אבל עדיף לבצע אותן בעת התצוגה
      },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({
            secure_url: result.secure_url,
            public_id: result.public_id,
          });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// 3. GET - שליפת כל התמונות של המשתמש
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: {
        user: {
          email: session.user.email,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error('[GetImages] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch images' },
      { status: 500 }
    );
  }
}

// 4. POST - העלאת תמונה חדשה
export async function POST(req: NextRequest) {
  // הגבלת קצב בקשות: 15 בקשות לשעה למשתמש (מונע הצפה)
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  const startTime = Date.now();

  try {
    console.log('[Upload] Starting upload process');

    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error('[Upload] Authentication failed - No user session');
      return NextResponse.json(
        {
          success: false,
          error: 'Unauthorized',
        },
        { status: 401 }
      );
    }

    // שליפת המשתמש ובדיקת כמות התמונות הקיימת
    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      select: { id: true, email: true, _count: { select: { images: true } } },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    // עיבוד הטופס (FormData)
    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.error('[Upload] No file provided in request');
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    // בדיקת מגבלת כמות תמונות (5)
    if (user._count.images >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { success: false, error: 'Maximum number of images reached' },
        { status: 400 }
      );
    }

    // בדיקת סוג קובץ
    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid file type. Only JPG, PNG and WEBP are allowed',
        },
        { status: 400 }
      );
    }

    // === כאן השינוי החשוב: מגבלה של 10MB ===
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    if (file.size > MAX_FILE_SIZE) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { success: false, error: 'File size must be less than 10MB' },
        { status: 400 }
      );
    }

    // המרת הקובץ ל-Buffer לצורך העלאה
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    console.log(`[Upload] File processed (${file.size} bytes), uploading to Cloudinary...`);

    // שליחה ל-Cloudinary
    const cloudinaryResult = await uploadToCloudinary(buffer);

    // אם זו התמונה הראשונה, נגדיר אותה כראשית
    const isFirstImage = user._count.images === 0;

    // שמירה ב-DB
    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });

    // עדכון זמן השינוי האחרון של המשתמש
    await prisma.user.update({
      where: { id: session.user.id },
      data: { updatedAt: new Date() }
    });

    console.log(
      `[Upload] Database save completed in ${Date.now() - startTime}ms`
    );
    
    return NextResponse.json({
      success: true,
      image,
      timing: `${Date.now() - startTime}ms`,
    });

  } catch (error) {
    console.error('[Upload] General error:', error);
    console.log(`[Upload] Failed after ${Date.now() - startTime}ms`);
    return NextResponse.json(
      { success: false, error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// 5. DELETE - מחיקת תמונות מרובות
export async function DELETE(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const { imageIds } = await req.json();

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Image IDs must be a non-empty array' },
        { status: 400 }
      );
    }

    // 1. בדיקת בעלות על התמונות וקבלת המידע עליהן
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: userId, // קריטי: מוודא שהמשתמש מוחק רק את התמונות שלו
      },
      select: {
        id: true,
        cloudinaryPublicId: true,
        isMain: true,
      },
    });

    if (imagesToDelete.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No matching images found to delete.' },
        { status: 404 }
      );
    }

    // 2. האם התמונה הראשית נמחקת?
    const wasMainImageDeleted = imagesToDelete.some((image) => image.isMain);

    // 3. מחיקה מ-Cloudinary
    const cloudinaryIdsToDelete = imagesToDelete
      .map((image) => image.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (cloudinaryIdsToDelete.length > 0) {
      const cloudinaryDeletions = cloudinaryIdsToDelete.map((publicId) =>
        cloudinary.uploader.destroy(publicId).catch((err) => {
          console.error(
            `[Bulk Delete] Failed to delete image ${publicId} from Cloudinary:`,
            err
          );
        })
      );
      await Promise.all(cloudinaryDeletions);
    }

    // 4. מחיקה מה-DB
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) },
        userId: userId,
      },
    });

    // 5. אם התמונה הראשית נמחקה, נגדיר חדשה (הכי חדשה שנשארה)
    if (wasMainImageDeleted) {
      const newMainImage = await prisma.userImage.findFirst({
        where: { userId: userId },
        orderBy: { createdAt: 'desc' },
      });

      if (newMainImage) {
        await prisma.userImage.update({
          where: { id: newMainImage.id },
          data: { isMain: true },
        });
      }
    }

    // 6. החזרת הרשימה המעודכנת לקלינט
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, images: updatedImages });

  } catch (error) {
    console.error('[Bulk Delete Images] Error:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete images',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/[imageId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // ✅ שינוי: התאמה ל-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // ✅ שינוי: הוספת await
    const { imageId } = params;
    
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId },
    });

    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // ✅ שינוי: התאמה ל-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // ✅ שינוי: הוספת await
    const { imageId } = params;

    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\neshama-insight
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\neshama-insight\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/neshama-insight/route.ts
// =====================================================
// API Route - גרסה 7.0 (Clean Text & Positive Vibes)
// =====================================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateNarrativeProfile } from '@/lib/services/profileAiService';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { Language, UserRole } from '@prisma/client';

// =====================================================
// POST Handler
// =====================================================

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body = await req.json();
    const userId = body.userId;
    const locale = body.locale || 'he';

    // בדיקת הרשאות
    const requester = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true, id: true },
    });

    const isMatchmakerOrAdmin =
      requester?.role === UserRole.MATCHMAKER ||
      requester?.role === UserRole.ADMIN;
    const isSelf = userId === session.user.id;

    if (!isSelf && !isMatchmakerOrAdmin) {
      return NextResponse.json(
        { success: false, message: 'Forbidden' },
        { status: 403 }
      );
    }

    // שליפת נתוני המשתמש
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: {
          take: 1,
          orderBy: { lastSaved: 'desc' },
        },
      },
    });

    if (!user || !user.profile) {
      return NextResponse.json(
        { success: false, message: 'Profile not found' },
        { status: 404 }
      );
    }

    // Rate Limiting (למשתמשים רגילים בלבד)
    if (isSelf && !isMatchmakerOrAdmin && user.neshamaInsightLastGeneratedAt) {
      const lastGenerated = new Date(user.neshamaInsightLastGeneratedAt);
      const now = new Date();
      const diffMs = now.getTime() - lastGenerated.getTime();
      const diffHours = diffMs / (1000 * 60 * 60);

      if (diffHours < 24) {
        const hoursLeft = Math.ceil(24 - diffHours);
        const message =
          locale === 'he'
            ? 'ניתן ליצור דוח חדש בעוד ' + hoursLeft + ' שעות'
            : 'You can generate a new report in ' + hoursLeft + ' hours';
        return NextResponse.json(
          { success: false, message: message },
          { status: 429 }
        );
      }
    }

    // בדיקת השלמת פרופיל (למשתמשים רגילים בלבד)
    const completionResult = calculateProfileCompletion(user);
    if (!completionResult.isComplete && !isMatchmakerOrAdmin) {
      const message =
        locale === 'he'
          ? 'יש להשלים לפחות 95% מהפרופיל (כרגע: ' +
            completionResult.completionPercent +
            '%)'
          : 'Please complete at least 95% of your profile (current: ' +
            completionResult.completionPercent +
            '%)';
      return NextResponse.json(
        { success: false, message: message },
        { status: 400 }
      );
    }

    // 1. יצירת פרופיל נרטיבי
    const narrativeProfile = await generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      throw new Error('Failed to generate narrative profile');
    }

    // 2. יצירת הדוח ב-AI עם הפרומפט המשופר
    const insightText = await generateNeshmaInsightText(
      narrativeProfile,
      user,
      locale as Language
    );

    // 3. עדכון מסד הנתונים
    await prisma.user.update({
      where: { id: userId },
      data: {
        neshamaInsightLastGeneratedAt: new Date(),
        neshamaInsightGeneratedCount: { increment: 1 },
        updatedAt: new Date(),
      },
    });

    return NextResponse.json({
      success: true,
      insight: insightText,
    });
  } catch (error) {
    console.error('Error generating Neshama Insight:', error);
    return NextResponse.json(
      { success: false, message: 'Internal server error' },
      { status: 500 }
    );
  }
}

// =====================================================
// Profile Completion Calculator
// =====================================================

interface CompletionResult {
  isComplete: boolean;
  completionPercent: number;
}

function calculateProfileCompletion(user: any): CompletionResult {
  const profile = user.profile;
  const questionnaire = user.questionnaireResponses[0];

  if (!profile) {
    return { isComplete: false, completionPercent: 0 };
  }

  const checks = [
    { weight: 5, pass: user.images && user.images.length >= 1 },
    { weight: 5, pass: Boolean(profile.profileHeadline) },
    { weight: 10, pass: Boolean(profile.about) && profile.about.length >= 50 },
    { weight: 5, pass: Boolean(profile.height) },
    { weight: 5, pass: Boolean(profile.city) },
    { weight: 5, pass: Boolean(profile.maritalStatus) },
    { weight: 5, pass: Boolean(profile.religiousLevel) },
    {
      weight: 15,
      pass: Boolean(questionnaire && questionnaire.valuesCompleted),
    },
    {
      weight: 15,
      pass: Boolean(questionnaire && questionnaire.personalityCompleted),
    },
    {
      weight: 15,
      pass: Boolean(questionnaire && questionnaire.relationshipCompleted),
    },
    {
      weight: 15,
      pass: Boolean(questionnaire && questionnaire.partnerCompleted),
    },
  ];

  let totalWeight = 0;
  let earnedWeight = 0;

  for (let i = 0; i < checks.length; i++) {
    totalWeight += checks[i].weight;
    if (checks[i].pass) {
      earnedWeight += checks[i].weight;
    }
  }

  const completionPercent = Math.round((earnedWeight / totalWeight) * 100);

  return {
    isComplete: completionPercent >= 95,
    completionPercent: completionPercent,
  };
}

// =====================================================
// AI Insight Generator
// =====================================================

async function generateNeshmaInsightText(
  narrativeProfile: string,
  user: any,
  locale: Language
) {
  const questionnaire = user.questionnaireResponses[0];
  const isHebrew = locale === 'he';
  
  const prompt = buildCleanMatchmakerPrompt(
    narrativeProfile,
    questionnaire,
    user,
    isHebrew
  );

  console.log('=== CLEAN MATCHMAKER PROMPT GENERATED ===');

  const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);

  const model = genAI.getGenerativeModel({
    model: 'gemini-2.0-flash',
    generationConfig: {
      temperature: 0.7, // טמפרטורה מאוזנת לטקסט קריא ולא "משוגע" מדי
      topP: 0.95,
      maxOutputTokens: 8192,
    },
  });

  const result = await model.generateContent(prompt);
  let text = result.response.text();

  // ניקוי נוסף ליתר ביטחון (למקרה שה-AI בכל זאת הוסיף Markdown)
  text = text.replace(/[*#]/g, '').trim();

  return text;
}

// =====================================================
// The "Clean" Matchmaker Prompt Builder
// =====================================================

function buildCleanMatchmakerPrompt(
  narrativeProfile: string,
  questionnaire: any,
  user: any,
  isHebrew: boolean
): string {
  const firstName = user.firstName || '';
  const isMale = user.profile && user.profile.gender === 'MALE';

  const questionnaireData = questionnaire
    ? {
        values: questionnaire.valuesAnswers || {},
        personality: questionnaire.personalityAnswers || {},
        relationship: questionnaire.relationshipAnswers || {},
        partner: questionnaire.partnerAnswers || {},
      }
    : {};
  const questionnaireJson = JSON.stringify(questionnaireData, null, 2);

  if (isHebrew) {
    return `
אתה ה-AI של נשמהטק, המשמש כשדכן מומחה, רגיש וחכם.

המשימה:
לכתוב דוח ניתוח אישי עבור ${firstName}.
המטרה: לתת ${isMale ? 'לו' : 'לה'} פידבק מעצים, נעים לקריאה, אך פרקטי ומדויק למציאת זוגיות.

---
מידע על המשתמש:
${narrativeProfile}

תשובות לשאלון:
${questionnaireJson}
---

הנחיות קריטיות לעיצוב וסגנון:

1. **טקסט נקי בלבד:** אל תשתמש בשום סימן עיצוב מיוחד. אסור להשתמש ב-# (סולמיות), אסור להשתמש ב-* (כוכביות) להדגשה או לבולטים. כתוב רק טקסט רגיל, נקי ופשוט.
2. **מבנה:** הפרד בין הפסקאות והחלקים השונים באמצעות שורות רווח כפולות. הכותרות של הסעיפים צריכות להיות טקסט רגיל בשורה נפרדת.
3. **מטאפורות חיוביות בלבד:** בפתיחה, השתמש בדימוי חיובי, יציב ומעצים (כמו "עוגן", "בית", "מגדלור", "שורשים"). **אסור בתכלית האיסור** להשתמש בדימויים מפחידים, שליליים או מלחיצים (כמו "תהום", "גשר רעוע", "סערה", "מלחמה"). המטרה היא לתת למשתמש ביטחון.
4. **אמפתיה ורגישות:** פנה למשתמש בגוף ${isMale ? 'שני זכר ("אתה")' : 'שני נקבה ("את")'}.
5. **ציטוטים:** השתמש בציטוטים מדויקים ממה שהמשתמש כתב כדי להראות שהבנת אותו.
6. **"אפקט המראה" (ריכוך):** כשאתה מנתח דינמיקה בדייטים או חולשות, אל תפנה אצבע מאשימה ("אתה משתלט"). במקום זאת, דבר על הטיפוס הכללי: "אנשים עם כריזמה טבעית כמו שלך, לעיתים נוטים בלי לשים לב לקחת הרבה מקום בשיחה...". זה קריטי לקבלה של הדברים.

מבנה הדוח הרצוי (טקסט נקי, ללא Markdown):

שלום ${firstName}, כאן ה-AI של נשמהטק.

[פסקה פותחת: מטאפורה חיובית ומחבקת שמזקקת את המהות של המשתמש. משהו שנותן תחושת יציבות וכוח.]

1. מי ${isMale ? 'אתה' : 'את'} באמת? (מבט לעומק)
[ניתוח אישיותי עמוק. התייחס לערכים ולרוחניות. השתמש בציטוטים מהטקסט שלו.]

2. מה ${isMale ? 'אתה מביא' : 'את מביאה'} לקשר?
[תיאור החוזקות הרגשיות. לאחר מכן, תיאור "אתגרי צמיחה" בצורה עדינה ומכילה, כחלק מהטיפוס האישיותי ולא כפגם אישי.]

3. הפרופיל המדויק עבורך
כאן אני רוצה לדייק אותך. הרבה פעמים הלב רוצה משהו אחד, אבל הנפש צריכה משהו אחר.
ההתאמה הקלאסית: [תיאור האישיות שמשלימה ומאזנת]
המוקש: [תיאור טיפוס שנראה מתאים בהתחלה אך לא יחזיק מעמד - הסבר למה]
על מה לא להתפשר: [ערכי ליבה]
איפה אפשר לשחרר: [מקומות בהם המשתמש אולי מחמיר מדי]

4. המראה: איך זה נראה בדייטים?
[ניתוח הדינמיקה בדייט. השתמש בשפה מכלילה ("טיפוסים כמוך...") כדי לא לפגוע. הצע שאלת זהב אחת שכדאי לשאול בדייט, והמלצה לסוג דייט שמתאים לאופי.]

5. סיכום ומילה לדרך
[סיום אופטימי, מחזק ומניע לפעולה.]

---
זכור: שפה עשירה, רגישה, וללא שום סימני עיצוב מיוחדים.
`;
  } else {
    // English Prompt (Mirror of the Hebrew one)
    return `
You are NeshamaTech AI, acting as an expert, sensitive, and wise matchmaker.

Mission:
Write a personal analysis report for ${firstName}.
Goal: Give ${firstName} empowering feedback that is pleasant to read, yet practical and accurate for finding a partner.

---
User Narrative:
${narrativeProfile}

Questionnaire Data:
${questionnaireJson}
---

Critical Style & Formatting Instructions:

1. **Clean Text Only:** Do NOT use any special formatting characters. NO hashtags (#), NO asterisks (*) for bolding or bullets. Write only plain, clean text.
2. **Structure:** Separate paragraphs and sections using double line breaks. Section titles should be plain text on a separate line.
3. **Positive Metaphors Only:** In the opening, use a positive, stable, and empowering image (like "anchor", "home", "lighthouse", "roots"). You are **STRICTLY FORBIDDEN** from using scary, negative, or stressful imagery (like "abyss", "shaky bridge", "storm", "battle"). The goal is to give the user confidence.
4. **Empathy:** Address the user as "You".
5. **Quotes:** Use direct quotes from what the user wrote.
6. **The "Mirror Effect" (Softening):** When analyzing dating dynamics or weaknesses, do NOT point an accusing finger ("You dominate"). Instead, talk about the general type: "People with natural charisma like yours, sometimes tend without realizing it to take up a lot of space in conversation...". This is crucial.

Desired Report Structure (Clean text, NO Markdown):

Hello ${firstName}, this is NeshamaTech AI.

[Opening paragraph: A positive, embracing metaphor distilling the user's essence. Something that gives a sense of stability and strength.]

1. Who are you, really? (Deep Dive)
[Deep personality analysis. Address values and spirituality. Use quotes from their text.]

2. What do you bring to the table?
[Describe emotional strengths. Then, describe "growth challenges" gently and inclusively, as part of the personality type rather than a personal flaw.]

3. Your Precise Match
I want to refine your search. Often the heart wants one thing, but the soul needs another.
The Classic Fit: [Description of the personality that complements/balances you]
The Trap: [Description of a type that looks good initially but won't last - explain why]
Dealbreakers: [Core values]
Where to Relax: [Areas where the user might be too rigid]

4. The Mirror: Dating Dynamics
[Dating dynamic analysis. Use inclusive language ("Types like you...") to avoid offense. Suggest one Golden Question to ask on a date, and a recommended date setting.]

5. Summary & Words of Encouragement
[Optimistic, empowering closing.]

---
Remember: Rich, sensitive language, and NO special formatting characters.
`;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/questionnaire/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma, UserRole } from '@prisma/client';
import { Locale } from '../../../../../i18n-config';

import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { WorldId, UpdateValue } from '@/types/next-auth';
import { formatQuestionnaireForDisplay } from '@/lib/services/questionnaireService';

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // קביעת שפת הצופה מה-URL או מה-headers (כאן נשתמש בברירת מחדל)
    const url = new URL(req.url);
    const viewerLocale = (url.searchParams.get('locale') as Locale) || 'he';
    const targetUserId = url.searchParams.get('userId') || session.user.id;
const isOwnProfile = session.user.id === targetUserId;
const hasElevatedPermissions = 
    session.user.role === UserRole.ADMIN || 
    session.user.role === UserRole.MATCHMAKER;
const canViewAllAnswers = isOwnProfile || hasElevatedPermissions;
console.log(`---[ SERVER LOG | API questionnaire GET ]--- שליפת שאלון עבור: ${targetUserId}, צופה: ${session.user.id}, תפקיד צופה: ${session.user.role}, יכול לראות הכל: ${canViewAllAnswers}`);

console.log(`---[ SERVER LOG | API questionnaire GET ]--- שליפת שאלון עבור משתמש: ${targetUserId}, שפת צפייה: ${viewerLocale}, האם בעל הפרופיל: ${isOwnProfile}`);


    const rawQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: targetUserId },
      orderBy: { createdAt: 'desc' },
    });

    if (!rawQuestionnaire) {
              console.warn('---[ SERVER LOG | API questionnaire GET ]--- לא נמצא שאלון עבור המשתמש.');

      return NextResponse.json({ success: false, message: 'No questionnaire found' }, { status: 404 });
    }
    console.log('---[ SERVER LOG | API questionnaire GET ]--- נתוני שאלון גולמיים מה-DB:', JSON.stringify(rawQuestionnaire, null, 2));

    // שימוש בפונקציית העיצוב החדשה
const formattedQuestionnaire = await formatQuestionnaireForDisplay(
  rawQuestionnaire,
  viewerLocale,
  canViewAllAnswers  // <-- הוספת הפרמטר החדש
);    console.log('---[ DEBUG 4: FINAL API RESPONSE ]--- Data being sent to client:', JSON.stringify(formattedQuestionnaire.formattedAnswers, null, 2));
    console.log('---[ SERVER LOG | API questionnaire GET ]--- נתונים מעובדים שמוחזרים לקליינט:', JSON.stringify(formattedQuestionnaire, null, 2));

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedQuestionnaire,
    });
  } catch (error) {
    console.error('Error fetching formatted questionnaire:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    return NextResponse.json({ success: false, message: errorMessage }, { status: 500 });
 
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
     const userId = session.user.id;

     const body = await req.json();
     
   const { worldKey: rawWorldKey, questionId, value } = body as {
  worldKey: string;  // שינוי מ-WorldId ל-string
  questionId: string;
  value: UpdateValue;
};

// נורמליזציה ל-UPPERCASE
const worldKey = rawWorldKey?.toUpperCase() as WorldId;

if (!worldKey || !questionId || !value || !value.type || !KEY_MAPPING[worldKey]) {
   return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
}

     const dbKey = KEY_MAPPING[worldKey];

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       return NextResponse.json({ success: false, error: "שאלון לא נמצא" }, { status: 404 });
     }

     const currentAnswersJson = questionnaire[dbKey];
     const currentAnswers = Array.isArray(currentAnswersJson) ? currentAnswersJson as unknown as JsonAnswerData[] : [];

     let updatedAnswers: JsonAnswerData[];

     if (value.type === 'delete') {
       // לוגיקה למחיקת התשובה
       updatedAnswers = currentAnswers.filter(a => a.questionId !== questionId);
     } else {
       // לוגיקה קיימת לעדכון או הוספת תשובה
       const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
       const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

       let updatedAnswer: JsonAnswerData;

       if (value.type === 'visibility') {
          if (!existingAnswer) return NextResponse.json({ success: false, error: "לא נמצאה תשובה לעדכון נראות" }, { status: 404 });
          if (typeof value.isVisible !== 'boolean') return NextResponse.json({ success: false, error: "ערך נראות לא תקין" }, { status: 400 });
          updatedAnswer = { ...existingAnswer, isVisible: value.isVisible, answeredAt: new Date().toISOString() };
       } else if (value.type === 'answer') {
         if (value.value === undefined) return NextResponse.json({ success: false, error: "ערך תשובה חסר" }, { status: 400 });
         updatedAnswer = {
           questionId,
           value: value.value as Prisma.JsonValue,
           isVisible: existingAnswer?.isVisible ?? true,
           answeredAt: new Date().toISOString()
         };
       } else {
           return NextResponse.json({ success: false, error: "סוג עדכון לא תקין" }, { status: 400 });
       }

       updatedAnswers = [...currentAnswers];
       if (existingAnswerIndex !== -1) {
           updatedAnswers[existingAnswerIndex] = updatedAnswer;
       } else if (value.type === 'answer') {
           updatedAnswers.push(updatedAnswer);
       }
     }

     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });

     await prisma.profile.update({
       where: { userId },
       data: { needsAiProfileUpdate: true }
     });
await prisma.user.update({
  where: { id: userId },
  data: { updatedAt: new Date() }
});
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach(key => {
       const currentDbKey = KEY_MAPPING[key];
        formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
    });

     const formattedResponse = {
       ...updated,
       formattedAnswers: formattedAnswers
     };

     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            return NextResponse.json({ success: false, error: "שגיאת מסד נתונים" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           return NextResponse.json({ success: false, error: "גוף הבקשה אינו JSON תקין" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "שגיאה בעדכון השאלון" }, { status: 500 });
   }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * GET - מאחזר המלצות.
 * לוגיקה זו משמשת לשני תרחישים:
 * 1. אם נשלח 'userId' בפרמטרים: אחזר המלצות *מאושרות* עבור פרופיל ציבורי.
 * 2. אם לא נשלח 'userId': אחזר את *כל* ההמלצות עבור המשתמש המחובר, כדי שיוכל לנהל אותן.
 */
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');

  try {
    // תרחיש 1: בקשה להצגת המלצות בפרופיל של משתמש ספציפי (לצפייה ציבורית)
    if (userId) {
      const testimonials = await prisma.friendTestimonial.findMany({
        where: {
          profile: {
            userId: userId,
          },
          // חשוב: החזר רק המלצות שאושרו לצפייה ציבורית
          status: 'APPROVED',
        },
        orderBy: {
          createdAt: 'desc',
        },
      });
      return NextResponse.json({ success: true, testimonials });
    }

    // תרחיש 2: בקשה לניהול המלצות של המשתמש המחובר (בתוך עמוד הפרופיל האישי)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const testimonials = await prisma.friendTestimonial.findMany({
      where: {
        profile: {
          userId: session.user.id,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, testimonials });
  } catch (error) {
    console.error('Error in GET /api/profile/testimonials:', error);
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}

/**
 * POST - יוצר המלצה חדשה.
 * תומך בשני תרחישים:
 * 1. עם token - הוספה ציבורית דרך קישור (חבר ממליץ)
 * 2. בלי token - הוספה ידנית (המשתמש מוסיף המלצה על עצמו)
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      token,
      authorName,
      relationship,
      content,
      authorPhone,
      isPhoneVisibleToMatch,
    } = body;

    // ולידציה בסיסית של שדות חובה (ללא token)
    if (!authorName || !relationship || !content) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields.' },
        { status: 400 }
      );
    }

    // ===== תרחיש 1: הוספה עם TOKEN (ציבורית) =====
    if (token) {
      const result = await prisma.$transaction(async (tx) => {
        // מצא את בקשת הטוקן
        const request = await tx.testimonialRequest.findUnique({
          where: {
            token: token,
            status: 'PENDING',
            expiresAt: { gt: new Date() },
          },
        });

        if (!request) {
          throw new Error('Invalid, expired, or already used link.');
        }

        // צור המלצה
        const testimonial = await tx.friendTestimonial.create({
          data: {
            profileId: request.profileId,
            authorName,
            relationship,
            content,
            authorPhone: authorPhone || null,
            isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
            status: 'PENDING',
            submittedBy: 'FRIEND',
          },
        });

        // סמן טוקן כ-COMPLETED
        await tx.testimonialRequest.update({
          where: { id: request.id },
          data: { status: 'COMPLETED' },
        });

        return { success: true, testimonial };
      });

      if (result.success) {
        return NextResponse.json({
          success: true,
          message: 'Thank you! Your testimonial has been submitted.',
        });
      } else {
        throw new Error('Transaction failed unexpectedly.');
      }
    }

    // ===== תרחיש 2: הוספה ידנית ללא TOKEN =====
    // בדוק session
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized - no session' },
        { status: 401 }
      );
    }

    // מצא את ה-profile של המשתמש המחובר
    const userProfile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: { id: true },
    });

    if (!userProfile) {
      return NextResponse.json(
        { success: false, message: 'Profile not found for current user' },
        { status: 404 }
      );
    }

    // צור המלצה חדשה
    const testimonial = await prisma.friendTestimonial.create({
      data: {
        profileId: userProfile.id,
        authorName,
        relationship,
        content,
        authorPhone: authorPhone || null,
        isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
        status: 'PENDING',
submittedBy: 'FRIEND',
      },
    });

    return NextResponse.json({
      success: true,
      message: 'Testimonial added successfully.',
      testimonial,
    });

  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);

    // טיפול בשגיאת token לא תקין
    if (
      error instanceof Error &&
      error.message.includes('Invalid, expired, or already used link')
    ) {
      return NextResponse.json(
        {
          success: false,
          message:
            'This link is invalid, has expired, or has already been used.',
        },
        { status: 400 }
      );
    }

    // שגיאות כלליות
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
# Generated on: 2026-01-05 08:33:46
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * GET - מאחזר המלצות.
 * לוגיקה זו משמשת לשני תרחישים:
 * 1. אם נשלח 'userId' בפרמטרים: אחזר המלצות *מאושרות* עבור פרופיל ציבורי.
 * 2. אם לא נשלח 'userId': אחזר את *כל* ההמלצות עבור המשתמש המחובר, כדי שיוכל לנהל אותן.
 */
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');

  try {
    // תרחיש 1: בקשה להצגת המלצות בפרופיל של משתמש ספציפי (לצפייה ציבורית)
    if (userId) {
      const testimonials = await prisma.friendTestimonial.findMany({
        where: {
          profile: {
            userId: userId,
          },
          // חשוב: החזר רק המלצות שאושרו לצפייה ציבורית
          status: 'APPROVED',
        },
        orderBy: {
          createdAt: 'desc',
        },
      });
      return NextResponse.json({ success: true, testimonials });
    }

    // תרחיש 2: בקשה לניהול המלצות של המשתמש המחובר (בתוך עמוד הפרופיל האישי)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const testimonials = await prisma.friendTestimonial.findMany({
      where: {
        profile: {
          userId: session.user.id,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, testimonials });
  } catch (error) {
    console.error('Error in GET /api/profile/testimonials:', error);
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}

/**
 * POST - יוצר המלצה חדשה באמצעות טוקן חד-פעמי ומאובטח.
 * נקודת קצה זו משמשת את הטופס הציבורי שחברים ממלאים.
 * היא מבטיחה שכל קישור ישמש פעם אחת בלבד.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      token,
      authorName,
      relationship,
      content,
      authorPhone,
      isPhoneVisibleToMatch,
    } = body;

    // 1. ולידציה בסיסית של שדות החובה
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields.' },
        { status: 400 }
      );
    }

    // 2. שימוש בטרנזקציה כדי להבטיח אטומיות.
    // שתי הפעולות (יצירת המלצה ועדכון הטוקן) חייבות להצליח יחד.
    const result = await prisma.$transaction(async (tx) => {
      // שלב א': חפש את בקשת הטוקן. היא חייבת להיות קיימת, בתוקף ובסטטוס PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() }, // ודא שהטוקן לא פג תוקף
        },
      });

      // אם לא נמצאה בקשה תקינה, זרוק שגיאה. זה יבטל את הטרנזקציה אוטומטית.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // שלב ב': צור את רשומת ההמלצה במסד הנתונים.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // המלצה חדשה תמיד ממתינה לאישור המשתמש
          submittedBy: 'FRIEND', // סמן שההמלצה הגיעה מחבר
        },
      });

      // שלב ג': קריטי! שנה את סטטוס הטוקן ל-COMPLETED כדי למנוע שימוש חוזר.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    // 3. אם הטרנזקציה הצליחה, החזר תשובת הצלחה.
    if (result.success) {
      return NextResponse.json({
        success: true,
        message: 'Thank you! Your testimonial has been submitted.',
      });
    } else {
      // מצב זה לא אמור לקרות אם לוגיקת הטרנזקציה נכונה
      throw new Error('Transaction failed unexpectedly.');
    }
  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);

    // 4. טיפול ייעודי בשגיאות ידועות
    if (
      error instanceof Error &&
      error.message.includes('Invalid, expired, or already used link')
    ) {
      return NextResponse.json(
        {
          success: false,
          message:
            'This link is invalid, has expired, or has already been used.',
        },
        { status: 400 }
      );
    }

    // 5. טיפול בשגיאות לא צפויות אחרות
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts

import { NextResponse, NextRequest } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

export async function PUT(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> } // ✅ שינוי: התאמה ל-Next.js 15
) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const params = await props.params; // ✅ שינוי: הוספת await

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id,
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

export async function DELETE(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> } // ✅ שינוי: התאמה ל-Next.js 15
) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const params = await props.params; // ✅ שינוי: הוספת await

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id,
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { randomBytes } from 'crypto';

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Find the user's profile to link the request to
    const userProfile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found' }, { status: 404 });
    }

    // 1. Generate a secure, random token
    const token = randomBytes(32).toString('hex');

    // 2. Set an expiration date (e.g., 7 days from now)
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    // 3. Create the request record in the new database table
    await prisma.testimonialRequest.create({
      data: {
        token: token,
        expiresAt: expiresAt,
        profileId: userProfile.id, // Use the fetched profile ID
      },
    });

    // 4. Construct the full link to return to the client
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    const link = `${baseUrl}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });
  } catch (error) {
    console.error("Failed to create testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal server error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for testimonials_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts

import { NextResponse, NextRequest } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

export async function PUT(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> }
) {
  const session = await getServerSession(authOptions);
  
  // ✅ תיקון: בדיקה רק של user.id (לא profile.id)
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const params = await props.params;

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  // ✅ תיקון: שימוש ב-nested where דרך profile.userId
  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profile: {
        userId: session.user.id,
      }
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

export async function DELETE(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> }
) {
  const session = await getServerSession(authOptions);
  
  // ✅ תיקון: בדיקה רק של user.id (לא profile.id)
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const params = await props.params;

  // ✅ תיקון: שימוש ב-nested where דרך profile.userId
  const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
    where: {
      id: params.testimonialId,
      profile: {
        userId: session.user.id,
      }
    },
  });

  if (deletedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { randomBytes } from 'crypto';

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Find the user's profile to link the request to
    const userProfile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found' }, { status: 404 });
    }

    // 1. Generate a secure, random token
    const token = randomBytes(32).toString('hex');

    // 2. Set an expiration date (e.g., 7 days from now)
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    // 3. Create the request record in the new database table
    await prisma.testimonialRequest.create({
      data: {
        token: token,
        expiresAt: expiresAt,
        profileId: userProfile.id, // Use the fetched profile ID
      },
    });

    // 4. Construct the full link to return to the client
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    const link = `${baseUrl}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });
  } catch (error) {
    console.error("Failed to create testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal server error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/update/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  ReligiousJourney,
  Profile,
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";

// --- Helpers ---

const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};


export async function PUT(req: NextRequest) {
  // Apply rate limiting
  const rateLimitResponse = await applyRateLimit(req, { requests: 50, window: '10 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      console.log("❌ [Update Profile] Unauthorized attempt");
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    console.log(`🔹 [Update Profile] Start update for UserID: ${userId}`);

    let body;
    try {
      body = await req.json();
      // --- LOG 1: בדיקת ה-Body הנכנס ---
      console.log("🔹 [Update Profile] Incoming Body Keys:", Object.keys(body));
      console.log("🔹 [Update Profile] Value of 'internalMatchmakerNotes' in body:", body.internalMatchmakerNotes);
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      religiousJourney,
      about,
      profileHeadline,
      inspiringCoupleStory,
      influentialRabbi,
      isAboutVisible,
      isFriendsSectionVisible,
      isNeshamaTechSummaryVisible,
      parentStatus,
      fatherOccupation,
      motherOccupation,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      internalMatchmakerNotes, // <--- Destructuring here
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious,
      profileCharacterTraits,
      profileHobbies,
      aliyaCountry,
      aliyaYear,
      // Preferences
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      preferredPartnerHasChildren,
      preferredCharacterTraits,
      preferredHobbies,
      preferredAliyaStatus,
      preferredReligiousJourneys,
      hasViewedProfilePreview,
      hasMedicalInfo,
      medicalInfoDetails,
      medicalInfoDisclosureTiming,
      isMedicalInfoVisible,
      cvUrl,
      cvSummary,
    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious;
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
    if (fatherOccupation !== undefined) dataToUpdate.fatherOccupation = emptyStringToNull(fatherOccupation);
    if (motherOccupation !== undefined) dataToUpdate.motherOccupation = emptyStringToNull(motherOccupation);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education & Occupation ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
    if (religiousJourney !== undefined) {
        const val = emptyStringToNull(religiousJourney);
        if (val && Object.values(ReligiousJourney).includes(val as ReligiousJourney)) {
            dataToUpdate.religiousJourney = val as ReligiousJourney;
        } else {
             dataToUpdate.religiousJourney = null;
        }
    }
    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    // Gender Logic for HeadCovering/Kippah
    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (Object.prototype.hasOwnProperty.call(body, 'kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (Object.prototype.hasOwnProperty.call(body, 'headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || [];

    // --- About ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
    if (profileHeadline !== undefined) dataToUpdate.profileHeadline = emptyStringToNull(profileHeadline);
    if (inspiringCoupleStory !== undefined) dataToUpdate.inspiringCoupleStory = emptyStringToNull(inspiringCoupleStory);
    if (influentialRabbi !== undefined) dataToUpdate.influentialRabbi = emptyStringToNull(influentialRabbi);
    
    // --- NOTES & INTERNAL DATA ---
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    
    // --- LOG 2: בדיקה לפני ההוספה לאובייקט העדכון ---
    if (internalMatchmakerNotes !== undefined) {
        console.log("✅ [Update Profile] internalMatchmakerNotes found in payload, updating to:", internalMatchmakerNotes);
        dataToUpdate.internalMatchmakerNotes = emptyStringToNull(internalMatchmakerNotes);
    } else {
        console.log("⚠️ [Update Profile] internalMatchmakerNotes is UNDEFINED in payload - skipping update.");
    }

    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    
    // --- Preferences ---
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    
    if (preferredReligiousJourneys !== undefined) {
        const validJourneys = (preferredReligiousJourneys || []).filter(j => 
            Object.values(ReligiousJourney).includes(j as ReligiousJourney)
        ) as ReligiousJourney[];
        dataToUpdate.preferredReligiousJourneys = validJourneys;
    }

    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah);
    if (preferredPartnerHasChildren !== undefined) dataToUpdate.preferredPartnerHasChildren = emptyStringToNull(preferredPartnerHasChildren);
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);

    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || [];
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || [];
    
    // --- Visibility ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
    if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
    if (isAboutVisible !== undefined) dataToUpdate.isAboutVisible = isAboutVisible;
    if (isFriendsSectionVisible !== undefined) dataToUpdate.isFriendsSectionVisible = isFriendsSectionVisible;
    if (isNeshamaTechSummaryVisible !== undefined) dataToUpdate.isNeshamaTechSummaryVisible = isNeshamaTechSummaryVisible;
   
    // --- Medical ---
    if (hasMedicalInfo !== undefined) dataToUpdate.hasMedicalInfo = hasMedicalInfo;
    if (medicalInfoDetails !== undefined) dataToUpdate.medicalInfoDetails = emptyStringToNull(medicalInfoDetails);
    if (medicalInfoDisclosureTiming !== undefined) dataToUpdate.medicalInfoDisclosureTiming = emptyStringToNull(medicalInfoDisclosureTiming);
    if (isMedicalInfoVisible !== undefined) dataToUpdate.isMedicalInfoVisible = isMedicalInfoVisible;
    if (cvUrl !== undefined) dataToUpdate.cvUrl = emptyStringToNull(cvUrl);
    if (cvSummary !== undefined) dataToUpdate.cvSummary = emptyStringToNull(cvSummary);
    
    // --- Availability ---
    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      if (!Object.prototype.hasOwnProperty.call(body, 'availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    if (Object.prototype.hasOwnProperty.call(body, 'availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // --- Perform Update ---
    let updatedProfileRecord: Profile | null = null;
    
    // --- LOG 3: האובייקט שנשלח ל-Prisma ---
    console.log("🔹 [Update Profile] Final Prisma Data Object:", JSON.stringify(dataToUpdate, null, 2));

    if (Object.keys(dataToUpdate).length > 0) {
      try {
         dataToUpdate.needsAiProfileUpdate = true;
         
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
        console.log("✅ [Update Profile] Database update successful.");
    
      } catch (dbError) {
        console.error('❌ [Update Profile] Prisma update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      console.log("⚠️ [Update Profile] No data to update provided.");
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // --- LOG 4: בדיקת הערך בדאטה בייס אחרי השמירה ---
    console.log("🔹 [Update Profile] Value in DB after update:", dbProfile.internalMatchmakerNotes);

    // Construct Response
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, 
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney || undefined,
      about: dbProfile.about || "",
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: refreshedUserWithProfile.isProfileComplete,
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      
      // ✅ ודא שזה מוחזר כאן!
      internalMatchmakerNotes: dbProfile.internalMatchmakerNotes || "", 

      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, 
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], 
      profileHobbies: dbProfile.profileHobbies || [],                 
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredLocations: dbProfile.preferredLocations || [],
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], 
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredPartnerHasChildren: dbProfile.preferredPartnerHasChildren || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], 
      preferredHobbies: dbProfile.preferredHobbies || [],                 
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, 
      cvUrl: dbProfile.cvUrl,
      cvSummary: dbProfile.cvSummary,
      aiProfileSummary: dbProfile.aiProfileSummary, 
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('❌ [Update Profile] Fatal Error:', error);
    // ... Error handling blocks
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

