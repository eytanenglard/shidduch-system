################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
# Generated on: 2026-01-05 10:08:44
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';


/**
 * POST - Creates a new testimonial from a one-time use token.
 * This is used by the public testimonial submission form.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    // 'token' is now the random hex string from the URL, not a JWT
    const { token, authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    // Basic validation
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json({ success: false, error: 'Missing required fields.' }, { status: 400 });
    }

    // Use a transaction to ensure both operations (create testimonial, update token) succeed or fail together.
    const result = await prisma.$transaction(async (tx) => {
      // 1. Find the token request. It MUST be valid and PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() },
        },
      });

      // If no valid request is found, throw an error to abort the transaction.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // 2. Create the actual testimonial record.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // Always pending user's approval
          submittedBy: 'FRIEND', // Set the source based on your schema enum
        },
      });

      // 3. IMPORTANT: Mark the token as COMPLETED so it cannot be used again.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    if (result.success) {
      return NextResponse.json({ success: true, message: 'Thank you! Your testimonial has been submitted.' });
    } else {
       // This part should not be reached if the transaction logic is correct
       throw new Error("Transaction failed unexpectedly.");
    }

  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);
    if (error instanceof Error && error.message.includes('Invalid, expired, or already used link')) {
      return NextResponse.json({ success: false, message: 'This link is invalid, has expired, or has already been used.' }, { status: 400 });
    }
    return NextResponse.json({ success: false, error: 'An internal server error occurred.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/testimonials/[testimonialId]/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

export async function PUT(req: Request, props: { params: Promise<{ testimonialId: string }> }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const { status } = await req.json() as { status: TestimonialStatus };
    if (!Object.values(TestimonialStatus).includes(status)) {
      return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
    }

    const params = await props.params;
    const updatedTestimonial = await prisma.friendTestimonial.updateMany({
      where: {
        id: params.testimonialId,
        profileId: userProfile.id,
      },
      data: { status },
    });

    if (updatedTestimonial.count === 0) {
      return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial status updated.' });
  } catch (error) {
    console.error("Error in PUT /api/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}

export async function DELETE(req: Request, props: { params: Promise<{ testimonialId: string }> }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const params = await props.params;
    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: userProfile.id,
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial deleted.' });
  } catch (error) {
    console.error("Error in DELETE /api/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

