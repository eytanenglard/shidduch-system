################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
# Generated on: 2025-12-21 02:23:04
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// 住专 转   驻注 转 专拽 住转 驻转
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// 驻拽爪 砖拽转  -metadata  转 住住 爪驻转
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    //  砖拽  住驻专  6 住驻专转
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "拽 转  转拽. 专砖 拽  6 住驻专转." },
        { status: 400 }
      );
    }

    // 爪转 拽
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "拽  转拽祝  砖驻 转拽驻" },
        { status: 400 }
      );
    }

    // 拽 砖- 转拽  转 住住 爪驻转
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "注 转 住专   转拽,  转 转 转 砖" },
        { status: 400 }
      );
    }

    // 注转 转 砖转 -hashedNewPassword , - 转
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // 注 住住 砖转 转
    await db.$transaction([
      // 注 住住
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // 注 住住 转
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "住住 注 爪"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "砖 砖转 砖 住住" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus, Language } from '@prisma/client'; 

// Zod Schema -  phone, 砖转 专, -about
const completeProfileSchema = z.object({
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),

  phone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
  religiousLevel: z.string().optional(),
  language: z.nativeEnum(Language).optional().default(Language.he),

  // 砖转 专
  engagementEmailsConsent: z.boolean().optional().default(false),
  promotionalEmailsConsent: z.boolean().optional().default(false),

  // ========== 住驻: 砖 住驻专 砖 ==========
  about: z.string().max(2000, "About text is too long").optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);

    // 拽专转 祝
    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    // 抓 砖转 爪
    const {
        firstName,
        lastName,
        phone,
        gender,
        birthDate,
        maritalStatus,
        height,
        occupation,
        education,
        religiousLevel,
        language,
        engagementEmailsConsent,
        promotionalEmailsConsent,
        about,  // ========== 住驻 ==========
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Consents received -> Engagement: ${engagementEmailsConsent}, Promotional: ${promotionalEmailsConsent}`);
    console.log(`[API /api/auth/complete-profile] About text length: ${about?.length || 0} characters`);

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);

    const updatedUser = await prisma.$transaction(async (tx) => {
      
      // 1. 注/爪专转 驻专驻 (转 Profile)
      console.log(`[API /api/auth/complete-profile] Inside transaction. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== 住驻 ==========

          // 专转 专专转 
          isProfileVisible: true,
          availabilityStatus: 'AVAILABLE',
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== 住驻 ==========

          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted.`);

      // 2. 拽  砖 注 转 转专 砖专 转
      const currentUser = await tx.user.findUnique({ 
          where: { id: userId }, 
          select: { termsAndPrivacyAcceptedAt: true } 
      });
      
      const termsDateToSet = currentUser?.termsAndPrivacyAcceptedAt ? undefined : new Date();
      if (termsDateToSet) {
          console.log(`[API /api/auth/complete-profile] User accepts terms now. Setting timestamp.`);
      }

      // 3. 注 砖转砖 (转 User)
      console.log(`[API /api/auth/complete-profile] Updating User record (names, phone, status, consents)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          firstName: firstName,
          lastName: lastName,
          phone: phone,
          isProfileComplete: true,
          language: language,

          // 注专 转 住住 爪  (转 驻)
          status: UserStatus.PENDING_PHONE_VERIFICATION,
          updatedAt: new Date(),
          
          // 注 砖转 专
          engagementEmailsConsent: engagementEmailsConsent,
          promotionalEmailsConsent: promotionalEmailsConsent,
          
          // 注 转专 砖专 转 ( 专)
          ...(termsDateToSet && { termsAndPrivacyAcceptedAt: termsDateToSet }),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true,
             engagementEmailsConsent: true,
             promotionalEmailsConsent: true
         }
      });
      
      console.log(`[API /api/auth/complete-profile] User updated. Consents saved as: Engagement=${user.engagementEmailsConsent}, Promo=${user.promotionalEmailsConsent}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Error Code: ${error.code}`);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone')) {
                 return NextResponse.json({ error: '住驻专 驻  专 专砖 注专转.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error.' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- 住驻 ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- 住祝 住驻 ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "拽砖专  转拽  砖驻 转拽驻.  拽砖 砖 砖  砖." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // 注 住住, 住住 砖转砖, 住住 转 专拽爪 转
    await prisma.$transaction(async (tx) => {
      // 注 住住, 转 , 住住 砖转砖
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- 住驻 ---
          isVerified: true, //  转  砖砖转砖 注 拽砖专
          status: UserStatus.PENDING_PHONE_VERIFICATION, // 注专 转 砖转砖 砖 
          // isProfileComplete 砖专 false   注 爪专  驻专
          // --- 住祝 住驻 ---
        },
      });

      // 注 住住 转 (拽 爪)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "砖 专 爪! 注转 转 转专 注 住住 砖." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "专注 砖 专转 砖." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `砖转 住 转 注转 拽转 砖转砖 (拽: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || '砖 拽转 砖.', status: 400 };
    }

    return { message: '专注 砖 转 爪驻 拽转 砖.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 .  转 住砖 驻注.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: '砖 拽 爪.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: '砖转砖 拽砖 拽  爪.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse, NextRequest } from "next/server"; //  NextRequest
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: NextRequest) { // 砖 -NextRequest
  try {
    // ================ 1. 砖驻转 -locale -URL ================
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    // ==========================================================

    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "砖转砖  爪" },
        { status: 404 }
      );
    }

    if (!user.password) {
      return NextResponse.json(
        { error: " 专 住住 砖 . 转 砖专砖转 爪注转 砖专转 爪." },
        { status: 400 }
      );
    }

    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "住住 转 砖" },
        { status: 400 }
      );
    }

    const hashedNewPassword = await hash(newPassword, 12);

    // 砖专转 爪专 OTP  6 住驻专转
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      24 // Expires in 24 hours
    );

    // 砖专转 住住 爪驻转 - 砖 转
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // ================ 2. 拽专 驻拽爪  注 驻专专 注 ================
    const otpCode = verification.token; // 拽 砖爪专  -OTP
    const expiresInText = locale === 'he' ? '24 砖注转' : '24 hours';

    await emailService.sendPasswordResetOtpEmail({
      locale,
      email: user.email,
      otp: otpCode,
      firstName: user.firstName,
      expiresIn: expiresInText,
    });
    // =================================================================================

    return NextResponse.json({ success: true, message: "拽 转 砖 住住 砖  砖." });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "砖 转 砖 住住" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/register/route.ts

import { NextRequest, NextResponse } from "next/server";
import { UserRole, UserStatus, Prisma, VerificationType, UserSource, Language } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 
import { applyRateLimit } from '@/lib/rate-limiter';
// ==========  转拽 拽专: 砖砖 -singleton 砖 Prisma ==========
import prisma from '@/lib/prisma';
// ==================================================================
import { 
  linkUserToReferral, 
  parseReferralCookie, 
  REFERRAL_COOKIE_NAME 
} from '@/lib/services/referralService';

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
  language?: 'he' | 'en';
  referralCode?: string;
  referralId?: string;
  referrerId?: string;
  referralLinked?: boolean;
  expiresAt?: string;
  error?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  language?: Language;
}

function handleError(error: unknown): { message: string; status: number; errorCode?: string } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: '砖转砖 注 转转   专 拽 注专转.', status: 409, errorCode: 'EMAIL_EXISTS' };
          }
          return { message: `砖转砖 注 驻专  专 拽 注专转 (拽 ${error.code}).`, status: 409, errorCode: error.code };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `砖转 转转 转 (砖: ${fieldName || ' 注'}).  住 砖转.`, status: 500, errorCode: error.code };
        }
        case 'P2014': return { message: '砖 转 砖.', status: 400, errorCode: error.code };
        // ==========  住驻: 驻 砖转 专 ==========
        case 'P1001': 
        case 'P1002':
        case 'P1003':
        case 'P1008':
        case 'P1017':
            return { 
              message: '砖转 专 砖专转.  住 砖转 注 住驻专 砖转  专砖 爪注转 砖 Google.', 
              status: 503, 
              errorCode: 'DB_CONNECTION_ERROR' 
            };
        // =====================================================
        default: 
            return { message: `砖 砖专转 转 (拽 砖转 DB: ${error.code}).`, status: 500, errorCode: error.code };
      }
    }
    
    // ==========  住驻: 驻 砖转 专 转 ==========
    if (error instanceof Prisma.PrismaClientInitializationError) {
      return { 
        message: '砖转 专 砖专转.  住 砖转 注 住驻专 砖转  专砖 爪注转 砖 Google.', 
        status: 503, 
        errorCode: 'DB_INIT_ERROR' 
      };
    }
    // ==========================================================
    
    if (error instanceof Error) {
       if (error.message === '砖转砖 注 转转   专 拽 注专转.') {
           return { message: error.message, status: 409, errorCode: 'EMAIL_EXISTS' };
       }
       if (['住专 驻专 ', '转转   转拽', '住住 转  驻转 8 转, 转 , 转 拽 住驻专'].includes(error.message)) {
           return { message: error.message, status: 400, errorCode: 'VALIDATION_ERROR' };
       }
       if (error.message.includes('专注 砖 爪专转 拽 转') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: '专注 砖 爪专转 专砖转 转 注拽 注转 转转.  住 砖转.', status: 500, errorCode: 'VERIFICATION_ERROR' };
       }
      return { message: error.message, status: 400, errorCode: 'GENERAL_ERROR' }; 
    }
    return { message: '专注 砖 转 爪驻.', status: 500, errorCode: 'UNKNOWN_ERROR' };
}


export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  logger.info('Initial registration process initiated');

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

  // 拽专转 cookie 专驻专
  let referralData: { referralId: string; code: string; expiresAt: string } | null = null;
  try {
    const refCookie = req.cookies.get(REFERRAL_COOKIE_NAME)?.value;
    if (refCookie) {
      referralData = parseReferralCookie(refCookie);
      if (referralData) {
        if (new Date(referralData.expiresAt) < new Date()) {
          logger.info('Referral cookie expired, ignoring', { 
            referralCode: referralData.code,
            expiresAt: referralData.expiresAt 
          });
          referralData = null;
        } else {
          logger.info('Referral cookie found and valid', { 
            referralCode: referralData.code,
            referralId: referralData.referralId 
          });
        }
      }
    }
  } catch (refError) {
    logger.error('Error parsing referral cookie', { 
      errorMessage: refError instanceof Error ? refError.message : String(refError) 
    });
  }

  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password,
      language: body.language,
      referralCode: referralData?.code,
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('住专 驻专 ');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('转转   转拽');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('住住 转  驻转 8 转, 转 , 转 拽 住驻专');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('砖转砖 注 转转   专 拽 注专转.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            language: body.language || 'he',
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(),
            engagementEmailsConsent: false,
            promotionalEmailsConsent: false,
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });

    // 拽砖专 砖转砖 专驻专
    let referralLinked = false;
    if (referralData) {
      try {
        logger.info('Attempting to link user to referral', { 
          userId: result.user.id, 
          referralId: referralData.referralId,
          referralCode: referralData.code 
        });
        
        const linkResult = await linkUserToReferral({
          userId: result.user.id,
          referralId: referralData.referralId,
        });
        
        if (linkResult.success) {
          referralLinked = true;
          logger.info('User successfully linked to referral', { 
            userId: result.user.id, 
            referrerId: linkResult.referrerId,
            referralCode: referralData.code 
          });
        } else {
          logger.error('Failed to link user to referral', { 
            userId: result.user.id, 
            referralId: referralData.referralId,
            error: linkResult.error 
          });
        }
      } catch (refLinkError) {
        logger.error('Error linking user to referral', { 
          userId: result.user.id,
          referralId: referralData.referralId,
          errorMessage: refLinkError instanceof Error ? refLinkError.message : String(refLinkError)
        });
      }
    }
    
    let emailSentSuccess = false;
    const emailOtpExpiryText = locale === 'he' ? "砖注 转" : "1 hour"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
        await emailService.sendVerificationEmail({
                locale,
                email: result.user.email,
                verificationCode: result.generatedOtp, 
                firstName: result.user.firstName,
                expiresIn: emailOtpExpiryText 
            });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = '砖 爪专 爪. ';
    if (emailSentSuccess) {
        responseMessage += `砖 拽 转 转转  砖 (${result.user.email}).   转 拽  砖.`;
    } else {
        responseMessage += '转 注 砖转 拽 转. 转 拽砖 拽 砖 住   驻转 转.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { 
      userId: result.user.id,
      referralLinked,
      referralCode: referralData?.code,
    });

    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id,
        referralLinked,
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status, errorCode } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        errorCode, // ==========  住驻: 拽 砖  爪 拽 ==========
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus, VerificationStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "转转   转拽" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
  
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined;

  try {
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "转转   转拽" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    logger.info('Processing password reset request', { action, email: normalizedEmail, locale });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    const genericSuccessMessage = locale === 'he'
      ? ' 拽转 转转   注专转 转 驻住 注专 住住, 拽 转 砖 注转.'
      : 'If an account with this email exists and is eligible for password reset, a code has been sent.';

    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    const finalLocale = user.language || locale;

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING,
        },
        data: {
            status: VerificationStatus.EXPIRED,
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60 
    );
    logger.info('New password reset OTP created', { action, userId: user.id, verificationId: passwordResetVerification.id });

    try {
      const expiresInText = finalLocale === 'he' ? `${expiresInMinutes} 拽转` : `${expiresInMinutes} minutes`;

      await emailService.sendPasswordResetOtpEmail({
         locale: finalLocale,
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: expiresInText,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    const errorMessage = locale === 'he'
      ? '专注 砖 转.  住 砖转 专 转专.'
      : 'An error occurred. Please try again later.';

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

// --- 专转 ---
const RESEND_RATE_LIMIT_SECONDS = 60; //  转 砖转  拽砖转 专转

// --- 专 注专  ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => {
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta }));
    },
    warn: (message: string, meta?: Record<string, unknown>) => {
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta }));
    },
    error: (message: string, meta?: any) => {
      let logMeta = meta || {};
      if (meta instanceof Error) {
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
};

// --- 驻拽爪转 -API 专砖转 ---
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
    if (rateLimitResponse) {
        return rateLimitResponse;
    }

    logger.info("Resend phone code request received");

    // 1. --- 拽转 转 砖转砖 ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });

    try {
        // ============================ 转拽 专 (1 转 2) ============================
        // 2. --- 拽专转 砖驻 (locale) 驻专专 -URL ---
        const url = new URL(req.url);
        // 专转 注专转 砖驻转 专专转   驻专专  拽
        const locale = (url.searchParams.get('locale') || 'he') as 'he' | 'en';
        logger.info("Processing request with locale", { userId, locale });
        // =================================================================================

        // 3. --- 转专 拽砖转 转 专 砖 砖转砖 ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc'
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            return NextResponse.json({ error: ' 爪 拽砖转 转 驻注. 转 砖专 转转 转 住驻专  砖拽 驻 转拽祝.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });

        // 4. --- 拽转 转 拽爪 (Rate Limiting) ---
        const now = new Date();
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: ` 转 ${timeLeft} 砖转 驻 拽砖转 拽 砖.` }, { status: 429 });
        }
        logger.info("Rate limit check passed", { userId });

        // 5. --- 拽注转 住驻专 驻 砖 ---
        let targetPhone = lastVerification.target;
        let userFirstName = session.user.firstName || '';

        // 拽专 砖住驻专 驻  砖专 专砖转 转, 砖祝 转 砖转砖
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true }
             });
             if (!user?.phone) {
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                return NextResponse.json({ error: '砖:  转 转专 转 住驻专 驻 砖转 拽.' }, { status: 500 });
             }
             targetPhone = user.phone;
             userFirstName = user.firstName || '';
        }
        
        // 6. --- 爪专转 拽 砖 转专 转驻 砖 ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 转拽祝 -10 拽转
        logger.info("Generated new OTP", { userId });

        // 7. --- 注 专砖转 转 住 转 ---
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // 驻住  住转
                createdAt: new Date() // 注 转转  拽转 -rate limit 
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });

        // ============================ 转拽 专 (2 转 2) ============================
        // 8. --- 砖转 拽 砖, 转 注专转 砖驻 (locale) 砖专转 砖 ---
        // 注专: 砖  砖驻拽爪 `sendOtpViaWhatsApp`  拽转 驻专专 专注 砖 砖驻
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone, locale });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName,
        );
        // =================================================================================

        if (!otpSent) {
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            return NextResponse.json({ error: '砖转 拽 转 砖 爪注转 WhatsApp 砖.  住 砖 注 住驻专 专注.' }, { status: 500 });
        }

        // 9. --- 专转 转砖转 爪 ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: '拽 转 砖 砖 爪 爪注转 WhatsApp.' }, { status: 200 });

    } catch (error: unknown) {
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id,
            error: error
        });
        return NextResponse.json({ error: '专注 砖 驻转 砖专转. 住 砖 专 转专.' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification/route.ts

import { NextResponse, NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * 驻 拽砖转 砖 专转 砖 拽 转 .
 * 拽转 拽爪  注 砖转砖 砖专砖   拽 转 拽 转 专砖.
 */
export async function POST(req: NextRequest) {
  // 1. 转 拽爪 拽砖转 注转 砖砖 专注 砖转 住驻
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. 砖驻转 砖驻转 砖拽 -URL 爪专 转专 
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. 拽专转 转 祝 拽砖
    const body = await req.json();
    const { email } = body;

    if (!email || typeof email !== 'string') {
      return NextResponse.json(
        { success: false, error: "转转   砖 ." },
        { status: 400 }
      );
    }

    const normalizedEmail = email.toLowerCase();

    // 4. 转专 砖转砖 住 转
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    });

    // 拽转 拽爪 拽专转
    if (!user) {
      return NextResponse.json(
        { success: false, error: " 爪 砖转砖 注 转转  ." },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { success: false, error: "砖  专 转. 转 转专." },
        { status: 400 }
      );
    }

    // 5. 爪专转 拽 转 砖 爪注转 砖专转 转 专
    // 砖专转   转拽祝 砖 拽 拽 砖专 爪.
    const expiresInHours = 1; // 转拽祝 砖注
    const { otp: verificationCode } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email,
        expiresInHours
    );

    console.log(`[Resend Verification] New OTP generated for user: ${user.id}`);

    // 6. 砖转  转 砖 注 拽 砖爪专, 转 砖驻 砖专
    const expiresInText = locale === 'he' ? '砖注 转' : '1 hour';
    
    await emailService.sendVerificationEmail({
      locale, // 注专转 驻专专 砖驻
      email: user.email,
      verificationCode: verificationCode,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Resend Verification] Verification email sent successfully to ${user.email} in ${locale}`);

    // 7. 专转 转砖转 爪 拽
    return NextResponse.json({
      success: true,
      message: " 转 砖 砖 爪."
    });

  } catch (error: unknown) {
    // 8. 驻 砖转  爪驻转
    console.error('[API Resend Verification] A critical error occurred:', error);
    
    const errorMessage = error instanceof Error ? error.message : "砖  爪驻 砖转  转.";
    
    return NextResponse.json(
        { success: false, error: "专注 砖 转,  住 砖转 专 转专.", details: errorMessage }, 
        { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification-code/route.ts

import { NextResponse, NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { VerificationType, UserStatus } from '@prisma/client';
import { applyRateLimit } from '@/lib/rate-limiter';

// 专转 驻住 注 砖专 
type LogMetadata = {
  email?: string;
  error?: unknown;
  userId?: string;
  verificationId?: string;
  status?: UserStatus;
  isVerified?: boolean;
};

// 拽 专 驻砖 注拽
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: NextRequest) {
  // 1. 转 拽爪 拽砖转
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  let requestBody: ResendCodeRequest | null = null;
  try {
    // 2. 砖驻转 砖驻转 砖拽 -URL
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. 拽专转 转 祝 拽砖
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });

    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: '住专 转转 .' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    
    // 4. 转专 砖转砖 爪
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail });
      return NextResponse.json({ success: false, error: '砖转砖 注 转转    专砖.' }, { status: 404 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        logger.warn('User email already verified or not pending verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: '转转  专 转转  砖 转 转.' }, { status: 400 });
    }
    
    // 5. 爪专转 拽 转 砖 专 砖专转 专
    const expiresInHoursForOtp = 1;
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHoursForOtp
    );
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });

    // 6. 砖转  注 拽 砖 砖驻 
    const emailOtpExpiryText = locale === 'he' ? "砖注 转" : "1 hour";
    await emailService.sendVerificationEmail({
      locale, // <<<<<<<<<<<< 注专转 -locale
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    // 7. 专转 转砖转 爪
    return NextResponse.json({
      success: true,
      message: `拽 转 砖 砖 转转 ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    // 8. 驻 砖转  爪驻转
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails });

    let errorMessage = '专注 砖 砖 专转 砖 拽.';
    const errorStatus = 500;

    if (error instanceof Error && error.message.includes('专注 砖 爪专转 拽 转')) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { hash } from 'bcryptjs';
import { z } from 'zod';

const resetPasswordSchema = z.object({
  email: z.string().email({ message: "转转   转拽" }),
  otp: z.string()
    .length(6, { message: "拽 转   6 住驻专转" })
    .regex(/^\d+$/, { message: "拽 转   住驻专转 " }),
  newPassword: z.string()
    .min(8, { message: "住住 转  驻转 8 转" })
    .regex(/[a-z]/, { message: "住住 转  驻转 转 拽 转 转" })
    .regex(/[A-Z]/, { message: "住住 转  驻转 转  转 转" })
    .regex(/[0-9]/, { message: "住住 转  驻转 住驻专 转" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "reset-password-with-otp";
  let requestBody: { email?: string } | undefined;

  try {
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '15 m' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action, locale });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "转  转拽.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];

      logger.warn('Invalid input for password reset', { action, error: errors });
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });
    
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      logger.error('OTP verification failed unexpectedly or did not return required data', {
        action,
        email: normalizedEmail,
        error: verificationResult.message,
      });
      throw new Error(verificationResult.message || '砖 转 拽.');
    }

    const { userId, id: verificationId } = verificationResult;
    logger.info('OTP verified successfully', { action, userId, verificationId });

    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
      },
      select: { email: true, firstName: true, language: true }
    });
    logger.info('User password updated in database', { action, userId });

    await VerificationService.completeVerification(verificationId);
    logger.info('Verification record marked as completed', { action, verificationId });

    if (user) {
      try {
        await emailService.sendPasswordChangedConfirmationEmail({
         locale: user.language || locale,
          email: user.email,
          firstName: user.firstName,
        });
        logger.info('Password change confirmation email sent', { action, userId, locale: user.language || locale });
      } catch (emailError) {
        logger.error('Failed to send password change confirmation email', {
          action,
          userId,
          error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
        });
      }
    }

    const successMessage = (user.language || locale) === 'he'
      ? '住住 驻住 爪. 注转 转 转专 注 住住 砖.'
      : 'Password has been reset successfully. You can now log in with your new password.';
      
    return NextResponse.json({ success: true, message: successMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    let errorMessage = '专注 砖 驻住 住住.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '拽 专 爪.',
        '转拽祝 拽 驻.  拽砖 拽 砖.',
        '拽 转  转拽  砖 拽转 拽砖转 转 驻注.',
        '拽 转 砖.',
        '专转 住驻专 住转 转 转专.  拽砖 拽 砖.',
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400;
        if (error.message.includes("驻 转拽驻")) errorStatus = 410;
        if (error.message.includes("专转 住驻专 住转")) errorStatus = 429;
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 requests per user per hour (costly SMS/WhatsApp)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. 拽 转 驻专 砖转砖 -DB (注拽专 住驻专 驻)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // 砖   专 拽专转  砖转砖 注  专 砖转 驻专驻
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. 爪专转 OTP 砖
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 拽转 转驻

        // 3. 砖专转/注 专砖转 转
        // 拽 专砖转 拽转 转 砖转砖  注 
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // 爪专 专砖 砖
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. 砖转 -OTP 住驻
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // 专 砖  砖拽  爪 注 转
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/send-verification/route.ts

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { VerificationType, UserStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

export const runtime = 'nodejs';

/**
 * Handles requests to send a new email verification code to an existing, unverified user.
 */
export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting to prevent email spam
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. Parse and Validate Request Body
    const { email } = await req.json();
    if (!email || typeof email !== 'string') {
      return NextResponse.json({ success: false, error: "  砖 " }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 4. Find the user and perform necessary checks
    const user = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (!user) {
      // Security: Return a generic message even if the user doesn't exist to prevent enumeration.
      return NextResponse.json({ success: true, message: " 拽 砖 砖  , 砖  拽 转." }, { status: 200 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        return NextResponse.json({ success: false, error: "砖  专 转  砖 转 转." }, { status: 400 });
    }

    // 5. Create a new verification OTP using the central service
    const expiresInHours = 1; // 1-hour validity for the new code
    const { otp: generatedOtp } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHours
    );

    console.log(`[Send Verification] New OTP generated for user: ${user.id}`);

    // 6. Send the verification email using the updated Email Service
    const expiresInText = locale === 'he' ? '砖注 转' : '1 hour';
    await emailService.sendVerificationEmail({
      locale, // <-- Pass the correct locale
      email: user.email,
      verificationCode: generatedOtp,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Send Verification] Verification email re-sent successfully to ${user.email} in ${locale}`);

    // 7. Return a success response
    return NextResponse.json({ success: true, message: "拽 转 砖 砖 爪." }, { status: 200 });

  } catch (error) {
    // 8. Handle unexpected errors
    console.error('[API Send Verification] A critical error occurred:', error);
    const errorMessage = error instanceof Error ? error.message : "砖  爪驻 砖转 拽 转.";
    return NextResponse.json(
      { success: false, error: "专注 砖 转,  住 砖转 专 转专.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
});


export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. 拽 砖住驻专 砖  转驻住 注  砖转砖 转 专
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } //  砖转砖 
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: '住驻专 驻 专 专砖 驻注 注专转 注专 砖转砖 专.' }, { status: 409 }); // Conflict
          }

        // 2. 注 转 住驻专 驻 砖 砖转砖
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // 拽 转 砖 注  爪专
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. 爪专 OTP 砖
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 拽转 转驻

        // 4. 爪专/注 专砖转 转 注专 住驻专 砖
        //  专砖转 拽转  
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // 住 拽 驻 转拽祝
         });
         // 爪专 专砖 砖
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // 住驻专 砖
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. 砖 转 -OTP 住驻专 砖
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // 专 砖, 转 砖住驻专 砖  转拽 住驻
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // 专转 error -unknown
        console.error("API update-and-resend: An error occurred:", error);

        // 驻 砖转 住驻爪驻转
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // 砖转 驻转 - 专转 砖拽, 转 爪 race condition
            return NextResponse.json({ error: '住驻专 驻 专 专砖 注专转.' }, { status: 409 });
        }

        // 砖 转
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId   转 string  undefined    拽 
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 verification attempts per IP per 15 minutes (prevents brute-force)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '15 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: '住专 驻专   拽.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `驻专 拽  转拽. 拽 爪专  ${OTP_LENGTH_FROM_SERVICE} 住驻专转.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- 转拽 转  ---
    //  砖-userId 拽  专转 驻 砖砖
    // 住专  砖-verificationResult.userId  转 string | null
    // 注 驻 专 砖 VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // 专拽 砖 砖转驻 拽 -catch ,  驻  驻 住驻爪驻 转专
      // 砖  爪注 注 注 转 驻转  拽 转   砖转砖 砖
      throw new Error('砖 驻转:  爪 砖转砖 砖 转 专 转 拽 爪.');
    }
    
    // 注转, 专 拽, TypeScript  住拽 ( 砖 爪专 驻专砖)
    // 砖-userId  string.
    const userId: string = verificationResult.userId; 
    // --- 住祝 转拽 ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, //  userId  转 string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: '转转  转 爪! 转爪注转 转专转 转...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = '专注 砖 转 拽.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '拽 专 爪.', 
        '转拽祝 拽 驻.  拽砖 拽 砖.', 
        '拽 转  转拽  砖 拽转 拽砖转 转 驻注.', 
        '拽 转 砖.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === '砖 驻转:  爪 砖转砖 砖 转.' || 
                 error.message === '砖 驻转:  爪 砖转砖 砖 转 专 转 拽 爪.') { // 住驻转 砖 砖  专爪 驻 
        errorMessage = '专注 砖 驻转.  住 砖转 专 转专.';
        // errorStatus 砖专 500 专专转  砖转 驻转,  砖转砖 驻 爪专
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/verify-phone-code/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { z } from 'zod';
import { Prisma, VerificationType, UserStatus } from '@prisma/client';

import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { emailService } from '@/lib/email/emailService';
// ==========  住驻 砖:  驻拽爪转 注 专驻专 ==========
import { updateReferralStatus } from '@/lib/services/referralService';
// ==============================================================

const MAX_VERIFICATION_ATTEMPTS = 5;

const verifyCodeSchema = z.object({
  code: z.string()
    .length(6, { message: "拽 转   6 住驻专转" })
    .regex(/^\d+$/, { message: "驻专 拽  转拽, 住驻专转 " }),
});

const logger = {
    info: (message: string, meta?: Record<string, unknown>) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
    warn: (message: string, meta?: Record<string, unknown>) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
    error: (message: string, meta?: Record<string, unknown>) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "verify-phone-code";

  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      logger.warn("住 转 驻  住砖 驻注", { action });
      return NextResponse.json({ error: 'Unauthorized - 专砖转 转专转' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("转 转 驻  注专 砖转砖", { action, userId });

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    logger.info("砖驻转 砖拽 转", { action, userId, locale });

    const body = await req.json();
    const validation = verifyCodeSchema.safeParse(body);

    if (!validation.success) {
      logger.warn("转  转拽 拽砖", { action, userId, errors: validation.error.flatten() });
      return NextResponse.json({ error: '转  转拽', details: validation.error.flatten() }, { status: 400 });
    }
    const { code } = validation.data;

    const verification = await prisma.verification.findFirst({
        where: {
            userId: userId,
            type: VerificationType.PHONE_WHATSAPP,
            status: 'PENDING',
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    if (!verification) {
      logger.warn(" 爪 拽砖转 转 驻 驻注", { action, userId });
      return NextResponse.json({ error: ' 爪 拽砖转 转 驻注  砖砖 专 转.' }, { status: 404 });
    }

    if (new Date() > verification.expiresAt) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'EXPIRED' }
        });
        logger.warn("住 砖转砖 拽 砖驻 转拽驻", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '拽 转 驻 转拽祝.  拽砖 拽 砖.' }, { status: 410 });
    }

    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'FAILED' }
        });
        logger.warn("专 住驻专 住转 转", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '专转 住驻专 住转 转 转专.  拽砖 拽 砖.' }, { status: 429 });
    }

    if (verification.token !== code) {
        const updatedVerification = await prisma.verification.update({
            where: { id: verification.id },
            data: { attempts: { increment: 1 } }
        });
        const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - updatedVerification.attempts;
        logger.warn(" 拽 转 砖", { action, userId, attemptsLeft });
        return NextResponse.json({ error: `拽 转 砖. 转专  ${attemptsLeft} 住转.` }, { status: 400 });
    }

    const [, updatedUser] = await prisma.$transaction([
        prisma.verification.update({
            where: { id: verification.id },
            data: {
                status: 'COMPLETED',
                completedAt: new Date(),
                attempts: verification.attempts + 1
             }
        }),
        prisma.user.update({
            where: { id: userId },
            data: {
                isPhoneVerified: true,
                isProfileComplete: true,
                status: UserStatus.ACTIVE,
                updatedAt: new Date(),
            },
            select: {
                id: true,
                email: true,
                firstName: true,
                language: true, 
                isPhoneVerified: true,
                isProfileComplete: true,
                status: true,
             }
        })
    ]);
    
    logger.info("转 驻 砖 爪, 砖转砖 专 驻注", { action, userId });

    // ==========  住驻 砖: 注 住住 专驻专 -VERIFIED ==========
    try {
      logger.info("住 注 住住 专驻专 -VERIFIED", { action, userId });
      
      const referralUpdateResult = await updateReferralStatus({
        userId: userId,
        newStatus: 'VERIFIED',
      });
      
      if (referralUpdateResult.success) {
        logger.info("住住 专驻专 注 爪 -VERIFIED", { 
          action, 
          userId,
          referralId: referralUpdateResult.referralId,
          referrerId: referralUpdateResult.referrerId,
          newVerifiedCount: referralUpdateResult.newVerifiedCount
        });
      } else if (referralUpdateResult.error === 'NO_REFERRAL') {
        // 砖转砖  注 专驻专 -  转拽
        logger.info("砖转砖  专驻专 拽砖专, 砖 专", { action, userId });
      } else {
        logger.warn(" 爪 注 住住 专驻专", { 
          action, 
          userId,
          error: referralUpdateResult.error 
        });
      }
    } catch (referralError) {
      //  注爪专 转 转  砖转 专驻专
      logger.error("砖 注 住住 专驻专", { 
        action, 
        userId, 
        error: referralError instanceof Error ? referralError.message : String(referralError)
      });
    }
    // =================================================================

    try {
        await emailService.sendWelcomeEmail({
            locale: updatedUser.language || locale,
            email: updatedUser.email,
            firstName: updatedUser.firstName || '专',
            dashboardUrl: '/profile'
        });
        logger.info(" 专  砖 爪", { action, userId, email: updatedUser.email, locale: updatedUser.language || locale });
    } catch (emailError) {
        logger.error("砖 砖转  专  专 转 驻", { action, userId, error: emailError });
    }

    return NextResponse.json({
         success: true,
         message: '转 驻 砖 爪!',
         user: updatedUser
    }, { status: 200 });

  } catch (error) {
    const userId = (await getServerSession(authOptions))?.user?.id || 'unknown';
    logger.error("砖 拽专转 转 转 驻", { action, userId, error });

    if (error instanceof z.ZodError) {
        return NextResponse.json({ error: '转  转拽 拽砖', details: error.flatten() }, { status: 400 });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        return NextResponse.json({ error: '砖转 住 转 转 转' }, { status: 500 });
    }
    
    return NextResponse.json({ error: '专注 砖 驻转 砖专转.  住 砖转 专 转专.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

