################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
# Generated on: 2026-02-13 14:18:26
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// ×”×¡×¨ ××ª ×”×œ×•×’×™× ××• ×”×¤×¢×œ ××•×ª× ×¨×§ ×‘×¡×‘×™×‘×ª ×¤×™×ª×•×—
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// ×¤×•× ×§×¦×™×” ×©×‘×•×“×§×ª ×× ×”-metadata ××›×™×œ ××ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // ×•×™×“×•× ×©×”×˜×•×§×Ÿ ×”×•× ××¡×¤×¨×™ ×‘×Ÿ 6 ×¡×¤×¨×•×ª
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ. × ×“×¨×© ×§×•×“ ×‘×Ÿ 6 ×¡×¤×¨×•×ª." },
        { status: 400 }
      );
    }

    // ××¦×™××ª ×”×˜×•×§×Ÿ
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "×§×•×“ ×œ× ×ª×§×£ ××• ×©×¤×’ ×ª×•×§×¤×•" },
        { status: 400 }
      );
    }

    // ×‘×“×™×§×” ×©×”××˜×-×“××˜×” ×ª×§×™×Ÿ ×•××›×™×œ ××ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "××™×“×¢ ××™××•×ª ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ, ×× × ×”×ª×—×œ ××ª ×”×ª×”×œ×™×š ××—×“×©" },
        { status: 400 }
      );
    }

    // ×›×¢×ª × ×™×ª×Ÿ ×œ×’×©×ª ×œ-hashedNewPassword ×‘×‘×˜×—×”, ×”××˜×-×“××˜×” ××•××ª
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // ×¢×“×›×•×Ÿ ×”×¡×™×¡××” ×•×”×©×œ××ª ×”××™××•×ª
    await db.$transaction([
      // ×¢×“×›×•×Ÿ ×¡×™×¡××”
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×”××™××•×ª
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "×”×¡×™×¡××” ×¢×•×“×›× ×” ×‘×”×¦×œ×—×”"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "×©×’×™××” ×‘×”×©×œ××ª ×©×™× ×•×™ ×”×¡×™×¡××”" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus, Language } from '@prisma/client';

const normalizePhone = (val: unknown) => {
  if (typeof val !== 'string') return val;
  // ×× ××ª×—×™×œ ×‘ +9720, ××—×œ×™×¤×™× ×‘ +972
  if (val.startsWith('+9720')) {
    return val.replace('+9720', '+972');
  }
  return val;
};
// Zod Schema - ×›×•×œ×œ phone, ×©×“×•×ª ×“×™×•×•×¨, ×•-about
const completeProfileSchema = z.object({
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),

 phone: z.preprocess(
    normalizePhone,
    z.string().refine(
      (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
      { message: "Invalid international phone number format (E.164 required)." }
    )
  ),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  
  // ×”×•×¡×¤×ª ×©×“×” ×¢×™×¨ ×›×—×•×‘×”
  city: z.string().min(1, "City is required"),
  origin: z.string().optional(), 

  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
  religiousLevel: z.string().optional(),
  language: z.nativeEnum(Language).optional().default(Language.he),

  // ×©×“×•×ª ×“×™×•×•×¨
  engagementEmailsConsent: z.boolean().optional().default(false),
  promotionalEmailsConsent: z.boolean().optional().default(false),

  // ========== ×”×•×¡×¤×”: ×©×“×” ×”×¡×™×¤×•×¨ ×©×œ×™ ==========
  about: z.string().max(2000, "About text is too long").optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);

    // ×§×¨×™××ª ×”×’×•×£
    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    // ×—×™×œ×•×¥ ×”××©×ª× ×™× ××”×•×•×œ×™×“×¦×™×”
    const {
        firstName,
        lastName,
        phone,
        gender,
        birthDate,
        maritalStatus,
        city, // ×—×™×œ×•×¥ ×”×¢×™×¨
        origin,
        height,
        occupation,
        education,
        religiousLevel,
        language,
        engagementEmailsConsent,
        promotionalEmailsConsent,
        about,  // ========== ×”×•×¡×¤×” ==========
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Consents received -> Engagement: ${engagementEmailsConsent}, Promotional: ${promotionalEmailsConsent}`);
    console.log(`[API /api/auth/complete-profile] About text length: ${about?.length || 0} characters`);
    console.log(`[API /api/auth/complete-profile] City received: ${city}`);

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);

    const updatedUser = await prisma.$transaction(async (tx) => {
      
      // 1. ×¢×“×›×•×Ÿ/×™×¦×™×¨×ª ×”×¤×¨×•×¤×™×œ (×˜×‘×œ×ª Profile)
      console.log(`[API /api/auth/complete-profile] Inside transaction. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          city: city, // ×©××™×¨×ª ×”×¢×™×¨
          origin: origin,
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== ×”×•×¡×¤×” ==========

          // ×”×’×“×¨×•×ª ×‘×¨×™×¨×ª ××—×“×œ
          isProfileVisible: true,
          availabilityStatus: 'AVAILABLE',
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          city: city, // ×¢×“×›×•×Ÿ ×”×¢×™×¨
          origin: origin,
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== ×”×•×¡×¤×” ==========

          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted.`);

      // 2. ×‘×“×™×§×” ×”×× ×™×© ×œ×¢×“×›×Ÿ ××ª ×ª××¨×™×š ××™×©×•×¨ ×”×ª× ××™×
      const currentUser = await tx.user.findUnique({ 
          where: { id: userId }, 
          select: { termsAndPrivacyAcceptedAt: true } 
      });
      
      const termsDateToSet = currentUser?.termsAndPrivacyAcceptedAt ? undefined : new Date();
      if (termsDateToSet) {
          console.log(`[API /api/auth/complete-profile] User accepts terms now. Setting timestamp.`);
      }

      // 3. ×¢×“×›×•×Ÿ ×”××©×ª××© (×˜×‘×œ×ª User)
      console.log(`[API /api/auth/complete-profile] Updating User record (names, phone, status, consents)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          firstName: firstName,
          lastName: lastName,
          phone: phone,
          isProfileComplete: true,
          language: language,

          // ××¢×‘×™×¨×™× ××ª ×”×¡×˜×˜×•×¡ ×œ××¦×‘ ×”×‘× (××™××•×ª ×˜×œ×¤×•×Ÿ)
          status: UserStatus.PENDING_PHONE_VERIFICATION,
          updatedAt: new Date(),
          
          // ×¢×“×›×•×Ÿ ×©×“×•×ª ×”×“×™×•×•×¨
          engagementEmailsConsent: engagementEmailsConsent,
          promotionalEmailsConsent: promotionalEmailsConsent,
          
          // ×¢×“×›×•×Ÿ ×ª××¨×™×š ××™×©×•×¨ ×ª× ××™× (×× ×¨×œ×•×•× ×˜×™)
          ...(termsDateToSet && { termsAndPrivacyAcceptedAt: termsDateToSet }),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true,
             engagementEmailsConsent: true,
             promotionalEmailsConsent: true
         }
      });
      
      console.log(`[API /api/auth/complete-profile] User updated. Consents saved as: Engagement=${user.engagementEmailsConsent}, Promo=${user.promotionalEmailsConsent}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Error Code: ${error.code}`);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone')) {
                 return NextResponse.json({ error: '××¡×¤×¨ ×˜×œ×¤×•×Ÿ ×–×” ×›×‘×¨ ×¨×©×•× ×‘××¢×¨×›×ª.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error.' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- ×”×•×¡×¤×” ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- ×¡×•×£ ×”×•×¡×¤×” ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "×§×™×©×•×¨ ×œ× ×ª×§×™×Ÿ ××• ×©×¤×’ ×ª×•×§×¤×•. ×× × ×‘×§×© ××”×©×“×›×Ÿ ×œ×©×œ×•×— ×”×–×× ×” ×—×“×©×”." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // ×¢×“×›×•×Ÿ ×”×¡×™×¡××”, ×¡×˜×˜×•×¡ ×”××©×ª××©, ×•×¡×˜×˜×•×¡ ×”××™××•×ª ×‘×˜×¨× ×–×§×¦×™×” ××—×ª
    await prisma.$transaction(async (tx) => {
      // ×¢×“×›×•×Ÿ ×¡×™×¡××”, ××™××•×ª ××™×™×œ, ×•×¡×˜×˜×•×¡ ×”××©×ª××©
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- ×”×•×¡×¤×” ---
          isVerified: true, // ×”××™×™×œ ××•××ª ××›×™×•×•×Ÿ ×©×”××©×ª××© ×”×’×™×¢ ××”×§×™×©×•×¨
          status: UserStatus.PENDING_PHONE_VERIFICATION, // ×”×¢×‘×¨ ××ª ×”××©×ª××© ×œ×©×œ×‘ ×”×‘×
          // isProfileComplete × ×©××¨ false ×›×™ ×”×•× ×¢×“×™×™×Ÿ ×¦×¨×™×š ×œ××œ× ×¤×¨×˜×™×
          // --- ×¡×•×£ ×”×•×¡×¤×” ---
        },
      });

      // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×”××™××•×ª (×”×˜×•×§×Ÿ × ×•×¦×œ)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "×”×—×©×‘×•×Ÿ ×”×•×’×“×¨ ×‘×”×¦×œ×—×”! ×›×¢×ª × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨ ×¢× ×”×¡×™×¡××” ×”×—×“×©×”." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×”×’×“×¨×ª ×”×—×©×‘×•×Ÿ." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘×¢×ª ××—×™×§×ª ×”××©×ª××© (×§×•×“: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || '×©×’×™××” ×‘××—×™×§×ª ×”×—×©×‘×•×Ÿ.', status: 400 };
    }

    return { message: '××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×” ×‘××—×™×§×ª ×”×—×©×‘×•×Ÿ.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. ×œ× ×–×•×”×ª×” ×¡×©×Ÿ ×¤×¢×™×œ.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: '×”×—×©×‘×•×Ÿ × ××—×§ ×‘×”×¦×œ×—×”.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: '×”××©×ª××© ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse, NextRequest } from "next/server"; // ×™×™×‘×•× NextRequest
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: NextRequest) { // ×©×™× ×•×™ ×œ-NextRequest
  try {
    // ================ 1. ×©×œ×™×¤×ª ×”-locale ××”-URL ================
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    // ==========================================================

    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "××©×ª××© ×œ× × ××¦×" },
        { status: 404 }
      );
    }

    if (!user.password) {
      return NextResponse.json(
        { error: "×œ× ×”×•×’×“×¨×” ×¡×™×¡××” ×œ×—×©×‘×•×Ÿ ×–×”. ×™×™×ª×›×Ÿ ×©× ×¨×©××ª ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×—×™×¦×•× ×™." },
        { status: 400 }
      );
    }

    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "×¡×™×¡××” × ×•×›×—×™×ª ×©×’×•×™×”" },
        { status: 400 }
      );
    }

    const hashedNewPassword = await hash(newPassword, 12);

    // ×”×©×™×¨×•×ª ×™×•×¦×¨ OTP ×‘×Ÿ 6 ×¡×¤×¨×•×ª
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      24 // Expires in 24 hours
    );

    // ×©××™×¨×ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª ×‘××˜×-×“××˜×” ×©×œ ×”××™××•×ª
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // ================ 2. ×§×¨×™××” ×œ×¤×•× ×§×¦×™×” ×”× ×›×•× ×” ×¢× ×”×¤×¨××˜×¨×™× ×”××¢×•×“×›× ×™× ================
    const otpCode = verification.token; // ×”×˜×•×§×Ÿ ×©× ×•×¦×¨ ×”×•× ×”-OTP
    const expiresInText = locale === 'he' ? '24 ×©×¢×•×ª' : '24 hours';

    await emailService.sendPasswordResetOtpEmail({
      locale,
      email: user.email,
      otp: otpCode,
      firstName: user.firstName,
      expiresIn: expiresInText,
    });
    // =================================================================================

    return NextResponse.json({ success: true, message: "×§×•×“ ××™××•×ª ×œ×©×™× ×•×™ ×¡×™×¡××” × ×©×œ×— ×œ××™×™×œ ×©×œ×š." });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "×©×’×™××” ×‘×ª×”×œ×™×š ×©×™× ×•×™ ×”×¡×™×¡××”" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/register/route.ts

import { NextRequest, NextResponse } from "next/server";
import { UserRole, UserStatus, Prisma, VerificationType, UserSource, Language, Gender } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 
import { applyRateLimit } from '@/lib/rate-limiter';
// ×©×™××•×© ×‘-singleton ×©×œ Prisma
import prisma from '@/lib/prisma';
import { 
  linkUserToReferral, 
  parseReferralCookie, 
  REFERRAL_COOKIE_NAME 
} from '@/lib/services/referralService';

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
  language?: 'he' | 'en';
  referralCode?: string;
  referralId?: string;
  referrerId?: string;
  referralLinked?: boolean;
  expiresAt?: string;
  error?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  language?: Language;
}

function handleError(error: unknown): { message: string; status: number; errorCode?: string } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.', status: 409, errorCode: 'EMAIL_EXISTS' };
          }
          return { message: `××©×ª××© ×¢× ×¤×¨×˜×™× ××œ×” ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª (×§×•×“ ${error.code}).`, status: 409, errorCode: error.code };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `×©×’×™××ª ×ª×œ×•×ª ×‘× ×ª×•× ×™× (×©×“×”: ${fieldName || '×œ× ×™×“×•×¢'}). ×× × × ×¡×” ×©× ×™×ª.`, status: 500, errorCode: error.code };
        }
        case 'P2014': return { message: '×©×’×™××” ×‘× ×ª×•× ×™× ×©×”×•×–× ×•.', status: 400, errorCode: error.code };
        case 'P1001': 
        case 'P1002':
        case 'P1003':
        case 'P1008':
        case 'P1017':
            return { 
              message: '×©×’×™××ª ×—×™×‘×•×¨ ×œ×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×‘×¢×•×“ ××¡×¤×¨ ×©× ×™×•×ª ××• ×”×™×¨×©× ×‘×××¦×¢×•×ª ×—×©×‘×•×Ÿ Google.', 
              status: 503, 
              errorCode: 'DB_CONNECTION_ERROR' 
            };
        default: 
            return { message: `×©×’×™××” ×‘×©××™×¨×ª ×”× ×ª×•× ×™× (×§×•×“ ×©×’×™××ª DB: ${error.code}).`, status: 500, errorCode: error.code };
      }
    }
    
    if (error instanceof Prisma.PrismaClientInitializationError) {
      return { 
        message: '×©×’×™××ª ×—×™×‘×•×¨ ×œ×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×‘×¢×•×“ ××¡×¤×¨ ×©× ×™×•×ª ××• ×”×™×¨×©× ×‘×××¦×¢×•×ª ×—×©×‘×•×Ÿ Google.', 
        status: 503, 
        errorCode: 'DB_INIT_ERROR' 
      };
    }
    
    if (error instanceof Error) {
       if (error.message === '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.') {
           return { message: error.message, status: 409, errorCode: 'EMAIL_EXISTS' };
       }
       if (['×—×¡×¨×™× ×¤×¨×˜×™× ×—×•×‘×”', '×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”', '×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×, ××•×ª ×’×“×•×œ×”, ××•×ª ×§×˜× ×” ×•××¡×¤×¨'].includes(error.message)) {
           return { message: error.message, status: 400, errorCode: 'VALIDATION_ERROR' };
       }
       if (error.message.includes('××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×§×•×“ ××™××•×ª') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: '××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×¨×©×•××ª ×”××™××•×ª ×¢×§×‘ ×‘×¢×™×™×ª ×ª×œ×•×ª. ×× × × ×¡×” ×©× ×™×ª.', status: 500, errorCode: 'VERIFICATION_ERROR' };
       }
      return { message: error.message, status: 400, errorCode: 'GENERAL_ERROR' }; 
    }
    return { message: '××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×”.', status: 500, errorCode: 'UNKNOWN_ERROR' };
}


export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  logger.info('Initial registration process initiated');

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

  let referralData: { referralId: string; code: string; expiresAt: string } | null = null;
  try {
    const refCookie = req.cookies.get(REFERRAL_COOKIE_NAME)?.value;
    if (refCookie) {
      referralData = parseReferralCookie(refCookie);
      if (referralData) {
        if (new Date(referralData.expiresAt) < new Date()) {
          logger.info('Referral cookie expired, ignoring', { 
            referralCode: referralData.code,
            expiresAt: referralData.expiresAt 
          });
          referralData = null;
        } else {
          logger.info('Referral cookie found and valid', { 
            referralCode: referralData.code,
            referralId: referralData.referralId 
          });
        }
      }
    }
  } catch (refError) {
    logger.error('Error parsing referral cookie', { 
      errorMessage: refError instanceof Error ? refError.message : String(refError) 
    });
  }

  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password,
      language: body.language,
      referralCode: referralData?.code,
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('×—×¡×¨×™× ×¤×¨×˜×™× ×—×•×‘×”');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×, ××•×ª ×’×“×•×œ×”, ××•×ª ×§×˜× ×” ×•××¡×¤×¨');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            language: body.language || 'he',
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(),
            engagementEmailsConsent: false,
            promotionalEmailsConsent: false,
            // ========================================================
            // ğŸ›‘ ×ª×™×§×•×Ÿ ×§×¨×™×˜×™: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ "×©×œ×“" ×›×‘×¨ ×‘×©×œ×‘ ×”×”×¨×©××”
            // ×–×” ××•× ×¢ ××™×•×–×¨×™× ×œ×”×™×•×ª "×¨×•×—×•×ª ×¨×¤××™×" ×× ×”× × ×•×˜×©×™×
            // ×‘×××¦×¢ ×”×ª×”×œ×™×š.
            // ========================================================
            profile: {
              create: {
                availabilityStatus: 'AVAILABLE',
                isProfileVisible: false,
                
                // ×”×•×¡×¤×ª ×¢×¨×›×™ ×—×•×‘×” ×–×× ×™×™× ×›×“×™ ×œ×¢×‘×•×¨ ××ª ×”×¡×›××”:
                // ×× ×• ××–×™× ×™× ×¢×¨×›×™× ××œ×• ×›×‘×¨×™×¨×ª ××—×“×œ ×›×“×™ ×©×”×™×¦×™×¨×” ×ª×¦×œ×™×—.
                // ×”××©×ª××© ×™×“×¨×•×¡ ××•×ª× ×‘×©×œ×‘ ××™×œ×•×™ ×”×¤×¨×˜×™× ×”×××™×ª×™.
                gender: Gender.FEMALE, // ×¢×¨×š ×–×× ×™ - ×™×•×—×œ×£ ×¢"×™ ×”××©×ª××©
                birthDate: new Date('2000-01-01T00:00:00.000Z'), // ×¢×¨×š ×–×× ×™
                
                // (××•×¤×¦×™×•× ×œ×™) ×× ×”×•×¡×¤×ª ××ª ×”×©×“×” ×”×–×” ×‘×¡×›××” - ×–×” ×¢×•×–×¨ ×œ×–×”×•×ª × ×ª×•× ×™× ×–×× ×™×™×
                birthDateIsApproximate: true 
              }
            }
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });

    let referralLinked = false;
    if (referralData) {
      try {
        logger.info('Attempting to link user to referral', { 
          userId: result.user.id, 
          referralId: referralData.referralId,
          referralCode: referralData.code 
        });
        
        const linkResult = await linkUserToReferral({
          userId: result.user.id,
          referralId: referralData.referralId,
        });
        
        if (linkResult.success) {
          referralLinked = true;
          logger.info('User successfully linked to referral', { 
            userId: result.user.id, 
            referrerId: linkResult.referrerId,
            referralCode: referralData.code 
          });
        } else {
          logger.error('Failed to link user to referral', { 
            userId: result.user.id, 
            referralId: referralData.referralId,
            error: linkResult.error 
          });
        }
      } catch (refLinkError) {
        logger.error('Error linking user to referral', { 
          userId: result.user.id,
          referralId: referralData.referralId,
          errorMessage: refLinkError instanceof Error ? refLinkError.message : String(refLinkError)
        });
      }
    }
    
    let emailSentSuccess = false;
    const emailOtpExpiryText = locale === 'he' ? "×©×¢×” ××—×ª" : "1 hour"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
        await emailService.sendVerificationEmail({
                locale,
                email: result.user.email,
                verificationCode: result.generatedOtp, 
                firstName: result.user.firstName,
                expiresIn: emailOtpExpiryText 
            });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = '×”×—×©×‘×•×Ÿ × ×•×¦×¨ ×‘×”×¦×œ×—×”. ';
    if (emailSentSuccess) {
        responseMessage += `× ×©×œ×— ×§×•×“ ××™××•×ª ×œ×›×ª×•×‘×ª ×”×“×•××œ ×©×œ×š (${result.user.email}). ×× × ×”×–×Ÿ ××ª ×”×§×•×“ ×›×“×™ ×œ×”××©×™×š.`;
    } else {
        responseMessage += '×”×™×™×ª×” ×‘×¢×™×” ×‘×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª. ×ª×•×›×œ ×œ×‘×§×© ×§×•×“ ×—×“×© ×‘××¡×š ×”×‘× ××• ×œ×¤× ×•×ª ×œ×ª××™×›×”.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { 
      userId: result.user.id,
      referralLinked,
      referralCode: referralData?.code,
    });

    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id,
        referralLinked,
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status, errorCode } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        errorCode, 
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\registration-info
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\registration-info\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth"; // ×•×•×“× ×©×”× ×ª×™×‘ × ×›×•×Ÿ ×œ×¤×¨×•×™×§×˜ ×©×œ×š
import prisma from "@/lib/prisma"; // ×•×•×“× ×©×”× ×ª×™×‘ × ×›×•×Ÿ

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ×œ×¤×™ ×”×¡×›××” ×”×××™×ª×™×ª ×©×œ×š
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        phone: true,
        termsAndPrivacyAcceptedAt: true,
        source: true, // ×—×©×•×‘ ×œ×–×™×”×•×™ ××§×•×¨ ×”××©×ª××©
        status: true,
        isVerified: true,
        isProfileComplete: true,
        accounts: {
          select: { provider: true }
        },
        profile: {
          select: {
            gender: true,
            birthDate: true,
            maritalStatus: true,
            height: true,
            occupation: true, // âœ… ×–×” ×”×©×“×” ×”× ×›×•×Ÿ (×‘××§×•× profession)
            education: true,
            religiousLevel: true,
            city: true,
            hasChildrenFromPrevious: true, // âœ… ×–×” ×”×©×“×” ×”× ×›×•×Ÿ ×œ×™×œ×“×™×
            // numberOfChildren: true, <--- ××—×§× ×• ×›×™ ×œ× ×§×™×™× ×‘×¡×›××”
          }
        }
      }
    });

    if (!user) {
      return new NextResponse("User not found", { status: 404 });
    }

    return NextResponse.json(user);

  } catch (error) {
    console.error("[REGISTRATION_INFO_GET]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus, VerificationStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus;
  locale?: 'he' | 'en';
  isOAuthUser?: boolean;
  providers?: string | string[]; // âœ… ×”×•×¡×¤×ª providers ×œ-type
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
  
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined;

  try {
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ 
        success: false, 
        error: validation.error.flatten().fieldErrors.email?.[0] || "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" 
      }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    logger.info('Processing password reset request', { action, email: normalizedEmail, locale });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
      include: {
        accounts: {
          select: {
            provider: true,
          }
        }
      }
    });

    const genericSuccessMessage = locale === 'he'
      ? '×× ×§×™×™××ª ×›×ª×•×‘×ª ××™×™×œ ×–×• ×‘××¢×¨×›×ª ×•× ×™×ª×Ÿ ×œ××¤×¡ ×¢×‘×•×¨×” ×¡×™×¡××”, ×§×•×“ ××™××•×ª × ×©×œ×— ×›×¢×ª.'
      : 'If an account with this email exists and is eligible for password reset, a code has been sent.';

    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    const finalLocale = user.language || locale;

    // ×‘×“×™×§×” ×× ×”××©×ª××© × ×¨×©× ×“×¨×š OAuth
    const hasOAuthAccount = user.accounts && user.accounts.length > 0;
    const isPasswordlessUser = !user.password;

    if (hasOAuthAccount && isPasswordlessUser) {
      const oauthProviders = user.accounts.map(acc => acc.provider);
      const providersText = oauthProviders.map(provider => {
        switch(provider) {
          case 'google': return 'Google';
          case 'facebook': return 'Facebook';
          default: return provider;
        }
      }).join(', ');

      logger.info('Password reset attempted for OAuth-only user', { 
        action, 
        email: normalizedEmail, 
        userId: user.id,
        isOAuthUser: true,
        providers: providersText // âœ… ×¢×›×©×™×• ×–×” ×ª×§×™×Ÿ
      });

      const oauthMessage = finalLocale === 'he'
        ? `×—×©×‘×•×Ÿ ×–×” × ×¨×©× ×“×¨×š ${providersText}. ×œ× × ×™×ª×Ÿ ×œ××¤×¡ ×¡×™×¡××” - ×× × ×”×™×›× ×¡ ×‘×××¦×¢×•×ª ${providersText}.`
        : `This account was registered via ${providersText}. Password reset is not available - please sign in using ${providersText}.`;

      return NextResponse.json({ 
        success: false, 
        error: oauthMessage,
        isOAuthAccount: true,
        providers: oauthProviders // ×©×•×œ×—×™× ××ª ×”×¡×¤×§×™× ×œ×§×œ×™×™× ×˜
      }, { status: 400 });
    }

    if (!user.password) {
      logger.info('Password reset attempted for account without password', { 
        action, 
        email: normalizedEmail, 
        userId: user.id 
      });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
      logger.warn('Password reset attempted for blocked or inactive user', { 
        action, 
        email: normalizedEmail, 
        userId: user.id, 
        status: user.status 
      });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    await prisma.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.PASSWORD_RESET,
        status: VerificationStatus.PENDING,
      },
      data: {
        status: VerificationStatus.EXPIRED,
      },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60 
    );
    logger.info('New password reset OTP created', { action, userId: user.id, verificationId: passwordResetVerification.id });

    try {
      const expiresInText = finalLocale === 'he' ? `${expiresInMinutes} ×“×§×•×ª` : `${expiresInMinutes} minutes`;

      await emailService.sendPasswordResetOtpEmail({
        locale: finalLocale,
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: expiresInText,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    const errorMessage = locale === 'he'
      ? '××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.'
      : 'An error occurred. Please try again later.';

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

// --- ×”×’×“×¨×•×ª ---
const RESEND_RATE_LIMIT_SECONDS = 60; // ×–××Ÿ ×”××ª× ×” ×‘×©× ×™×•×ª ×‘×™×Ÿ ×‘×§×©×•×ª ×—×•×–×¨×•×ª

// --- ×œ×•×’×¨ ×œ×¢×–×¨×” ×‘×“×™×‘××’×™× ×’ ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => {
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta }));
    },
    warn: (message: string, meta?: Record<string, unknown>) => {
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta }));
    },
    error: (message: string, meta?: any) => {
      let logMeta = meta || {};
      if (meta instanceof Error) {
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
};

// --- ×¤×•× ×§×¦×™×™×ª ×”-API ×”×¨××©×™×ª ---
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
    if (rateLimitResponse) {
        return rateLimitResponse;
    }

    logger.info("Resend phone code request received");

    // 1. --- ×‘×“×™×§×ª ××™××•×ª ××©×ª××© ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });

    try {
        // ============================ ×”×ª×™×§×•×Ÿ ×”××¨×›×–×™ (1 ××ª×•×š 2) ============================
        // 2. --- ×§×¨×™××ª ×”×©×¤×” (locale) ××¤×¨××˜×¨ ×”-URL ---
        const url = new URL(req.url);
        // ×”×’×“×¨×ª ×¢×‘×¨×™×ª ×›×©×¤×ª ×‘×¨×™×¨×ª ××—×“×œ ×× ×”×¤×¨××˜×¨ ×œ× ×§×™×™×
        const locale = (url.searchParams.get('locale') || 'he') as 'he' | 'en';
        logger.info("Processing request with locale", { userId, locale });
        // =================================================================================

        // 3. --- ××™×ª×•×¨ ×‘×§×©×ª ×”××™××•×ª ×”××—×¨×•× ×” ×©×œ ×”××©×ª××© ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc'
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            return NextResponse.json({ error: '×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”. ×™×™×ª×›×Ÿ ×©×›×‘×¨ ××™××ª×ª ××ª ××¡×¤×¨×š ××• ×©×”×§×•×“ ×¤×’ ×ª×•×§×£.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });

        // 4. --- ×‘×“×™×§×ª ×”×’×‘×œ×ª ×§×¦×‘ (Rate Limiting) ---
        const now = new Date();
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: `×× × ×”××ª×Ÿ ${timeLeft} ×©× ×™×•×ª ×œ×¤× ×™ ×‘×§×©×ª ×§×•×“ ×—×“×©.` }, { status: 429 });
        }
        logger.info("Rate limit check passed", { userId });

        // 5. --- ×§×‘×™×¢×ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×•×”×©× ---
        let targetPhone = lastVerification.target;
        let userFirstName = session.user.firstName || '';

        // ×‘××§×¨×” ×©××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×œ× × ×©××¨ ×‘×¨×©×•××ª ×”××™××•×ª, × ×©×œ×•×£ ××•×ª×• ××”××©×ª××©
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true }
             });
             if (!user?.phone) {
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                return NextResponse.json({ error: '×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ××ª×¨ ××ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×œ×©×œ×™×—×ª ×”×§×•×“.' }, { status: 500 });
             }
             targetPhone = user.phone;
             userFirstName = user.firstName || '';
        }
        
        // 6. --- ×™×¦×™×¨×ª ×§×•×“ ×—×“×© ×•×ª××¨×™×š ×ª×¤×•×’×” ×—×“×© ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // ×ª×•×§×£ ×œ-10 ×“×§×•×ª
        logger.info("Generated new OTP", { userId });

        // 7. --- ×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××™××•×ª ×‘××¡×“ ×”× ×ª×•× ×™× ---
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // ××™×¤×•×¡ ××•× ×” ×”× ×™×¡×™×•× ×•×ª
                createdAt: new Date() // ×¢×“×›×•×Ÿ ×—×•×ª××ª ×”×–××Ÿ ×œ×‘×“×™×§×ª ×”-rate limit ×”×‘××”
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });

        // ============================ ×”×ª×™×§×•×Ÿ ×”××¨×›×–×™ (2 ××ª×•×š 2) ============================
        // 8. --- ×©×œ×™×—×ª ×”×§×•×“ ×”×—×“×©, ×ª×•×š ×”×¢×‘×¨×ª ×”×©×¤×” (locale) ×œ×©×™×¨×•×ª ×”×©×œ×™×—×” ---
        // ×”×¢×¨×”: ×™×© ×œ×•×•×“× ×©×”×¤×•× ×§×¦×™×” `sendOtpViaWhatsApp` ××›×Ÿ ××§×‘×œ×ª ×¤×¨××˜×¨ ×¨×‘×™×¢×™ ×©×œ ×©×¤×”
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone, locale });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName,
        );
        // =================================================================================

        if (!otpSent) {
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            return NextResponse.json({ error: '×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª ×”×—×“×© ×‘×××¦×¢×•×ª WhatsApp × ×›×©×œ×”. ×× × × ×¡×” ×©×•×‘ ×‘×¢×•×“ ××¡×¤×¨ ×¨×’×¢×™×.' }, { status: 500 });
        }

        // 9. --- ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×” ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: '×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×” ×‘×××¦×¢×•×ª WhatsApp.' }, { status: 200 });

    } catch (error: unknown) {
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id,
            error: error
        });
        return NextResponse.json({ error: '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª ×‘×©×¨×ª. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification/route.ts

import { NextResponse, NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª ×œ×©×œ×™×—×” ×—×•×–×¨×ª ×©×œ ×§×•×“ ××™××•×ª ×œ××™×™×œ.
 * × ×§×•×“×ª ×§×¦×” ×–×• × ×•×¢×“×” ×œ××©×ª××©×™× ×©× ×¨×©××• ××š ×œ× ×§×™×‘×œ×• ××ª ×§×•×“ ×”××™××•×ª ×”×¨××©×•× ×™.
 */
export async function POST(req: NextRequest) {
  // 1. ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª ×œ×× ×™×¢×ª ×©×™××•×© ×œ×¨×¢×” ×•×©×œ×™×—×ª ×¡×¤××
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. ×©×œ×™×¤×ª ×©×¤×ª ×”×××©×§ ××”-URL ×œ×¦×•×¨×š ×ª×¨×’×•× ×”××™×™×œ
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. ×§×¨×™××ª ×•××™××•×ª ×’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { email } = body;

    if (!email || typeof email !== 'string') {
      return NextResponse.json(
        { success: false, error: "×›×ª×•×‘×ª ×”××™×™×œ ×”×™× ×©×“×” ×—×•×‘×”." },
        { status: 400 }
      );
    }

    const normalizedEmail = email.toLowerCase();

    // 4. ××™×ª×•×¨ ×”××©×ª××© ×‘××¡×“ ×”× ×ª×•× ×™×
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    });

    // ×‘×“×™×§×•×ª ×§×¦×” ×§×¨×™×˜×™×•×ª
    if (!user) {
      return NextResponse.json(
        { success: false, error: "×œ× × ××¦× ××©×ª××© ×¢× ×›×ª×•×‘×ª ×”××™×™×œ ×”×–×•." },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { success: false, error: "×—×©×‘×•×Ÿ ×–×” ×›×‘×¨ ×××•××ª. × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨." },
        { status: 400 }
      );
    }

    // 5. ×™×¦×™×¨×ª ×§×•×“ ××™××•×ª ×—×“×© ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×”××™××•×ª ×”××¨×›×–×™
    // ×”×©×™×¨×•×ª ×™×“××’ ×œ×‘×˜×œ ×ª×•×§×£ ×©×œ ×§×•×“×™× ×§×•×“××™× ×©×˜×¨× × ×•×¦×œ×•.
    const expiresInHours = 1; // ×ª×•×§×£ ×œ×©×¢×”
    const { otp: verificationCode } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email,
        expiresInHours
    );

    console.log(`[Resend Verification] New OTP generated for user: ${user.id}`);

    // 6. ×©×œ×™×—×ª ××™×™×œ ××™××•×ª ×—×“×© ×¢× ×”×§×•×“ ×©× ×•×¦×¨, ×‘×”×ª×× ×œ×©×¤×” ×©× ×‘×—×¨×”
    const expiresInText = locale === 'he' ? '×©×¢×” ××—×ª' : '1 hour';
    
    await emailService.sendVerificationEmail({
      locale, // ×”×¢×‘×¨×ª ×¤×¨××˜×¨ ×”×©×¤×”
      email: user.email,
      verificationCode: verificationCode,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Resend Verification] Verification email sent successfully to ${user.email} in ${locale}`);

    // 7. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×” ×œ×œ×§×•×—
    return NextResponse.json({
      success: true,
      message: "××™×™×œ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×”."
    });

  } catch (error: unknown) {
    // 8. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª
    console.error('[API Resend Verification] A critical error occurred:', error);
    
    const errorMessage = error instanceof Error ? error.message : "×©×’×™××” ×œ× ×¦×¤×•×™×” ×‘×©×œ×™×—×ª ××™×™×œ ×”××™××•×ª.";
    
    return NextResponse.json(
        { success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š, ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.", details: errorMessage }, 
        { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification-code/route.ts

import { NextResponse, NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { VerificationType, UserStatus } from '@prisma/client';
import { applyRateLimit } from '@/lib/rate-limiter';

// ×”×’×“×¨×ª ×˜×™×¤×•×¡ ×œ××™×“×¢ ×”× ×©××¨ ×‘×œ×•×’×™×
type LogMetadata = {
  email?: string;
  error?: unknown;
  userId?: string;
  verificationId?: string;
  status?: UserStatus;
  isVerified?: boolean;
};

// ××•×‘×™×™×§×˜ ×œ×•×’×¨ ×¤×©×•×˜ ×•×¢×§×‘×™
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: NextRequest) {
  // 1. ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  let requestBody: ResendCodeRequest | null = null;
  try {
    // 2. ×©×œ×™×¤×ª ×©×¤×ª ×”×××©×§ ××”-URL
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. ×§×¨×™××ª ×•××™××•×ª ×’×•×£ ×”×‘×§×©×”
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });

    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: '×—×¡×¨×” ×›×ª×•×‘×ª ××™××™×™×œ.' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    
    // 4. ××™×ª×•×¨ ×”××©×ª××© ×•×•×œ×™×“×¦×™×”
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail });
      return NextResponse.json({ success: false, error: '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ××™× ×• ×¨×©×•×.' }, { status: 404 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        logger.warn('User email already verified or not pending verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: '×›×ª×•×‘×ª ×”××™××™×™×œ ×›×‘×¨ ×××•××ª×ª ××• ×©××™× ×” ×××ª×™× ×” ×œ××™××•×ª.' }, { status: 400 });
    }
    
    // 5. ×™×¦×™×¨×ª ×§×•×“ ××™××•×ª ×—×“×© ×“×¨×š ×”×©×™×¨×•×ª ×”××¨×›×–×™
    const expiresInHoursForOtp = 1;
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHoursForOtp
    );
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });

    // 6. ×©×œ×™×—×ª ×”××™×™×œ ×¢× ×”×§×•×“ ×”×—×“×© ×•×”×©×¤×” ×”× ×›×•× ×”
    const emailOtpExpiryText = locale === 'he' ? "×©×¢×” ××—×ª" : "1 hour";
    await emailService.sendVerificationEmail({
      locale, // <<<<<<<<<<<< ×”×¢×‘×¨×ª ×”-locale
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    // 7. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×”
    return NextResponse.json({
      success: true,
      message: `×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×œ×›×ª×•×‘×ª ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    // 8. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×” ×—×•×–×¨×ª ×©×œ ×”×§×•×“.';
    const errorStatus = 500;

    if (error instanceof Error && error.message.includes('××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×§×•×“ ××™××•×ª')) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { hash } from 'bcryptjs';
import { z } from 'zod';

const resetPasswordSchema = z.object({
  email: z.string().email({ message: "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }),
  otp: z.string()
    .length(6, { message: "×§×•×“ ×”××™××•×ª ×—×™×™×‘ ×œ×”×›×™×œ 6 ×¡×¤×¨×•×ª" })
    .regex(/^\d+$/, { message: "×§×•×“ ××™××•×ª ×™×›×•×œ ×œ×”×›×™×œ ×¡×¤×¨×•×ª ×‘×œ×‘×“" }),
  newPassword: z.string()
    .min(8, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×" })
    .regex(/[a-z]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ××•×ª ×§×˜× ×” ××—×ª ×‘×× ×’×œ×™×ª" })
    .regex(/[A-Z]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ××•×ª ×’×“×•×œ×” ××—×ª ×‘×× ×’×œ×™×ª" })
    .regex(/[0-9]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ×¡×¤×¨×” ××—×ª" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "reset-password-with-otp";
  let requestBody: { email?: string } | undefined;

  try {
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '15 m' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action, locale });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "× ×ª×•× ×™× ×œ× ×ª×§×™× ×™×.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];

      logger.warn('Invalid input for password reset', { action, error: errors });
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });
    
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      logger.error('OTP verification failed unexpectedly or did not return required data', {
        action,
        email: normalizedEmail,
        error: verificationResult.message,
      });
      throw new Error(verificationResult.message || '×©×’×™××” ×‘××™××•×ª ×”×§×•×“.');
    }

    const { userId, id: verificationId } = verificationResult;
    logger.info('OTP verified successfully', { action, userId, verificationId });

    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
      },
      select: { email: true, firstName: true, language: true }
    });
    logger.info('User password updated in database', { action, userId });

    await VerificationService.completeVerification(verificationId);
    logger.info('Verification record marked as completed', { action, verificationId });

    if (user) {
      try {
        await emailService.sendPasswordChangedConfirmationEmail({
         locale: user.language || locale,
          email: user.email,
          firstName: user.firstName,
        });
        logger.info('Password change confirmation email sent', { action, userId, locale: user.language || locale });
      } catch (emailError) {
        logger.error('Failed to send password change confirmation email', {
          action,
          userId,
          error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
        });
      }
    }

    const successMessage = (user.language || locale) === 'he'
      ? '×”×¡×™×¡××” ××•×¤×¡×” ×‘×”×¦×œ×—×”. ×›×¢×ª ×ª×•×›×œ ×œ×”×ª×—×‘×¨ ×¢× ×”×¡×™×¡××” ×”×—×“×©×”.'
      : 'Password has been reset successfully. You can now log in with your new password.';
      
    return NextResponse.json({ success: true, message: successMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘××™×¤×•×¡ ×”×¡×™×¡××”.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '×”×§×•×“ ×›×‘×¨ × ×•×¦×œ.',
        '×ª×•×§×£ ×”×§×•×“ ×¤×’. ×× × ×‘×§×© ×§×•×“ ×—×“×©.',
        '×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ ××• ×©×œ× ×§×™×™××ª ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”.',
        '×§×•×“ ××™××•×ª ×©×’×•×™.',
        '×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª ×”××•×ª×¨. ×× × ×‘×§×© ×§×•×“ ×—×“×©.',
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400;
        if (error.message.includes("×¤×’ ×ª×•×§×¤×•")) errorStatus = 410;
        if (error.message.includes("×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª")) errorStatus = 429;
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 requests per user per hour (costly SMS/WhatsApp)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. ×§×‘×œ ××ª ×¤×¨×˜×™ ×”××©×ª××© ××”-DB (×‘×¢×™×§×¨ ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // ×©×’×™××” ×–×• ×œ× ×××•×¨×” ×œ×§×¨×•×ª ×× ×”××©×ª××© ×”×’×™×¢ ×œ×›××Ÿ ×“×¨×š ×”×©×œ××ª ×¤×¨×•×¤×™×œ
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. ×™×¦×™×¨×ª OTP ×—×“×©
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 ×“×§×•×ª ×ª×¤×•×’×”

        // 3. ×©××™×¨×ª/×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××™××•×ª
        // ××—×§ ×¨×©×•××•×ª ×§×•×“××•×ª ×œ××•×ª×• ××©×ª××© ×›×“×™ ×œ×× ×•×¢ ×‘×œ×‘×•×œ
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // ×¦×•×¨ ×¨×©×•××” ×—×“×©×”
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. ×©×œ×™×—×ª ×”-OTP ×‘×•×•××˜×¡××¤
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // ×”×—×–×¨ ×©×’×™××” ×›×“×™ ×©×”×§×œ×™×™× ×˜ ×™×•×›×œ ×œ×”×¦×™×’ ×”×•×“×¢×” ××ª××™××”
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/send-verification/route.ts

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { VerificationType, UserStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

export const runtime = 'nodejs';

/**
 * Handles requests to send a new email verification code to an existing, unverified user.
 */
export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting to prevent email spam
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. Parse and Validate Request Body
    const { email } = await req.json();
    if (!email || typeof email !== 'string') {
      return NextResponse.json({ success: false, error: "××™××™×™×œ ×”×•× ×©×“×” ×—×•×‘×”" }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 4. Find the user and perform necessary checks
    const user = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (!user) {
      // Security: Return a generic message even if the user doesn't exist to prevent enumeration.
      return NextResponse.json({ success: true, message: "×× ×§×™×™× ×—×©×‘×•×Ÿ ×”××©×•×™×š ×œ××™×™×œ ×–×”, × ×©×œ×— ××œ×™×• ×§×•×“ ××™××•×ª." }, { status: 200 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        return NextResponse.json({ success: false, error: "×—×©×‘×•×Ÿ ×–×” ×›×‘×¨ ×××•××ª ××• ×©××™× ×• ×××ª×™×Ÿ ×œ××™××•×ª." }, { status: 400 });
    }

    // 5. Create a new verification OTP using the central service
    const expiresInHours = 1; // 1-hour validity for the new code
    const { otp: generatedOtp } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHours
    );

    console.log(`[Send Verification] New OTP generated for user: ${user.id}`);

    // 6. Send the verification email using the updated Email Service
    const expiresInText = locale === 'he' ? '×©×¢×” ××—×ª' : '1 hour';
    await emailService.sendVerificationEmail({
      locale, // <-- Pass the correct locale
      email: user.email,
      verificationCode: generatedOtp,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Send Verification] Verification email re-sent successfully to ${user.email} in ${locale}`);

    // 7. Return a success response
    return NextResponse.json({ success: true, message: "×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×”." }, { status: 200 });

  } catch (error) {
    // 8. Handle unexpected errors
    console.error('[API Send Verification] A critical error occurred:', error);
    const errorMessage = error instanceof Error ? error.message : "×©×’×™××” ×œ× ×¦×¤×•×™×” ×‘×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª.";
    return NextResponse.json(
      { success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š, ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
});


export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. ×‘×“×•×§ ×©×”××¡×¤×¨ ×”×—×“×© ×œ× ×ª×¤×•×¡ ×¢×œ ×™×“×™ ××©×ª××© ×××•××ª ××—×¨
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } // ×œ× ×”××©×ª××© ×”× ×•×›×—×™
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: '××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×›×‘×¨ ×¨×©×•× ×•×¤×¢×™×œ ×‘××¢×¨×›×ª ×¢×‘×•×¨ ××©×ª××© ××—×¨.' }, { status: 409 }); // Conflict
          }

        // 2. ×¢×“×›×Ÿ ××ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×©×œ ×”××©×ª××©
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // ×§×— ××ª ×”×©× ×”××¢×•×“×›×Ÿ ×× ×¦×¨×™×š
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. ×¦×•×¨ OTP ×—×“×©
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 ×“×§×•×ª ×ª×¤×•×’×”

        // 4. ×¦×•×¨/×¢×“×›×Ÿ ×¨×©×•××ª ××™××•×ª ×¢×‘×•×¨ ×”××¡×¤×¨ ×”×—×“×©
        // ×‘×˜×œ ×¨×©×•××•×ª ×§×•×“××•×ª ×× ×”×™×•
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // ×¡××Ÿ ×§×•×“××™× ×›×¤×’×™ ×ª×•×§×£
         });
         // ×¦×•×¨ ×¨×©×•××” ×—×“×©×”
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // ×”××¡×¤×¨ ×”×—×“×©
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. ×©×œ×— ××ª ×”-OTP ×œ××¡×¤×¨ ×”×—×“×©
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // ×”×—×–×¨ ×©×’×™××”, ×™×™×ª×›×Ÿ ×©×”××¡×¤×¨ ×”×—×“×© ×œ× ×ª×§×™×Ÿ ×‘×•×•××˜×¡××¤
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // ×”×’×“×¨×ª error ×›-unknown
        console.error("API update-and-resend: An error occurred:", error);

        // ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×¡×¤×¦×™×¤×™×•×ª
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // ×©×’×™××ª ×›×¤×™×œ×•×ª - ×œ××¨×•×ª ×©×‘×“×§× ×•, ×™×™×ª×›×Ÿ ××¦×‘ race condition
            return NextResponse.json({ error: '××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×›×‘×¨ ×¨×©×•× ×‘××¢×¨×›×ª.' }, { status: 409 });
        }

        // ×©×’×™××” ×›×œ×œ×™×ª
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId ×›××Ÿ ×™×›×•×œ ×œ×”×™×•×ª string ××• undefined ×× ×”×•× ×œ× ×§×™×™× ×‘××˜××“××˜×”
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 verification attempts per IP per 15 minutes (prevents brute-force)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '15 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: '×—×¡×¨×™× ×¤×¨×˜×™ ××™××™×™×œ ××• ×§×•×“.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `×¤×•×¨××˜ ×§×•×“ ×œ× ×ª×§×™×Ÿ. ×”×§×•×“ ×¦×¨×™×š ×œ×”×›×™×œ ${OTP_LENGTH_FROM_SERVICE} ×¡×¤×¨×•×ª.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- ×”×ª×™×§×•×Ÿ ××ª×—×™×œ ×›××Ÿ ---
    // ×•×•×“× ×©-userId ×§×™×™× ×•×”×•× ××—×¨×•×–×ª ×œ×¤× ×™ ×©× ××©×™×š
    // ×¡×‘×™×¨ ×œ×”× ×™×— ×©-verificationResult.userId ×™×›×•×œ ×œ×”×™×•×ª string | null
    // ×¢×œ ×¤×™ ×”×”×’×“×¨×” ×©×œ VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // ×–×¨×•×§ ×©×’×™××” ×©×ª×˜×•×¤×œ ×‘×œ×•×§ ×”-catch ×”×›×œ×œ×™, ××• ×˜×¤×œ ×‘×” ×‘××•×¤×Ÿ ×¡×¤×¦×™×¤×™ ×™×•×ª×¨
      // ×©×’×™××” ×–×• ××¦×‘×™×¢×” ×¢×œ ×‘×¢×™×” ×œ×•×’×™×ª ×¤× ×™××™×ª ×× ×”×§×•×“ ××•××ª ××š ××™×Ÿ ××©×ª××© ××©×•×™×š
      throw new Error('×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª ×œ××—×¨ ××™××•×ª ×§×•×“ ××•×¦×œ×—.');
    }
    
    // ×›×¢×ª, ×œ××—×¨ ×”×‘×“×™×§×”, TypeScript ×™×›×•×œ ×œ×”×¡×™×§ (××• ×©× ×•×›×œ ×œ×”×¦×”×™×¨ ×‘××¤×•×¨×©)
    // ×©-userId ×”×•× string.
    const userId: string = verificationResult.userId; 
    // --- ×¡×•×£ ×”×ª×™×§×•×Ÿ ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, // ×›××Ÿ userId ××•×‘×˜×— ×œ×”×™×•×ª string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: '×›×ª×•×‘×ª ×”××™××™×™×œ ××•××ª×” ×‘×”×¦×œ×—×”! ××ª×‘×¦×¢×ª ×”×ª×—×‘×¨×•×ª ××•×˜×•××˜×™×ª...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘××™××•×ª ×”×§×•×“.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '×”×§×•×“ ×›×‘×¨ × ×•×¦×œ.', 
        '×ª×•×§×£ ×”×§×•×“ ×¤×’. ×× × ×‘×§×© ×§×•×“ ×—×“×©.', 
        '×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ ××• ×©×œ× ×§×™×™××ª ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”.', 
        '×§×•×“ ××™××•×ª ×©×’×•×™.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === '×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª.' || 
                 error.message === '×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª ×œ××—×¨ ××™××•×ª ×§×•×“ ××•×¦×œ×—.') { // ×”×•×¡×¤×ª ×”×©×’×™××” ×”×—×“×©×” ×× ×¨×•×¦×™× ×˜×™×¤×•×œ ××™×•×—×“
        errorMessage = '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.';
        // errorStatus × ×©××¨ 500 ×›×‘×¨×™×¨×ª ××—×“×œ ×œ×©×’×™××•×ª ×¤× ×™××™×•×ª, ××• ×©×ª×©× ×” ×œ×¤×™ ×”×¦×•×¨×š
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/verify-phone-code/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { z } from 'zod';
import { Prisma, VerificationType, UserStatus } from '@prisma/client';

import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { emailService } from '@/lib/email/emailService';
// ========== ğŸ”´ ×”×•×¡×¤×” ×—×“×©×”: ×™×™×‘×•× ×¤×•× ×§×¦×™×™×ª ×¢×“×›×•×Ÿ ×¨×¤×¨×œ ==========
import { updateReferralStatus } from '@/lib/services/referralService';
// ==============================================================

const MAX_VERIFICATION_ATTEMPTS = 5;

const verifyCodeSchema = z.object({
  code: z.string()
    .length(6, { message: "×§×•×“ ×”××™××•×ª ×—×™×™×‘ ×œ×”×›×™×œ 6 ×¡×¤×¨×•×ª" })
    .regex(/^\d+$/, { message: "×¤×•×¨××˜ ×§×•×“ ×œ× ×ª×§×™×Ÿ, ×¡×¤×¨×•×ª ×‘×œ×‘×“" }),
});

const logger = {
    info: (message: string, meta?: Record<string, unknown>) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
    warn: (message: string, meta?: Record<string, unknown>) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
    error: (message: string, meta?: Record<string, unknown>) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "verify-phone-code";

  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      logger.warn("× ×™×¡×™×•×Ÿ ×œ××™××•×ª ×˜×œ×¤×•×Ÿ ×œ×œ× ×¡×©×Ÿ ×¤×¢×™×œ", { action });
      return NextResponse.json({ error: 'Unauthorized - × ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("×ª×”×œ×™×š ××™××•×ª ×˜×œ×¤×•×Ÿ ×”×—×œ ×¢×‘×•×¨ ××©×ª××©", { action, userId });

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    logger.info("×©×¤×ª ×”×××©×§ ×–×•×”×ª×”", { action, userId, locale });

    const body = await req.json();
    const validation = verifyCodeSchema.safeParse(body);

    if (!validation.success) {
      logger.warn("× ×ª×•× ×™× ×œ× ×ª×§×™× ×™× ×‘×‘×§×©×”", { action, userId, errors: validation.error.flatten() });
      return NextResponse.json({ error: '× ×ª×•× ×™× ×œ× ×ª×§×™× ×™×', details: validation.error.flatten() }, { status: 400 });
    }
    const { code } = validation.data;

    const verification = await prisma.verification.findFirst({
        where: {
            userId: userId,
            type: VerificationType.PHONE_WHATSAPP,
            status: 'PENDING',
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    if (!verification) {
      logger.warn("×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×˜×œ×¤×•×Ÿ ×¤×¢×™×œ×”", { action, userId });
      return NextResponse.json({ error: '×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×” ××• ×©×”×—×©×‘×•×Ÿ ×›×‘×¨ ××•××ª.' }, { status: 404 });
    }

    if (new Date() > verification.expiresAt) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'EXPIRED' }
        });
        logger.warn("× ×™×¡×™×•×Ÿ ×œ×”×©×ª××© ×‘×§×•×“ ×©×¤×’ ×ª×•×§×¤×•", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '×§×•×“ ×”××™××•×ª ×¤×’ ×ª×•×§×£. ×× × ×‘×§×© ×§×•×“ ×—×“×©.' }, { status: 410 });
    }

    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'FAILED' }
        });
        logger.warn("×—×¨×’×” ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª ×”××•×ª×¨. ×× × ×‘×§×© ×§×•×“ ×—×“×©.' }, { status: 429 });
    }

    if (verification.token !== code) {
        const updatedVerification = await prisma.verification.update({
            where: { id: verification.id },
            data: { attempts: { increment: 1 } }
        });
        const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - updatedVerification.attempts;
        logger.warn("×”×•×–×Ÿ ×§×•×“ ××™××•×ª ×©×’×•×™", { action, userId, attemptsLeft });
        return NextResponse.json({ error: `×§×•×“ ××™××•×ª ×©×’×•×™. × ×•×ª×¨×• ×œ×š ${attemptsLeft} × ×™×¡×™×•× ×•×ª.` }, { status: 400 });
    }

    const [, updatedUser] = await prisma.$transaction([
        prisma.verification.update({
            where: { id: verification.id },
            data: {
                status: 'COMPLETED',
                completedAt: new Date(),
                attempts: verification.attempts + 1
             }
        }),
        prisma.user.update({
            where: { id: userId },
            data: {
                isPhoneVerified: true,
                isProfileComplete: true,
                status: UserStatus.ACTIVE,
                updatedAt: new Date(),
            },
            select: {
                id: true,
                email: true,
                firstName: true,
                language: true, 
                isPhoneVerified: true,
                isProfileComplete: true,
                status: true,
             }
        })
    ]);
    
    logger.info("××™××•×ª ×˜×œ×¤×•×Ÿ ×”×•×©×œ× ×‘×”×¦×œ×—×”, ××©×ª××© ×”×•×’×“×¨ ×›×¤×¢×™×œ", { action, userId });

    // ========== ğŸ”´ ×”×•×¡×¤×” ×—×“×©×”: ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×œ-VERIFIED ==========
    try {
      logger.info("×× ×¡×” ×œ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×œ-VERIFIED", { action, userId });
      
      const referralUpdateResult = await updateReferralStatus({
        userId: userId,
        newStatus: 'VERIFIED',
      });
      
      if (referralUpdateResult.success) {
        logger.info("×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×” ×œ-VERIFIED", { 
          action, 
          userId,
          referralId: referralUpdateResult.referralId,
          referrerId: referralUpdateResult.referrerId,
          newVerifiedCount: referralUpdateResult.newVerifiedCount
        });
      } else if (referralUpdateResult.error === 'NO_REFERRAL') {
        // ×”××©×ª××© ×œ× ×”×’×™×¢ ××¨×¤×¨×œ - ×–×” ×ª×§×™×Ÿ
        logger.info("×œ××©×ª××© ××™×Ÿ ×¨×¤×¨×œ ××§×•×©×¨, ×××©×™×›×™× ×¨×’×™×œ", { action, userId });
      } else {
        logger.warn("×œ× ×”×¦×œ×—× ×• ×œ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ", { 
          action, 
          userId,
          error: referralUpdateResult.error 
        });
      }
    } catch (referralError) {
      // ×œ× ×¢×•×¦×¨×™× ××ª ×”×ª×”×œ×™×š ×‘×’×œ×œ ×©×’×™××ª ×¨×¤×¨×œ
      logger.error("×©×’×™××” ×‘×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ", { 
        action, 
        userId, 
        error: referralError instanceof Error ? referralError.message : String(referralError)
      });
    }
    // =================================================================

    try {
        await emailService.sendWelcomeEmail({
            locale: updatedUser.language || locale,
            email: updatedUser.email,
            firstName: updatedUser.firstName || '×—×‘×¨',
            dashboardUrl: '/profile'
        });
        logger.info("××™×™×œ ×‘×¨×•×›×™× ×”×‘××™× × ×©×œ×— ×‘×”×¦×œ×—×”", { action, userId, email: updatedUser.email, locale: updatedUser.language || locale });
    } catch (emailError) {
        logger.error("×›×©×œ ×‘×©×œ×™×—×ª ××™×™×œ ×‘×¨×•×›×™× ×”×‘××™× ×œ××—×¨ ××™××•×ª ×˜×œ×¤×•×Ÿ", { action, userId, error: emailError });
    }

    return NextResponse.json({
         success: true,
         message: '××™××•×ª ×”×˜×œ×¤×•×Ÿ ×”×•×©×œ× ×‘×”×¦×œ×—×”!',
         user: updatedUser
    }, { status: 200 });

  } catch (error) {
    const userId = (await getServerSession(authOptions))?.user?.id || 'unknown';
    logger.error("×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ××™××•×ª ×”×˜×œ×¤×•×Ÿ", { action, userId, error });

    if (error instanceof z.ZodError) {
        return NextResponse.json({ error: '× ×ª×•× ×™× ×œ× ×ª×§×™× ×™× ×‘×‘×§×©×”', details: error.flatten() }, { status: 400 });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        return NextResponse.json({ error: '×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘×ª×”×œ×™×š ×”××™××•×ª' }, { status: 500 });
    }
    
    return NextResponse.json({ error: '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª ×‘×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

