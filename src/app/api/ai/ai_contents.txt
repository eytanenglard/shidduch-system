################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
# Generated on: 2025-09-21 21:02:25
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * מטפל בבקשות POST לניתוח פרופיל המשתמש באמצעות AI.
 * הפונקציה מאמתת את המשתמש, יוצרת פרופיל נרטיבי מקיף,
 * שולחת אותו לניתוח AI, ומחזירה את התוצאה המובנית.
 */
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // שלב 1: אימות משתמש
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // שלב 2: ודא שהמשתמש והפרופיל קיימים לפני יצירת הנרטיב
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] לא נמצא פרופיל עבור משתמש: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // שלב 3: יצירת פרופיל נרטיבי מקיף
    // שימוש חוזר בלוגיקה הקיימת והמצוינת מ-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] נכשל ביצירת פרופיל נרטיבי עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // שלב 4: שליחת הנרטיב לניתוח AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] שירות ה-AI לא החזיר תוצאה עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // שלב 5: החזרת התוצאה ללקוח
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * מטפל בבקשות POST לניתוח הצעת שידוך עבור המשתמש המחובר.
 * הפונקציה מאמתת את המשתמש, מאחזרת את הפרופיל שלו ואת הפרופיל של המשתמש המוצע,
 * יוצרת פרופילים נרטיביים עבור שניהם, שולחת אותם לניתוח AI מותאם למשתמש,
 * ומחזירה את התוצאה המובנית.
 */
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. אימות וקבלת המשתמש הנוכחי
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. קבלת ID של המשתמש המוצע מגוף הבקשה
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3. ודא ששני הפרופילים קיימים
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] אחד הפרופילים או שניהם לא נמצאו. נמצאו: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. יצירת פרופילים נרטיביים עבור שני המשתמשים במקביל
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] נכשל ביצירת פרופיל נרטיבי עבור אחד המשתמשים.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. שליחת הנרטיבים לניתוח AI מותאם למשתמש
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] שירות ה-AI לא החזיר תוצאת ניתוח הצעה.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. החזרת התוצאה ללקוח
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
# Generated on: 2025-09-18 16:39:27
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * מטפל בבקשות POST לניתוח פרופיל של משתמש ספציפי על ידי שדכן.
 */
export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // שלב 1: אימות והרשאות (שדכן או אדמין בלבד)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // שלב 2: קבלת ID המועמד לניתוח מגוף הבקשה
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId חסר או לא תקין בבקשה.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // שלב 3: יצירת פרופיל נרטיבי עבור המשתמש המבוקש
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] נכשל ביצירת פרופיל נרטיבי עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // שלב 4: שליחת הנרטיב לניתוח AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] שירות ה-AI לא החזיר תוצאה עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // שלב 5: החזרת התוצאה המוצלחת
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";
import prisma from "@/lib/prisma";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    const report = await profileFeedbackService.compileFeedbackReport(userId, locale);
    
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    // בודקים אם מילון המייל קיים לפני השימוש בו
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // שימוש ב-optional chaining (?.) ובערכי ברירת מחדל למניעת קריסה
    const context = {
      locale,
      dict: emailDict.profileFeedback,
      greeting: (emailDict.profileFeedback.greeting || "שלום {{name}}").replace('{{name}}', report.name),
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "השדכן/ית שלך",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    const htmlContent = compiledTemplate(context);

    return NextResponse.json({ success: true, htmlContent });

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json({ success: false, error: "Internal Server Error", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// קריאה לשירות המייל עם התוכן הערוך
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * מטפל בבקשות POST לניתוח פרופיל של משתמש ספציפי על ידי שדכן.
 */
export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // שלב 1: אימות והרשאות (שדכן או אדמין בלבד)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // שלב 2: קבלת ID המועמד לניתוח מגוף הבקשה
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId חסר או לא תקין בבקשה.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // שלב 3: יצירת פרופיל נרטיבי עבור המשתמש המבוקש
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] נכשל ביצירת פרופיל נרטיבי עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // שלב 4: שליחת הנרטיב לניתוח AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] שירות ה-AI לא החזיר תוצאה עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // שלב 5: החזרת התוצאה המוצלחת
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. אימות והרשאות (שדכן או אדמין בלבד)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. קבלת ID המועמד מגוף הבקשה
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. יצירת פרופיל נרטיבי מקיף
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. שליחת הנרטיב ל-AI ליצירת הסיכום
    const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. החזרת התוצאה המוצלחת
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";
import prisma from "@/lib/prisma";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // טוענים את המילון המלא פעם אחת, כולל מודול השאלון
    const dictionary = await getDictionary(locale);
    
    // מעבירים את מודול השאלון כולו לשירות
    const report = await profileFeedbackService.compileFeedbackReport(
        userId, 
        locale,
        dictionary.questionnaire
    );
    
    const emailDict = dictionary.email;

    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    const context = {
      locale,
      dict: emailDict.profileFeedback,
      greeting: (emailDict.profileFeedback.greeting || "שלום {{name}}").replace('{{name}}', report.name),
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "השדכן/ית שלך",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    const htmlContent = compiledTemplate(context);

    return NextResponse.json({ success: true, htmlContent });

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json({ success: false, error: "Internal Server Error", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// קריאה לשירות המייל עם התוכן הערוך
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * פונקציית עזר שמריצה את תהליך העדכון ברקע
 * ומדפיסה לוג מפורט בסיומו.
 * @param userIds - מערך מזהי המשתמשים לעדכון
 * @param adminId - מזהה האדמין שהפעיל את התהליך
 */
async function runBulkUpdateAndLog(userIds: string[], adminId: string) {
  const totalUsers = userIds.length;
  // הודעת התחלה ברורה לתהליך הרקע
 
  try {
    // נשתמש ב-Promise.allSettled כדי להמתין לסיום כל העדכונים, גם אם חלקם נכשלים
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // איסוף מזהי המשתמשים שנכשלו (אם יש כאלה)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // הדפסת סיכום מפורט
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // במקרה של שגיאה קריטית בתהליך הרקע עצמו
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // כאן הלוג המקורי נשאר, כדי שתראה שה-API הופעל
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds, adminId).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

