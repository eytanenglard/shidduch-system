################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
# Generated on: 2026-01-11 20:48:59
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

// -----------------------------------------------------------------------------
// ×”×’×“×¨×•×ª ×ª×¦×•×¨×” ×œ-Next.js ×›×“×™ ×œ×× ×•×¢ Timeout ×•-Caching
// -----------------------------------------------------------------------------

// ×××¤×©×¨ ×œ×¤×•× ×§×¦×™×” ×œ×¨×•×¥ ×¢×“ 300 ×©× ×™×•×ª (×‘××§×•× ×‘×¨×™×¨×ª ×”××—×“×œ ×©×œ 10-15 ×©× ×™×•×ª).
// ×–×” ×§×¨×™×˜×™ ×œ×§×¨×™××•×ª AI ×©×œ×•×§×—×•×ª ×–××Ÿ.
export const maxDuration = 300; 

// ××•×•×“× ×©×”× ×ª×™×‘ ×ª××™×“ ×“×™× ××™ ×•×œ× × ×©××¨ ×‘-Cache ×©×œ ×”×©×¨×ª
export const dynamic = 'force-dynamic';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×”××©×ª××© ×‘×××¦×¢×•×ª AI.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£,
 * ×©×•×œ×—×ª ××•×ª×• ×œ× ×™×ª×•×— AI, ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
  // ×‘×“×™×§×ª Rate Limit
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ××©×ª××©
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // ×©×œ×‘ 2: ×•×“× ×©×”××©×ª××© ×•×”×¤×¨×•×¤×™×œ ×§×™×™××™× ×œ×¤× ×™ ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] ×œ× × ××¦× ×¤×¨×•×¤×™×œ ×¢×‘×•×¨ ××©×ª××©: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    // ×©×™××•×© ×—×•×–×¨ ×‘×œ×•×’×™×§×” ×”×§×™×™××ª ×•×”××¦×•×™× ×ª ×-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×”×¦×¢×ª ×©×™×“×•×š ×¢×‘×•×¨ ×”××©×ª××© ×”××—×•×‘×¨.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×××—×–×¨×ª ××ª ×”×¤×¨×•×¤×™×œ ×©×œ×• ×•××ª ×”×¤×¨×•×¤×™×œ ×©×œ ×”××©×ª××© ×”××•×¦×¢,
 * ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™×”×, ×©×•×œ×—×ª ××•×ª× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©,
 * ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×§×‘×œ×ª ×”××©×ª××© ×”× ×•×›×—×™
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. ×§×‘×œ×ª ID ×©×œ ×”××©×ª××© ×”××•×¦×¢ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3. ×•×“× ×©×©× ×™ ×”×¤×¨×•×¤×™×œ×™× ×§×™×™××™×
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] ××—×“ ×”×¤×¨×•×¤×™×œ×™× ××• ×©× ×™×”× ×œ× × ××¦××•. × ××¦××•: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™ ×”××©×ª××©×™× ×‘××§×‘×™×œ
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ××—×“ ×”××©×ª××©×™×.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘×™× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××ª × ×™×ª×•×— ×”×¦×¢×”.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches-v2
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches-v2\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches-v2/route.ts
// ğŸ¯ API Route ×œ××œ×’×•×¨×™×ª× ××¦×™××ª ×”×ª×××•×ª - ×’×¨×¡×” ×¤×©×•×˜×” (Inline)
// ××¨×™×¥ ××ª ×”××œ×’×•×¨×™×ª× ×™×©×™×¨×•×ª ×‘×ª×•×š ×”-Request - ×‘×œ×™ Jobs!

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { 
  findMatchesForUser,
  loadSavedMatches,
  deleteSavedMatches,
} from "@/lib/services/matchingAlgorithmService";

// ×”×’×“×¨×•×ª
export const dynamic = 'force-dynamic';
export const maxDuration = 60; // Heroku timeout - 30 ×©× ×™×•×ª default, ××¤×©×¨ ×¢×“ 60

// ============================================================================
// TYPES
// ============================================================================

interface PostRequestBody {
  targetUserId: string;
  forceRefresh?: boolean;
}

// ============================================================================
// POST - ××¨×™×¥ ××ª ×”××œ×’×•×¨×™×ª× ×™×©×™×¨×•×ª ×•××—×–×™×¨ ×ª×•×¦××•×ª
// ============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  const startTime = Date.now();
  
  // Rate Limiting
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { 
    requests: 30, 
    window: '1 h' 
  });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // Authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ 
        success: false, 
        error: "Unauthorized: Please log in" 
      }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ 
        success: false, 
        error: "Forbidden: Matchmaker or Admin access required" 
      }, { status: 403 });
    }

    // Body Validation
    const body: PostRequestBody = await req.json();
    const { targetUserId, forceRefresh = false } = body;

    if (!targetUserId || typeof targetUserId !== 'string') {
      return NextResponse.json({ 
        success: false, 
        error: "Bad Request: 'targetUserId' (string) is required" 
      }, { status: 400 });
    }

    const matchmakerId = session.user.id;

    console.log(`\n========================================`);
    console.log(`[API find-matches SIMPLE] POST from ${session.user.email}`);
    console.log(`[API find-matches SIMPLE] Target: ${targetUserId}, forceRefresh: ${forceRefresh}`);
    console.log(`========================================\n`);

    // ğŸš€ ×”×¨×¦×ª ×”××œ×’×•×¨×™×ª× ×™×©×™×¨×•×ª!
    const result = await findMatchesForUser(targetUserId, matchmakerId, {
      forceRefresh,
      autoSave: true,
    });

    const duration = Date.now() - startTime;
    
    console.log(`\n========================================`);
    console.log(`[API find-matches SIMPLE] âœ… Completed in ${duration}ms`);
    console.log(`[API find-matches SIMPLE] Found ${result.matches.length} matches`);
    console.log(`[API find-matches SIMPLE] From cache: ${result.fromCache}`);
    console.log(`========================================\n`);

    return NextResponse.json({
      success: true,
      matches: result.matches,
      fromCache: result.fromCache,
      meta: {
        targetUserId,
        totalMatches: result.matches.length,
        totalCandidatesScanned: result.meta.totalCandidatesScanned,
        analyzedAt: new Date().toISOString(),
        algorithmVersion: result.meta.algorithmVersion,
        savedAt: result.meta.savedAt?.toISOString(),
        isStale: result.meta.isStale,
        durationMs: duration,
      }
    });

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[API find-matches SIMPLE] âŒ Error after ${duration}ms:`, error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred";
    
    return NextResponse.json({ 
      success: false, 
      error: "Internal server error",
      details: errorMessage,
      durationMs: duration,
    }, { status: 500 });
  }
}

// ============================================================================
// GET - ×˜×¢×™× ×ª ×ª×•×¦××•×ª ×©××•×¨×•×ª ×‘×œ×‘×“
// ============================================================================

export async function GET(req: NextRequest): Promise<NextResponse> {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Forbidden" }, { status: 403 });
    }

    const { searchParams } = new URL(req.url);
    const targetUserId = searchParams.get('targetUserId');

    if (!targetUserId) {
      return NextResponse.json({
        name: "NeshamaTech Matching Algorithm",
        version: "3.2-simple",
        description: "Smart matching algorithm - inline execution",
        endpoints: {
          "POST /api/ai/find-matches-v2": "Run matching algorithm (inline)",
          "GET /api/ai/find-matches-v2?targetUserId=...": "Load saved matches",
          "DELETE /api/ai/find-matches-v2?targetUserId=...": "Clear saved matches"
        }
      });
    }

    const savedResults = await loadSavedMatches(targetUserId);

    if (!savedResults) {
      return NextResponse.json({
        success: true,
        matches: [],
        fromCache: false,
        meta: { targetUserId, totalMatches: 0, message: 'No saved matches found.' }
      });
    }

    return NextResponse.json({
      success: true,
      matches: savedResults.matches,
      fromCache: true,
      meta: {
        targetUserId,
        totalMatches: savedResults.matches.length,
        totalCandidatesScanned: savedResults.meta.totalCandidatesScanned,
        algorithmVersion: savedResults.meta.algorithmVersion,
        savedAt: savedResults.meta.savedAt.toISOString(),
        isStale: savedResults.meta.isStale,
      }
    });

  } catch (error) {
    console.error('[API find-matches SIMPLE] GET Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}

// ============================================================================
// DELETE - ××—×™×§×ª ×ª×•×¦××•×ª ×©××•×¨×•×ª
// ============================================================================

export async function DELETE(req: NextRequest): Promise<NextResponse> {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Forbidden" }, { status: 403 });
    }

    const { searchParams } = new URL(req.url);
    const targetUserId = searchParams.get('targetUserId');

    if (!targetUserId) {
      return NextResponse.json({ 
        success: false, 
        error: "Bad Request: 'targetUserId' required" 
      }, { status: 400 });
    }

    await deleteSavedMatches(targetUserId);

    return NextResponse.json({
      success: true,
      message: `Saved matches for ${targetUserId} deleted`
    });

  } catch (error) {
    console.error('[API find-matches SIMPLE] DELETE Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
# Generated on: 2025-12-24 12:00:38
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ×™×¦×™×¨×ª ×¡×™×›×•× ×¤×¨×•×¤×™×œ (××™×©×™×•×ª + ××” ××—×¤×©) ×¢×‘×•×¨ ×©×“×›×Ÿ.
 * ×‘×•×“×§ ××˜××•×Ÿ ×‘×“××˜×” ×‘×™×™×¡ ×œ×¤× ×™ ×¤× ×™×™×” ×œ-AI.
 */
export async function POST(req: NextRequest) {
  // ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™× ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId, forceRefresh } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ ×•×”×©×“×” ×”×—×“×© ××”×“××˜×” ×‘×™×™×¡ ×œ×‘×“×™×§×ª ××˜××•×Ÿ
    const existingProfile = await prisma.profile.findUnique({
      where: { userId },
      select: { 
        aiProfileSummary: true, 
        needsAiProfileUpdate: true 
      }
    });

    if (!existingProfile) {
      return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 4. ×œ×•×’×™×§×ª ××˜××•×Ÿ: ×× ×™×© ×¡×™×›×•× ×©××•×¨, ×”×¤×¨×•×¤×™×œ ×œ× ×”×©×ª× ×”, ×•×œ× ×‘×™×§×©× ×• ×¨×¢× ×•×Ÿ ×‘×›×•×— -> × ×—×–×™×¨ ××ª ×”×§×™×™×
    if (
      existingProfile.aiProfileSummary && 
      !existingProfile.needsAiProfileUpdate && 
      !forceRefresh
    ) {
      console.log(`[API analyze-profile] Returning cached summary for user: ${userId}`);
      return NextResponse.json({ success: true, data: existingProfile.aiProfileSummary });
    }

    console.log(`[API analyze-profile] Generating NEW summary for user: ${userId} (Force: ${forceRefresh})`);

    // 5. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£ (×˜×§×¡×˜ ×’×•×œ××™ ×œ-AI)
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 6. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI (×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”×—×“×©×” ×•×”×××•×§×“×ª)
    const summaryResult = await aiService.generateProfileSummary(narrativeProfile);

    if (!summaryResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 7. ×©××™×¨×ª ×”×ª×•×¦××” ×‘×“××˜×” ×‘×™×™×¡ (×‘×©×“×” ×”×—×“×© aiProfileSummary) ×•××™×¤×•×¡ ×”×“×’×œ needsAiProfileUpdate
    await prisma.profile.update({
      where: { userId },
      data: {
        aiProfileSummary: summaryResult as any, // ×”××¨×” ×œ-Json ×©×œ ×¤×¨×™×–××”
        needsAiProfileUpdate: false // ×”×“×•×— ××¢×•×“×›×Ÿ ×›×¢×ª
      }
    });

    // 8. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”×—×“×©×” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: summaryResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ×™×¦×™×¨×ª ×¡×™×›×•× ×¤×¨×•×¤×™×œ (××™×©×™×•×ª + ××” ××—×¤×©) ×¢×‘×•×¨ ×©×“×›×Ÿ.
 * ×‘×•×“×§ ××˜××•×Ÿ ×‘×“××˜×” ×‘×™×™×¡ ×œ×¤× ×™ ×¤× ×™×™×” ×œ-AI.
 */
export async function POST(req: NextRequest) {
  // ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™× ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId, forceRefresh } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ ×•×”×©×“×” ×”×—×“×© ××”×“××˜×” ×‘×™×™×¡ ×œ×‘×“×™×§×ª ××˜××•×Ÿ
    const existingProfile = await prisma.profile.findUnique({
      where: { userId },
      select: { 
        aiProfileSummary: true, 
        needsAiProfileUpdate: true 
      }
    });

    if (!existingProfile) {
      return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 4. ×œ×•×’×™×§×ª ××˜××•×Ÿ: ×× ×™×© ×¡×™×›×•× ×©××•×¨, ×”×¤×¨×•×¤×™×œ ×œ× ×”×©×ª× ×”, ×•×œ× ×‘×™×§×©× ×• ×¨×¢× ×•×Ÿ ×‘×›×•×— -> × ×—×–×™×¨ ××ª ×”×§×™×™×
    if (
      existingProfile.aiProfileSummary && 
      !existingProfile.needsAiProfileUpdate && 
      !forceRefresh
    ) {
      console.log(`[API analyze-profile] Returning cached summary for user: ${userId}`);
      return NextResponse.json({ success: true, data: existingProfile.aiProfileSummary });
    }

    console.log(`[API analyze-profile] Generating NEW summary for user: ${userId} (Force: ${forceRefresh})`);

    // 5. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£ (×˜×§×¡×˜ ×’×•×œ××™ ×œ-AI)
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 6. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI (×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”×—×“×©×” ×•×”×××•×§×“×ª)
    const summaryResult = await aiService.generateProfileSummary(narrativeProfile);

    if (!summaryResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 7. ×©××™×¨×ª ×”×ª×•×¦××” ×‘×“××˜×” ×‘×™×™×¡ (×‘×©×“×” ×”×—×“×© aiProfileSummary) ×•××™×¤×•×¡ ×”×“×’×œ needsAiProfileUpdate
    await prisma.profile.update({
      where: { userId },
      data: {
        aiProfileSummary: summaryResult as any, // ×”××¨×” ×œ-Json ×©×œ ×¤×¨×™×–××”
        needsAiProfileUpdate: false // ×”×“×•×— ××¢×•×“×›×Ÿ ×›×¢×ª
      }
    });

    // 8. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”×—×“×©×” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: summaryResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export const maxDuration = 60; // ×–××Ÿ ×¨×™×¦×” ××§×¡×™××œ×™ (×× ×”×©×¨×ª ×ª×•××š)
export const dynamic = 'force-dynamic';

export async function POST(req: NextRequest) {
  try {
    // 1. ×‘×“×™×§×ª ×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { action, batchSize = 5 } = await req.json();

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 1: RESET_FLAGS
    // ×¡×™××•×Ÿ ×›×œ ×”××•×¢××“×™× ×”×¤×¢×™×œ×™× ×›"× ×“×¨×©×™× ×œ×¢×“×›×•×Ÿ"
    // ×× ×—× ×• ××¡×× ×™× ××ª ×›×•×œ×, ×”×¡×™× ×•×Ÿ ×”×××™×ª×™ ×™×§×¨×” ×‘×–××Ÿ ×”×¢×™×‘×•×“ ×›×“×™ ×œ×—×¡×•×š ×‘×™×¦×•×¢×™×
    // ---------------------------------------------------------
    if (action === 'RESET_FLAGS') {
      const updateResult = await prisma.profile.updateMany({
        where: {
          user: {
            role: 'CANDIDATE',
            // ××¡× × ×™× ×¨×§ ×™×•×–×¨×™× ×¤×¢×™×œ×™× ××• ×‘×ª×”×œ×™×š ××™××•×ª (×œ× ×—×¡×•××™×)
            status: { in: ['ACTIVE', 'PENDING_EMAIL_VERIFICATION', 'PENDING_PHONE_VERIFICATION'] }
          }
        },
        data: { needsAiProfileUpdate: true }
      });
      
      return NextResponse.json({ 
        success: true, 
        message: 'Flags reset successfully', 
        count: updateResult.count 
      });
    }

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 2: PROCESS_BATCH
    // ×©×œ×™×¤×” ×•×¢×™×‘×•×“ ×©×œ ×§×‘×•×¦×ª ××©×ª××©×™×
    // ---------------------------------------------------------
    if (action === 'PROCESS_BATCH') {
      // 1. ×©×œ×™×¤×ª ××•×¢××“×™× ×©×¦×¨×™×›×™× ×¢×“×›×•×Ÿ
      const candidatesToProcess = await prisma.user.findMany({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: {
            needsAiProfileUpdate: true
          }
        },
        take: batchSize,
        // ×©×œ×™×¤×ª ×”××™×“×¢ ×”×¨×œ×•×•× ×˜×™ ×œ×‘×“×™×§×ª "×”×× ×™×© ×“××˜×”"
        include: {
          profile: {
            select: { id: true, about: true, needsAiProfileUpdate: true }
          },
          questionnaireResponses: {
            select: { id: true } // ××¡×¤×™×§ ×œ×“×¢×ª ×× ×§×™×™× ID ×›×“×™ ×œ×“×¢×ª ×©×™×© ×©××œ×•×Ÿ
          }
        }
      });

      // ×‘×“×™×§×” ×›××” × ×©××¨×• ×¡×”"×› (×œ×¦×•×¨×š ×”-Progress Bar)
      const remainingCount = await prisma.user.count({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: { needsAiProfileUpdate: true }
        }
      });

      // ×× ××™×Ÿ ×™×•×ª×¨ ××•×¢××“×™× ×œ×¢×“×›×•×Ÿ - ×¡×™×™×× ×•
      if (candidatesToProcess.length === 0) {
        return NextResponse.json({ success: true, processed: 0, remaining: 0, completed: true });
      }

      console.log(`[Batch AI] Processing batch of ${candidatesToProcess.length} candidates...`);

      // 2. ×¢×™×‘×•×“ ×‘××§×‘×™×œ
      const results = await Promise.all(
        candidatesToProcess.map(async (user) => {
          try {
            // --- ×©×œ×‘ ×”×¡×™× ×•×Ÿ ×”×—×›× ---
            // × ×‘×“×•×§ ×”×× ×œ×™×•×–×¨ ×™×© ××™×“×¢ ×¨×œ×•×•× ×˜×™ ×œ-AI
            
            const hasAbout = user.profile?.about && user.profile.about.trim().length > 10; // ×œ×¤×—×•×ª 10 ×ª×•×•×™×
            const hasQuestionnaire = user.questionnaireResponses && user.questionnaireResponses.length > 0;

            // ×× ××™×Ÿ ×©×•× ××™×“×¢ - ××“×œ×’×™× (××‘×œ ××›×‘×™× ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×—×–×•×¨ ××œ×™×•)
            if (!hasAbout && !hasQuestionnaire) {
              await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
              });
              return { id: user.id, status: 'skipped_no_data' };
            }

            // --- ×™×© ××™×“×¢? ×××©×™×›×™× ×œ-AI ---

            // 1. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ (×”×¤×•× ×§×¦×™×” ×”×–×• ×›×‘×¨ ×™×•×“×¢×ª ×œ×§×—×ª ×©××œ×•× ×™× ×•-about)
            const narrative = await profileAiService.generateNarrativeProfile(user.id);
            
            // ×”×’× ×” × ×•×¡×¤×ª ×œ××§×¨×” ×©×”× ×¨×˜×™×‘ ×™×¦× ×¨×™×§ ×œ××¨×•×ª ×”×‘×“×™×§×”
            if (!narrative || narrative.length < 20) {
                await prisma.profile.update({
                    where: { userId: user.id },
                    data: { needsAiProfileUpdate: false }
                });
                return { id: user.id, status: 'skipped_empty_narrative' };
            }

            // 2. ×™×¦×™×¨×ª ×”×“×•×— ×‘-AI
            const summary = await aiService.generateProfileSummary(narrative);
            
            if (!summary) throw new Error("AI Summary failed");

            // 3. ×©××™×¨×” ×‘×“××˜×” ×‘×™×™×¡ ×•×›×™×‘×•×™ ×”×“×’×œ
            await prisma.profile.update({
              where: { userId: user.id },
              data: {
                aiProfileSummary: summary as any, // ×”××¨×ª JSON ×œ×¤×•×¨××˜ ×©×œ ×¤×¨×™×–××”
                needsAiProfileUpdate: false,
                // ××•×¤×¦×™×•× ×œ×™: ×¢×“×›×•×Ÿ ××•× ×” ×”×¤×¢××™× ×©×”×•×¤×§ ×“×•×— (×× ×”×•×¡×¤×ª ××ª ×”×©×“×” ××”××•×“×œ)
                // neshamaInsightGeneratedCount: { increment: 1 },
                // neshamaInsightLastGeneratedAt: new Date()
              }
            });

            return { id: user.id, status: 'success' };

          } catch (error) {
            console.error(`[Batch AI] Failed for user ${user.id}:`, error);
            // ×‘××§×¨×” ×©×’×™××” ×˜×›× ×™×ª ×‘-AI, × ×›×‘×” ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×ª×§×•×¢ ××ª ×”×ª×”×œ×™×š ×”×›×œ×œ×™
            await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
            });
            return { id: user.id, status: 'error' };
          }
        })
      );

      const successful = results.filter(r => r.status === 'success').length;
      const skipped = results.filter(r => r.status.startsWith('skipped')).length;

      return NextResponse.json({
        success: true,
        processed: candidatesToProcess.length, // ×¡×š ×”×›×œ ×©×¢×‘×¨×• ×‘×‘××¥'
        successful, // ×›××” × ×•×¦×¨×• ×‘×¤×•×¢×œ
        skipped,    // ×›××” ×“×•×œ×’×• ×›×™ ×”×™×• ×¨×™×§×™×
        remaining: Math.max(0, remainingCount - candidatesToProcess.length),
        completed: (remainingCount - candidatesToProcess.length) <= 0
      });
    }

    return NextResponse.json({ success: false, error: "Invalid action" }, { status: 400 });

  } catch (error) {
    console.error('[Batch Process] Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/test-connection/route.ts

import { NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function GET() {
  console.log('--- [API TEST] Received request at /api/ai/test-connection ---');

  const apiKey = process.env.GOOGLE_API_KEY;

  if (!apiKey) {
    console.error('--- [API TEST] FATAL ERROR: GOOGLE_API_KEY is not set in .env or .env.local!');
    return NextResponse.json(
      { success: false, error: 'Server configuration error: GOOGLE_API_KEY is missing.' },
      { status: 500 }
    );
  }

  // --- ×§×˜×¢ ×”××™××•×ª ×©×”×•×¡×¤× ×• ---
  const keyIdentifier = `Starts with: ${apiKey.substring(0, 5)}... | Ends with: ...${apiKey.substring(apiKey.length - 4)} | Length: ${apiKey.length}`; // <-- ×”×•×¡×£
  console.log(`--- [API TEST] Verifying the loaded API Key: ${keyIdentifier} ---`); // <-- ×”×•×¡×£
  // -----------------------------

  console.log('--- [API TEST] GOOGLE_API_KEY found. Proceeding with API call.');

  try {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' }); 
    const prompt = 'Say "Connection Successful" in one sentence.';

    console.log('--- [API TEST] Sending a simple prompt to Google AI...');
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    console.log('--- [API TEST] SUCCESS! Google AI responded:', text);
    return NextResponse.json({ success: true, message: 'Connection to Google AI is working!', response: text });

  } catch (error) {
    console.error('--- [API TEST] FAILED! The API call to Google threw an error.', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to connect to Google AI. This is likely an API key, permissions, or billing issue.',
        details: JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×©××¨×™×¦×” ××ª ×ª×”×œ×™×š ×”×¢×“×›×•×Ÿ ×‘×¨×§×¢
 * ×•××“×¤×™×¡×” ×œ×•×’ ××¤×•×¨×˜ ×‘×¡×™×•××•.
 * @param userIds - ××¢×¨×š ××–×”×™ ×”××©×ª××©×™× ×œ×¢×“×›×•×Ÿ
 * @param adminId - ××–×”×” ×”××“××™×Ÿ ×©×”×¤×¢×™×œ ××ª ×”×ª×”×œ×™×š
 */
async function runBulkUpdateAndLog(userIds: string[]) {
  const totalUsers = userIds.length;
  // ×”×•×“×¢×ª ×”×ª×—×œ×” ×‘×¨×•×¨×” ×œ×ª×”×œ×™×š ×”×¨×§×¢
 
  try {
    // × ×©×ª××© ×‘-Promise.allSettled ×›×“×™ ×œ×”××ª×™×Ÿ ×œ×¡×™×•× ×›×œ ×”×¢×“×›×•× ×™×, ×’× ×× ×—×œ×§× × ×›×©×œ×™×
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // ××™×¡×•×£ ××–×”×™ ×”××©×ª××©×™× ×©× ×›×©×œ×• (×× ×™×© ×›××œ×”)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // ×”×“×¤×¡×ª ×¡×™×›×•× ××¤×•×¨×˜
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // ×‘××§×¨×” ×©×œ ×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ×”×¨×§×¢ ×¢×¦××•
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // ×›××Ÿ ×”×œ×•×’ ×”××§×•×¨×™ × ×©××¨, ×›×“×™ ×©×ª×¨××” ×©×”-API ×”×•×¤×¢×œ
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

