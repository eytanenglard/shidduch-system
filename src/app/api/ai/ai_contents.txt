################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
# Generated on: 2026-01-15 22:42:27
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

// -----------------------------------------------------------------------------
// ×”×’×“×¨×•×ª ×ª×¦×•×¨×” ×œ-Next.js ×›×“×™ ×œ×× ×•×¢ Timeout ×•-Caching
// -----------------------------------------------------------------------------

// ×××¤×©×¨ ×œ×¤×•× ×§×¦×™×” ×œ×¨×•×¥ ×¢×“ 300 ×©× ×™×•×ª (×‘××§×•× ×‘×¨×™×¨×ª ×”××—×“×œ ×©×œ 10-15 ×©× ×™×•×ª).
// ×–×” ×§×¨×™×˜×™ ×œ×§×¨×™××•×ª AI ×©×œ×•×§×—×•×ª ×–××Ÿ.
export const maxDuration = 300; 

// ××•×•×“× ×©×”× ×ª×™×‘ ×ª××™×“ ×“×™× ××™ ×•×œ× × ×©××¨ ×‘-Cache ×©×œ ×”×©×¨×ª
export const dynamic = 'force-dynamic';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×”××©×ª××© ×‘×××¦×¢×•×ª AI.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£,
 * ×©×•×œ×—×ª ××•×ª×• ×œ× ×™×ª×•×— AI, ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
  // ×‘×“×™×§×ª Rate Limit
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ××©×ª××©
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // ×©×œ×‘ 2: ×•×“× ×©×”××©×ª××© ×•×”×¤×¨×•×¤×™×œ ×§×™×™××™× ×œ×¤× ×™ ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] ×œ× × ××¦× ×¤×¨×•×¤×™×œ ×¢×‘×•×¨ ××©×ª××©: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    // ×©×™××•×© ×—×•×–×¨ ×‘×œ×•×’×™×§×” ×”×§×™×™××ª ×•×”××¦×•×™× ×ª ×-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×”×¦×¢×ª ×©×™×“×•×š ×¢×‘×•×¨ ×”××©×ª××© ×”××—×•×‘×¨.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×××—×–×¨×ª ××ª ×”×¤×¨×•×¤×™×œ ×©×œ×• ×•××ª ×”×¤×¨×•×¤×™×œ ×©×œ ×”××©×ª××© ×”××•×¦×¢,
 * ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™×”×, ×©×•×œ×—×ª ××•×ª× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©,
 * ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×§×‘×œ×ª ×”××©×ª××© ×”× ×•×›×—×™
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. ×§×‘×œ×ª ID ×©×œ ×”××©×ª××© ×”××•×¦×¢ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3. ×•×“× ×©×©× ×™ ×”×¤×¨×•×¤×™×œ×™× ×§×™×™××™×
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] ××—×“ ×”×¤×¨×•×¤×™×œ×™× ××• ×©× ×™×”× ×œ× × ××¦××•. × ××¦××•: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™ ×”××©×ª××©×™× ×‘××§×‘×™×œ
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ××—×“ ×”××©×ª××©×™×.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘×™× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××ª × ×™×ª×•×— ×”×¦×¢×”.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches-v2
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches-v2\route.ts
--------------------------------------------------------------------------------
Content:
// ===========================================
// src/app/api/ai/find-matches-v2/route.ts
// ===========================================
// ğŸ¯ API Route ×¢× ×ª××™×›×” ×‘-Background Jobs
// ×¤×•×ª×¨ ××ª ×‘×¢×™×™×ª ×”-30 ×©× ×™×•×ª timeout ×©×œ Heroku
// ğŸ”§ ×ª×™×§×•×Ÿ: ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ ××¢×•×‘×“ ×™×©×™×¨×•×ª (×œ× fire-and-forget)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole, Gender } from "@prisma/client";
import prisma from "@/lib/prisma";
import { findMatchesForVirtualUser } from '@/lib/services/matchingAlgorithmService';
import { findMatchesForVirtualUserVector } from '@/lib/services/vectorMatchingService';

export const dynamic = 'force-dynamic';
export const maxDuration = 300; // 5 ×“×§×•×ª ×œ×—×™×¤×•×©×™× ××¨×•×›×™×

// ============================================================================
// TYPES
// ============================================================================

interface VirtualProcessingParams {
  virtualProfileId: string;
  virtualProfile: any;
  gender: string;
  religiousLevel: string;
  editedSummary?: string;
  method: string;
  matchmakerId: string;
}

// ============================================================================
// POST - ×”×ª×—×œ×ª Job ×—×“×© (××—×–×™×¨ ××™×“!)
// ============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  try {
    // Authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ 
        success: false, 
        error: "Unauthorized" 
      }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ 
        success: false, 
        error: "Forbidden" 
      }, { status: 403 });
    }

    // Parse body
    const body = await req.json();
    const { 
      targetUserId, 
      forceRefresh = false, 
      method = 'algorithmic',
      // ğŸ†• ×¤×¨××˜×¨×™× ×œ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™
      isVirtualSearch = false,
      virtualProfileId,
      virtualProfile,
      gender,
      religiousLevel,
      editedSummary,
    } = body;

    const matchmakerId = session.user.id;

    // ================================================================
    // ğŸ”® ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ - ××¢×•×‘×“ ×™×©×™×¨×•×ª (×œ× fire-and-forget)
    // ================================================================
    if (isVirtualSearch) {
      if (!virtualProfileId || !virtualProfile || !gender || !religiousLevel) {
        return NextResponse.json({ 
          success: false, 
          error: "Missing required virtual profile parameters" 
        }, { status: 400 });
      }

      console.log(`\n${'='.repeat(60)}`);
      console.log(`[MatchingJob] ğŸ”® Virtual search request from ${session.user.email}`);
      console.log(`[MatchingJob] Virtual Profile: ${virtualProfileId}, Method: ${method}`);
      console.log(`${'='.repeat(60)}\n`);

      // ×™×¦×™×¨×ª Job ×—×“×© ×œ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™
      const newJob = await prisma.matchingJob.create({
        data: {
          targetUserId: virtualProfileId,
          matchmakerId,
          method: `${method}-virtual`,
          status: 'processing', // ××ª×—×™×œ ×™×©×¨ ×‘-processing
          progress: 5,
          progressMessage: '××ª×—×™×œ ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™...'
        }
      });

      console.log(`[MatchingJob] ğŸ†• Created virtual job: ${newJob.id}`);

      // ğŸ”¥ ×”×¤×¢×œ×ª ×¢×™×‘×•×“ ×™×©×™×¨ (×œ× fire-and-forget!)
      // ××©×ª××©×™× ×‘-Promise ×©×œ× ××—×›×™× ×œ×•, ××‘×œ ××¢×‘×“×™× ×™×©×™×¨×•×ª
      processVirtualSearchDirectly(newJob.id, {
        virtualProfileId,
        virtualProfile,
        gender,
        religiousLevel,
        editedSummary,
        method,
        matchmakerId,
      }).catch(err => {
        console.error(`[MatchingJob] âŒ Virtual search processing error:`, err);
      });

      // ××—×–×™×¨×™× ×ª×©×•×‘×” ××™×™×“×™×ª ×¢× ×”-jobId
      return NextResponse.json({
        success: true,
        jobId: newJob.id,
        status: 'processing',
        progress: 5,
        progressMessage: '××ª×—×™×œ ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™...',
        isVirtualSearch: true,
      });
    }

    // ================================================================
    // ğŸ‘¤ ×—×™×¤×•×© ×¨×’×™×œ - ×××©×™×š ×›×¨×’×™×œ
    // ================================================================
    
    if (!targetUserId || typeof targetUserId !== 'string') {
      return NextResponse.json({ 
        success: false, 
        error: "targetUserId is required" 
      }, { status: 400 });
    }

    console.log(`[MatchingJob] ğŸ“‹ New request from ${session.user.email}`);
    console.log(`[MatchingJob] Target: ${targetUserId}, Method: ${method}`);

    // ×‘×“×™×§×” ×× ×™×© Job ×¤×¢×™×œ ×§×™×™× ×œ××•×ª×• ××©×ª××©
    const existingActiveJob = await prisma.matchingJob.findFirst({
      where: {
        targetUserId,
        method,
        status: { in: ['pending', 'processing'] }
      }
    });

    if (existingActiveJob) {
      console.log(`[MatchingJob] â³ Found existing active job: ${existingActiveJob.id}`);
      return NextResponse.json({
        success: true,
        jobId: existingActiveJob.id,
        status: existingActiveJob.status,
        progress: existingActiveJob.progress,
        progressMessage: existingActiveJob.progressMessage,
        isExisting: true
      });
    }

    // ×‘×“×™×§×ª Cache
    if (!forceRefresh) {
      const recentCompletedJob = await prisma.matchingJob.findFirst({
        where: {
          targetUserId,
          method,
          status: 'completed',
          completedAt: { 
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
          }
        },
        orderBy: { completedAt: 'desc' }
      });

      if (recentCompletedJob && recentCompletedJob.result) {
        console.log(`[MatchingJob] âœ… Using cached results from ${recentCompletedJob.completedAt}`);
        return NextResponse.json({
          success: true,
          jobId: recentCompletedJob.id,
          status: 'completed',
          progress: 100,
          fromCache: true,
          result: recentCompletedJob.result,
          meta: {
            completedAt: recentCompletedJob.completedAt,
            matchesFound: recentCompletedJob.matchesFound,
            totalCandidates: recentCompletedJob.totalCandidates
          }
        });
      }
    }

    // ×™×¦×™×¨×ª Job ×—×“×©
    const newJob = await prisma.matchingJob.create({
      data: {
        targetUserId,
        matchmakerId,
        method,
        status: 'pending',
        progress: 0,
        progressMessage: '×××ª×™×Ÿ ×œ×”×ª×—×œ×”...'
      }
    });

    console.log(`[MatchingJob] ğŸ†• Created new job: ${newJob.id}`);

    // ×”×¤×¢×œ×ª ×¢×™×‘×•×“ ×‘×¨×§×¢ (×œ×—×™×¤×•×© ×¨×’×™×œ)
    triggerBackgroundProcessing(newJob.id).catch(err => {
      console.error(`[MatchingJob] Failed to trigger background processing:`, err);
    });

    return NextResponse.json({
      success: true,
      jobId: newJob.id,
      status: 'pending',
      progress: 0,
      progressMessage: '×××ª×™×Ÿ ×œ×”×ª×—×œ×”...'
    });

  } catch (error) {
    console.error('[MatchingJob] POST Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Internal server error" 
    }, { status: 500 });
  }
}

// ============================================================================
// ğŸ”® ×¢×™×‘×•×“ ×™×©×™×¨ ×©×œ ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ (×œ× fire-and-forget!)
// ============================================================================

async function processVirtualSearchDirectly(
  jobId: string,
  params: VirtualProcessingParams
): Promise<void> {
  const startTime = Date.now();
  
  console.log(`\n${'='.repeat(60)}`);
  console.log(`[VirtualSearch] ğŸš€ Starting direct processing for job: ${jobId}`);
  console.log(`[VirtualSearch] Method: ${params.method}`);
  console.log(`${'='.repeat(60)}\n`);

  try {
    // ×¢×“×›×•×Ÿ ×”×ª×§×“××•×ª
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        progress: 10,
        progressMessage: '×˜×•×¢×Ÿ ×¤×¨×•×¤×™×œ ×•×™×¨×˜×•××œ×™...'
      }
    });

    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        progress: 20,
        progressMessage: '××—×¤×© ×”×ª×××•×ª...'
      }
    });

    let result;

    // ×‘×—×™×¨×ª ×©×™×˜×ª ×—×™×¤×•×©
    if (params.method === 'vector' || params.method === 'vector-virtual') {
      console.log(`[VirtualSearch] ğŸ”· Using Vector Search`);
      
      await prisma.matchingJob.update({
        where: { id: jobId },
        data: {
          progress: 40,
          progressMessage: '××‘×¦×¢ ×—×™×¤×•×© ×•×§×˜×•×¨×™...'
        }
      });

      result = await findMatchesForVirtualUserVector(
        params.virtualProfileId,
        params.virtualProfile,
        params.gender as Gender,
        params.religiousLevel,
        params.matchmakerId,
        params.editedSummary
      );

    } else {
      console.log(`[VirtualSearch] ğŸ§  Using Algorithmic Search`);
      
      await prisma.matchingJob.update({
        where: { id: jobId },
        data: {
          progress: 40,
          progressMessage: '×× ×ª×— ××•×¢××“×™× ×¤×•×˜× ×¦×™××œ×™×™×...'
        }
      });

      result = await findMatchesForVirtualUser(
        params.virtualProfileId,
        null, // name - ×œ× × ×“×¨×©
        params.virtualProfile,
        params.gender as Gender,
        params.religiousLevel,
        params.matchmakerId,
        params.editedSummary
      );
    }

    // ×—×™×©×•×‘ ×–××Ÿ ×¨×™×¦×”
    const duration = Date.now() - startTime;
    const durationSeconds = (duration / 1000).toFixed(1);

    // ×©××™×¨×ª ×”×ª×•×¦××•×ª
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'completed',
        progress: 100,
        progressMessage: `×”×•×©×œ×! × ××¦××• ${result.matches.length} ×”×ª×××•×ª`,
        result: result.matches as any,
        matchesFound: result.matches.length,
        totalCandidates: result.meta?.totalCandidatesScanned || 0,
        completedAt: new Date()
      }
    });

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[VirtualSearch] âœ… Job ${jobId} completed successfully!`);
    console.log(`[VirtualSearch] â±ï¸ Duration: ${durationSeconds} seconds`);
    console.log(`[VirtualSearch] ğŸ“Š Matches found: ${result.matches.length}`);
    console.log(`${'='.repeat(60)}\n`);

  } catch (error) {
    const duration = Date.now() - startTime;
    
    console.error(`\n${'='.repeat(60)}`);
    console.error(`[VirtualSearch] âŒ Job ${jobId} FAILED after ${(duration/1000).toFixed(1)}s`);
    console.error(`[VirtualSearch] Error:`, error);
    console.error(`${'='.repeat(60)}\n`);

    // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×œ×›×™×©×œ×•×Ÿ
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        progress: 0,
        progressMessage: '×”×—×™×¤×•×© × ×›×©×œ',
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }).catch(err => {
      console.error(`[VirtualSearch] Failed to update job status:`, err);
    });
  }
}

// ============================================================================
// GET - ×‘×“×™×§×ª ×¡×˜×˜×•×¡ Job
// ============================================================================

export async function GET(req: NextRequest): Promise<NextResponse> {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const jobId = searchParams.get('jobId');
    const targetUserId = searchParams.get('targetUserId');

    // ×× ××™×Ÿ jobId - ××—×–×™×¨ ×¨×©×™××ª jobs ××• ××™×“×¢ ×¢×œ ×”-API
    if (!jobId) {
      // ×× ×™×© targetUserId - ××—×–×™×¨ ××ª ×”-jobs ×©×œ×•
      if (targetUserId) {
        const jobs = await prisma.matchingJob.findMany({
          where: { targetUserId },
          orderBy: { createdAt: 'desc' },
          take: 5,
          select: {
            id: true,
            status: true,
            progress: true,
            method: true,
            matchesFound: true,
            createdAt: true,
            completedAt: true
          }
        });
        return NextResponse.json({ success: true, jobs });
      }

      // ××—×¨×ª - ××—×–×™×¨ ××™×“×¢ ×¢×œ ×”-API
      return NextResponse.json({
        name: "NeshamaTech Matching API with Background Jobs",
        version: "4.1",
        endpoints: {
          "POST": "Start a new matching job",
          "GET ?jobId=xxx": "Check job status",
          "GET ?targetUserId=xxx": "List jobs for user",
          "DELETE ?jobId=xxx": "Cancel/delete a job"
        }
      });
    }

    // ×©×œ×™×¤×ª Job ×¡×¤×¦×™×¤×™
    const job = await prisma.matchingJob.findUnique({
      where: { id: jobId }
    });

    if (!job) {
      return NextResponse.json({ 
        success: false, 
        error: "Job not found" 
      }, { status: 404 });
    }

    // ××—×–×™×¨ ××ª ×”×¡×˜×˜×•×¡
    return NextResponse.json({
      success: true,
      jobId: job.id,
      targetUserId: job.targetUserId,
      method: job.method,
      status: job.status,
      progress: job.progress,
      progressMessage: job.progressMessage,
      result: job.status === 'completed' ? job.result : null,
      error: job.error,
      meta: {
        createdAt: job.createdAt,
        completedAt: job.completedAt,
        matchesFound: job.matchesFound,
        totalCandidates: job.totalCandidates
      }
    });

  } catch (error) {
    console.error('[MatchingJob] GET Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Internal server error" 
    }, { status: 500 });
  }
}

// ============================================================================
// DELETE - ×‘×™×˜×•×œ/××—×™×§×ª Job
// ============================================================================

export async function DELETE(req: NextRequest): Promise<NextResponse> {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const jobId = searchParams.get('jobId');

    if (!jobId) {
      return NextResponse.json({ 
        success: false, 
        error: "jobId is required" 
      }, { status: 400 });
    }

    // ××•×—×§ ××• ××¡××Ÿ ×›-cancelled
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: { 
        status: 'failed',
        error: 'Cancelled by user'
      }
    });

    return NextResponse.json({
      success: true,
      message: "Job cancelled"
    });

  } catch (error) {
    console.error('[MatchingJob] DELETE Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Internal server error" 
    }, { status: 500 });
  }
}

// ============================================================================
// Background Processing Trigger (×œ×—×™×¤×•×© ×¨×’×™×œ ×‘×œ×‘×“)
// ============================================================================

async function triggerBackgroundProcessing(jobId: string): Promise<void> {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || process.env.NEXTAUTH_URL || 'http://localhost:3000';
  
  console.log(`[MatchingJob] ğŸš€ Triggering background processing for job: ${jobId}`);
  console.log(`[MatchingJob] ğŸŒ Base URL: ${baseUrl}`);
  
  try {
    const response = await fetch(`${baseUrl}/api/ai/process-matching-job`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'x-internal-secret': process.env.INTERNAL_API_SECRET || 'default-secret'
      },
      body: JSON.stringify({ jobId })
    });
    
    console.log(`[MatchingJob] âœ… Background job triggered, status: ${response.status}`);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[MatchingJob] âš ï¸ Background trigger returned error:`, errorText);
    }
    
  } catch (err) {
    // ×× ×”×§×¨×™××” × ×›×©×œ×”, ××¢×“×›× ×™× ××ª ×”-Job ×¢× ×©×’×™××”
    console.error(`[MatchingJob] âŒ Failed to trigger background processing:`, err);
    
    // ×¢×“×›×•×Ÿ Job ×œ×¡×˜×˜×•×¡ ×©×’×™××”
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        error: `Failed to start background processing: ${err instanceof Error ? err.message : 'Unknown error'}`,
        progressMessage: '×©×’×™××” ×‘×”×¤×¢×œ×ª ×”×—×™×¤×•×©'
      }
    }).catch(updateErr => {
      console.error(`[MatchingJob] Failed to update job status:`, updateErr);
    });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ×™×¦×™×¨×ª ×¡×™×›×•× ×¤×¨×•×¤×™×œ (××™×©×™×•×ª + ××” ××—×¤×©) ×¢×‘×•×¨ ×©×“×›×Ÿ.
 * ×‘×•×“×§ ××˜××•×Ÿ ×‘×“××˜×” ×‘×™×™×¡ ×œ×¤× ×™ ×¤× ×™×™×” ×œ-AI.
 */
export async function POST(req: NextRequest) {
  // ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™× ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId, forceRefresh } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ ×•×”×©×“×” ×”×—×“×© ××”×“××˜×” ×‘×™×™×¡ ×œ×‘×“×™×§×ª ××˜××•×Ÿ
    const existingProfile = await prisma.profile.findUnique({
      where: { userId },
      select: { 
        aiProfileSummary: true, 
        needsAiProfileUpdate: true 
      }
    });

    if (!existingProfile) {
      return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 4. ×œ×•×’×™×§×ª ××˜××•×Ÿ: ×× ×™×© ×¡×™×›×•× ×©××•×¨, ×”×¤×¨×•×¤×™×œ ×œ× ×”×©×ª× ×”, ×•×œ× ×‘×™×§×©× ×• ×¨×¢× ×•×Ÿ ×‘×›×•×— -> × ×—×–×™×¨ ××ª ×”×§×™×™×
    if (
      existingProfile.aiProfileSummary && 
      !existingProfile.needsAiProfileUpdate && 
      !forceRefresh
    ) {
      console.log(`[API analyze-profile] Returning cached summary for user: ${userId}`);
      return NextResponse.json({ success: true, data: existingProfile.aiProfileSummary });
    }

    console.log(`[API analyze-profile] Generating NEW summary for user: ${userId} (Force: ${forceRefresh})`);

    // 5. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£ (×˜×§×¡×˜ ×’×•×œ××™ ×œ-AI)
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 6. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI (×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”×—×“×©×” ×•×”×××•×§×“×ª)
    const summaryResult = await aiService.generateProfileSummary(narrativeProfile);

    if (!summaryResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 7. ×©××™×¨×ª ×”×ª×•×¦××” ×‘×“××˜×” ×‘×™×™×¡ (×‘×©×“×” ×”×—×“×© aiProfileSummary) ×•××™×¤×•×¡ ×”×“×’×œ needsAiProfileUpdate
    await prisma.profile.update({
      where: { userId },
      data: {
        aiProfileSummary: summaryResult as any, // ×”××¨×” ×œ-Json ×©×œ ×¤×¨×™×–××”
        needsAiProfileUpdate: false // ×”×“×•×— ××¢×•×“×›×Ÿ ×›×¢×ª
      }
    });

    // 8. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”×—×“×©×” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: summaryResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export const maxDuration = 60; // ×–××Ÿ ×¨×™×¦×” ××§×¡×™××œ×™ (×× ×”×©×¨×ª ×ª×•××š)
export const dynamic = 'force-dynamic';

export async function POST(req: NextRequest) {
  try {
    // 1. ×‘×“×™×§×ª ×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { action, batchSize = 5 } = await req.json();

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 1: RESET_FLAGS
    // ×¡×™××•×Ÿ ×›×œ ×”××•×¢××“×™× ×”×¤×¢×™×œ×™× ×›"× ×“×¨×©×™× ×œ×¢×“×›×•×Ÿ"
    // ×× ×—× ×• ××¡×× ×™× ××ª ×›×•×œ×, ×”×¡×™× ×•×Ÿ ×”×××™×ª×™ ×™×§×¨×” ×‘×–××Ÿ ×”×¢×™×‘×•×“ ×›×“×™ ×œ×—×¡×•×š ×‘×™×¦×•×¢×™×
    // ---------------------------------------------------------
    if (action === 'RESET_FLAGS') {
      const updateResult = await prisma.profile.updateMany({
        where: {
          user: {
            role: 'CANDIDATE',
            // ××¡× × ×™× ×¨×§ ×™×•×–×¨×™× ×¤×¢×™×œ×™× ××• ×‘×ª×”×œ×™×š ××™××•×ª (×œ× ×—×¡×•××™×)
            status: { in: ['ACTIVE', 'PENDING_EMAIL_VERIFICATION', 'PENDING_PHONE_VERIFICATION'] }
          }
        },
        data: { needsAiProfileUpdate: true }
      });
      
      return NextResponse.json({ 
        success: true, 
        message: 'Flags reset successfully', 
        count: updateResult.count 
      });
    }

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 2: PROCESS_BATCH
    // ×©×œ×™×¤×” ×•×¢×™×‘×•×“ ×©×œ ×§×‘×•×¦×ª ××©×ª××©×™×
    // ---------------------------------------------------------
    if (action === 'PROCESS_BATCH') {
      // 1. ×©×œ×™×¤×ª ××•×¢××“×™× ×©×¦×¨×™×›×™× ×¢×“×›×•×Ÿ
      const candidatesToProcess = await prisma.user.findMany({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: {
            needsAiProfileUpdate: true
          }
        },
        take: batchSize,
        // ×©×œ×™×¤×ª ×”××™×“×¢ ×”×¨×œ×•×•× ×˜×™ ×œ×‘×“×™×§×ª "×”×× ×™×© ×“××˜×”"
        include: {
          profile: {
            select: { id: true, about: true, needsAiProfileUpdate: true }
          },
          questionnaireResponses: {
            select: { id: true } // ××¡×¤×™×§ ×œ×“×¢×ª ×× ×§×™×™× ID ×›×“×™ ×œ×“×¢×ª ×©×™×© ×©××œ×•×Ÿ
          }
        }
      });

      // ×‘×“×™×§×” ×›××” × ×©××¨×• ×¡×”"×› (×œ×¦×•×¨×š ×”-Progress Bar)
      const remainingCount = await prisma.user.count({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: { needsAiProfileUpdate: true }
        }
      });

      // ×× ××™×Ÿ ×™×•×ª×¨ ××•×¢××“×™× ×œ×¢×“×›×•×Ÿ - ×¡×™×™×× ×•
      if (candidatesToProcess.length === 0) {
        return NextResponse.json({ success: true, processed: 0, remaining: 0, completed: true });
      }

      console.log(`[Batch AI] Processing batch of ${candidatesToProcess.length} candidates...`);

      // 2. ×¢×™×‘×•×“ ×‘××§×‘×™×œ
      const results = await Promise.all(
        candidatesToProcess.map(async (user) => {
          try {
            // --- ×©×œ×‘ ×”×¡×™× ×•×Ÿ ×”×—×›× ---
            // × ×‘×“×•×§ ×”×× ×œ×™×•×–×¨ ×™×© ××™×“×¢ ×¨×œ×•×•× ×˜×™ ×œ-AI
            
            const hasAbout = user.profile?.about && user.profile.about.trim().length > 10; // ×œ×¤×—×•×ª 10 ×ª×•×•×™×
            const hasQuestionnaire = user.questionnaireResponses && user.questionnaireResponses.length > 0;

            // ×× ××™×Ÿ ×©×•× ××™×“×¢ - ××“×œ×’×™× (××‘×œ ××›×‘×™× ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×—×–×•×¨ ××œ×™×•)
            if (!hasAbout && !hasQuestionnaire) {
              await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
              });
              return { id: user.id, status: 'skipped_no_data' };
            }

            // --- ×™×© ××™×“×¢? ×××©×™×›×™× ×œ-AI ---

            // 1. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ (×”×¤×•× ×§×¦×™×” ×”×–×• ×›×‘×¨ ×™×•×“×¢×ª ×œ×§×—×ª ×©××œ×•× ×™× ×•-about)
            const narrative = await profileAiService.generateNarrativeProfile(user.id);
            
            // ×”×’× ×” × ×•×¡×¤×ª ×œ××§×¨×” ×©×”× ×¨×˜×™×‘ ×™×¦× ×¨×™×§ ×œ××¨×•×ª ×”×‘×“×™×§×”
            if (!narrative || narrative.length < 20) {
                await prisma.profile.update({
                    where: { userId: user.id },
                    data: { needsAiProfileUpdate: false }
                });
                return { id: user.id, status: 'skipped_empty_narrative' };
            }

            // 2. ×™×¦×™×¨×ª ×”×“×•×— ×‘-AI
            const summary = await aiService.generateProfileSummary(narrative);
            
            if (!summary) throw new Error("AI Summary failed");

            // 3. ×©××™×¨×” ×‘×“××˜×” ×‘×™×™×¡ ×•×›×™×‘×•×™ ×”×“×’×œ
            await prisma.profile.update({
              where: { userId: user.id },
              data: {
                aiProfileSummary: summary as any, // ×”××¨×ª JSON ×œ×¤×•×¨××˜ ×©×œ ×¤×¨×™×–××”
                needsAiProfileUpdate: false,
                // ××•×¤×¦×™×•× ×œ×™: ×¢×“×›×•×Ÿ ××•× ×” ×”×¤×¢××™× ×©×”×•×¤×§ ×“×•×— (×× ×”×•×¡×¤×ª ××ª ×”×©×“×” ××”××•×“×œ)
                // neshamaInsightGeneratedCount: { increment: 1 },
                // neshamaInsightLastGeneratedAt: new Date()
              }
            });

            return { id: user.id, status: 'success' };

          } catch (error) {
            console.error(`[Batch AI] Failed for user ${user.id}:`, error);
            // ×‘××§×¨×” ×©×’×™××” ×˜×›× ×™×ª ×‘-AI, × ×›×‘×” ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×ª×§×•×¢ ××ª ×”×ª×”×œ×™×š ×”×›×œ×œ×™
            await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
            });
            return { id: user.id, status: 'error' };
          }
        })
      );

      const successful = results.filter(r => r.status === 'success').length;
      const skipped = results.filter(r => r.status.startsWith('skipped')).length;

      return NextResponse.json({
        success: true,
        processed: candidatesToProcess.length, // ×¡×š ×”×›×œ ×©×¢×‘×¨×• ×‘×‘××¥'
        successful, // ×›××” × ×•×¦×¨×• ×‘×¤×•×¢×œ
        skipped,    // ×›××” ×“×•×œ×’×• ×›×™ ×”×™×• ×¨×™×§×™×
        remaining: Math.max(0, remainingCount - candidatesToProcess.length),
        completed: (remainingCount - candidatesToProcess.length) <= 0
      });
    }

    return NextResponse.json({ success: false, error: "Invalid action" }, { status: 400 });

  } catch (error) {
    console.error('[Batch Process] Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\process-matching-job
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\process-matching-job\route.ts
--------------------------------------------------------------------------------
Content:
// ===========================================
// src/app/api/ai/process-matching-job/route.ts
// ===========================================
// ğŸ¯ Background Job Processor
// ××¢×‘×“ ×—×™×¤×•×©×™× ×¨×’×™×œ×™× (×œ× ×•×™×¨×˜×•××œ×™×™×) ×‘×¨×§×¢
// 
// ğŸ“ ×”×¢×¨×”: ×—×™×¤×•×©×™× ×•×™×¨×˜×•××œ×™×™× ××¢×•×‘×“×™× ×™×©×™×¨×•×ª ×‘-find-matches-v2
// ×•×œ× ×¢×•×‘×¨×™× ×“×¨×š route ×–×” ×™×•×ª×¨

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { findMatchesForUser } from "@/lib/services/matchingAlgorithmService";
import { findMatchesWithVector } from "@/lib/services/vectorMatchingService";

export const dynamic = 'force-dynamic';
export const maxDuration = 300; // 5 ×“×§×•×ª

// ============================================================================
// POST - ××¢×‘×“ Job ×¨×’×™×œ (×œ× ×•×™×¨×˜×•××œ×™)
// ============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  const startTime = Date.now();
  
  try {
    // ××™××•×ª ×¤× ×™××™ - ×¨×§ ×§×¨×™××•×ª ××”×©×¨×ª ×¢×¦××•
    const internalSecret = req.headers.get('x-internal-secret');
    const expectedSecret = process.env.INTERNAL_API_SECRET || 'default-secret';
    
    if (internalSecret !== expectedSecret) {
      console.warn('[ProcessJob] âš ï¸ Unauthorized access attempt');
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { jobId } = body;

    if (!jobId) {
      return NextResponse.json({ error: "jobId required" }, { status: 400 });
    }

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[ProcessJob] ğŸ“¥ Received job: ${jobId}`);
    console.log(`${'='.repeat(60)}\n`);

    // ×©×œ×™×¤×ª ×¤×¨×˜×™ ×”-Job
    const job = await prisma.matchingJob.findUnique({
      where: { id: jobId }
    });

    if (!job) {
      console.error(`[ProcessJob] âŒ Job not found: ${jobId}`);
      return NextResponse.json({ error: "Job not found" }, { status: 404 });
    }

    // ×‘×“×™×§×” ×× ×–×” ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ - ×œ× ×××•×¨ ×œ×”×’×™×¢ ×œ×›××Ÿ ×™×•×ª×¨
    if (job.method?.includes('virtual')) {
      console.warn(`[ProcessJob] âš ï¸ Virtual search job ${jobId} arrived at wrong endpoint`);
      console.warn(`[ProcessJob] Virtual searches should be processed directly in find-matches-v2`);
      
      // ××¢×“×›× ×™× ×©×’×™××”
      await prisma.matchingJob.update({
        where: { id: jobId },
        data: {
          status: 'failed',
          error: 'Virtual search routed incorrectly - please retry',
          progressMessage: '×©×’×™××ª × ×™×ª×•×‘ - × × ×œ× ×¡×•×ª ×©×•×‘'
        }
      });
      
      return NextResponse.json({ 
        error: "Virtual searches should be processed directly",
        hint: "This is a routing error - virtual searches are now handled in find-matches-v2"
      }, { status: 400 });
    }

    // ×‘×“×™×§×” ×× ×”×’'×•×‘ ×›×‘×¨ ×”×¡×ª×™×™×
    if (job.status === 'completed' || job.status === 'failed') {
      console.log(`[ProcessJob] â­ï¸ Job ${jobId} already finished (status: ${job.status})`);
      return NextResponse.json({ 
        success: true, 
        message: "Job already finished",
        status: job.status 
      });
    }

    // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×œ-processing
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: { 
        status: 'processing',
        progress: 5,
        progressMessage: '××ª×—×™×œ ×¢×™×‘×•×“...'
      }
    });

    // ==========================================================
    // ğŸ”¥ ×¢×™×‘×•×“ ×‘×¨×§×¢ (Fire and Forget)
    // ==========================================================
    
    processJobInBackground(jobId, job.method, job.targetUserId, job.matchmakerId)
      .catch(err => {
        console.error(`[ProcessJob] Background processing failed:`, err);
      });

    // ××—×–×™×¨ ×ª×©×•×‘×” ××™×™×“×™×ª
    return NextResponse.json({ 
      success: true, 
      message: "Processing started",
      jobId 
    });

  } catch (error) {
    console.error('[ProcessJob] Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Failed to start processing" 
    }, { status: 500 });
  }
}

// ============================================================================
// Background Processing Function
// ============================================================================

async function processJobInBackground(
  jobId: string,
  method: string,
  targetUserId: string,
  matchmakerId: string
): Promise<void> {
  const startTime = Date.now();

  console.log(`\n${'='.repeat(60)}`);
  console.log(`[ProcessJob] ğŸš€ Starting background processing`);
  console.log(`[ProcessJob] Job ID: ${jobId}`);
  console.log(`[ProcessJob] Method: ${method}`);
  console.log(`[ProcessJob] Target: ${targetUserId}`);
  console.log(`${'='.repeat(60)}\n`);

  try {
    // ×¤×•× ×§×¦×™×™×ª callback ×œ×¢×“×›×•×Ÿ progress
    const onProgress = async (progress: number, message: string) => {
      await updateJobProgress(jobId, progress, message);
    };

    let result;

    // ==========================================================
    // ğŸ”· Vector Search
    // ==========================================================
    if (method === 'vector') {
      console.log(`[ProcessJob] ğŸ”· Running Vector Search method`);
      await onProgress(10, '××¤×¢×™×œ ×—×™×¤×•×© ×•×§×˜×•×¨×™...');
      
      result = await findMatchesWithVector(targetUserId, matchmakerId, {
        forceRefresh: true,
        autoSave: true,
      });
    } 
    // ==========================================================
    // ğŸ§  Algorithmic Search
    // ==========================================================
    else {
      console.log(`[ProcessJob] ğŸ§  Running Algorithmic method`);
      await onProgress(10, '×˜×•×¢×Ÿ × ×ª×•× ×™ ××•×¢××“ ××˜×¨×”...');
      
      result = await findMatchesForUserWithProgress(
        targetUserId, 
        matchmakerId,
        onProgress
      );
    }

    // ×—×™×©×•×‘ ×–××Ÿ ×¨×™×¦×”
    const duration = Date.now() - startTime;
    const durationMinutes = (duration / 1000 / 60).toFixed(2);

    // ×©××™×¨×ª ×”×ª×•×¦××•×ª
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'completed',
        progress: 100,
        progressMessage: `×”×•×©×œ×! × ××¦××• ${result.matches.length} ×”×ª×××•×ª`,
        result: {
          matches: result.matches,
          meta: result.meta,
          fromCache: result.fromCache
        },
        matchesFound: result.matches.length,
        totalCandidates: result.meta?.totalCandidatesScanned || 0,
        completedAt: new Date()
      }
    });

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[ProcessJob] âœ… Job ${jobId} completed successfully!`);
    console.log(`[ProcessJob] â±ï¸ Duration: ${durationMinutes} minutes`);
    console.log(`[ProcessJob] ğŸ“Š Matches found: ${result.matches.length}`);
    console.log(`${'='.repeat(60)}\n`);

  } catch (error) {
    const duration = Date.now() - startTime;
    
    console.error(`\n${'='.repeat(60)}`);
    console.error(`[ProcessJob] âŒ Job ${jobId} FAILED after ${(duration/1000).toFixed(1)}s`);
    console.error(`[ProcessJob] Error:`, error);
    console.error(`${'='.repeat(60)}\n`);

    // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×œ×›×™×©×œ×•×Ÿ
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        progress: 0,
        progressMessage: '×”×—×™×¤×•×© × ×›×©×œ',
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }).catch(err => {
      console.error(`[ProcessJob] Failed to update job status:`, err);
    });
  }
}

// ============================================================================
// Helper: Update Job Progress
// ============================================================================

async function updateJobProgress(
  jobId: string, 
  progress: number, 
  message: string
): Promise<void> {
  try {
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        progress: Math.min(99, progress), // ××§×¡×™××•× 99 ×¢×“ ×©××¡×™×™×
        progressMessage: message
      }
    });
    console.log(`[ProcessJob] ğŸ“Š Progress: ${progress}% - ${message}`);
  } catch (error) {
    console.error(`[ProcessJob] Failed to update progress:`, error);
  }
}

// ============================================================================
// Wrapper: findMatchesForUser with Progress Updates
// ============================================================================

async function findMatchesForUserWithProgress(
  targetUserId: string,
  matchmakerId: string,
  onProgress: (progress: number, message: string) => Promise<void>
): Promise<{
  matches: any[];
  fromCache: boolean;
  meta: any;
}> {
  await onProgress(15, '×˜×•×¢×Ÿ × ×ª×•× ×™ ××•×¢××“ ××˜×¨×”...');
  await onProgress(20, '××—×¤×© ××•×¢××“×™× ××ª××™××™×...');
  await onProgress(30, '××¡× ×Ÿ ×œ×¤×™ ×§×¨×™×˜×¨×™×•× ×™×...');
  
  // ×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”××§×•×¨×™×ª
  const result = await findMatchesForUser(targetUserId, matchmakerId, {
    forceRefresh: true,
    autoSave: true,
  });

  await onProgress(95, '××¡×™×™× ×•×©×•××¨ ×ª×•×¦××•×ª...');

  return result;
}

// ============================================================================
// GET - Health Check
// ============================================================================

export async function GET(req: NextRequest): Promise<NextResponse> {
  return NextResponse.json({
    status: "healthy",
    service: "process-matching-job",
    version: "4.1",
    note: "Virtual searches are now processed directly in find-matches-v2",
    timestamp: new Date().toISOString()
  });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/test-connection/route.ts

import { NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function GET() {
  console.log('--- [API TEST] Received request at /api/ai/test-connection ---');

  const apiKey = process.env.GOOGLE_API_KEY;

  if (!apiKey) {
    console.error('--- [API TEST] FATAL ERROR: GOOGLE_API_KEY is not set in .env or .env.local!');
    return NextResponse.json(
      { success: false, error: 'Server configuration error: GOOGLE_API_KEY is missing.' },
      { status: 500 }
    );
  }

  // --- ×§×˜×¢ ×”××™××•×ª ×©×”×•×¡×¤× ×• ---
  const keyIdentifier = `Starts with: ${apiKey.substring(0, 5)}... | Ends with: ...${apiKey.substring(apiKey.length - 4)} | Length: ${apiKey.length}`; // <-- ×”×•×¡×£
  console.log(`--- [API TEST] Verifying the loaded API Key: ${keyIdentifier} ---`); // <-- ×”×•×¡×£
  // -----------------------------

  console.log('--- [API TEST] GOOGLE_API_KEY found. Proceeding with API call.');

  try {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' }); 
    const prompt = 'Say "Connection Successful" in one sentence.';

    console.log('--- [API TEST] Sending a simple prompt to Google AI...');
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    console.log('--- [API TEST] SUCCESS! Google AI responded:', text);
    return NextResponse.json({ success: true, message: 'Connection to Google AI is working!', response: text });

  } catch (error) {
    console.error('--- [API TEST] FAILED! The API call to Google threw an error.', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to connect to Google AI. This is likely an API key, permissions, or billing issue.',
        details: JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×©××¨×™×¦×” ××ª ×ª×”×œ×™×š ×”×¢×“×›×•×Ÿ ×‘×¨×§×¢
 * ×•××“×¤×™×¡×” ×œ×•×’ ××¤×•×¨×˜ ×‘×¡×™×•××•.
 * @param userIds - ××¢×¨×š ××–×”×™ ×”××©×ª××©×™× ×œ×¢×“×›×•×Ÿ
 * @param adminId - ××–×”×” ×”××“××™×Ÿ ×©×”×¤×¢×™×œ ××ª ×”×ª×”×œ×™×š
 */
async function runBulkUpdateAndLog(userIds: string[]) {
  const totalUsers = userIds.length;
  // ×”×•×“×¢×ª ×”×ª×—×œ×” ×‘×¨×•×¨×” ×œ×ª×”×œ×™×š ×”×¨×§×¢
 
  try {
    // × ×©×ª××© ×‘-Promise.allSettled ×›×“×™ ×œ×”××ª×™×Ÿ ×œ×¡×™×•× ×›×œ ×”×¢×“×›×•× ×™×, ×’× ×× ×—×œ×§× × ×›×©×œ×™×
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // ××™×¡×•×£ ××–×”×™ ×”××©×ª××©×™× ×©× ×›×©×œ×• (×× ×™×© ×›××œ×”)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // ×”×“×¤×¡×ª ×¡×™×›×•× ××¤×•×¨×˜
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // ×‘××§×¨×” ×©×œ ×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ×”×¨×§×¢ ×¢×¦××•
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // ×›××Ÿ ×”×œ×•×’ ×”××§×•×¨×™ × ×©××¨, ×›×“×™ ×©×ª×¨××” ×©×”-API ×”×•×¤×¢×œ
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\virtual-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\virtual-profile\route.ts
--------------------------------------------------------------------------------
Content:
// ===========================================
// ×§×•×‘×¥ ×—×“×©: src/app/api/ai/virtual-profile/route.ts
// ===========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole, Gender } from "@prisma/client";
import prisma from "@/lib/prisma";
import aiService from "@/lib/services/aiService";

export const dynamic = 'force-dynamic';

// ============================================================================
// POST - ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ ×•×™×¨×˜×•××œ×™ ×—×“×©
// ============================================================================

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™×
    const body = await req.json();
    const { sourceText, gender, religiousLevel, name } = body;

    // 3. ×•×œ×™×“×¦×™×”
    if (!sourceText || typeof sourceText !== 'string' || sourceText.trim().length < 20) {
      return NextResponse.json({ 
        success: false, 
        message: 'sourceText is required and must be at least 20 characters.' 
      }, { status: 400 });
    }

    if (!gender || !['MALE', 'FEMALE'].includes(gender)) {
      return NextResponse.json({ 
        success: false, 
        message: 'gender is required and must be MALE or FEMALE.' 
      }, { status: 400 });
    }

    if (!religiousLevel || typeof religiousLevel !== 'string') {
      return NextResponse.json({ 
        success: false, 
        message: 'religiousLevel is required.' 
      }, { status: 400 });
    }

    console.log(`[Virtual Profile API] Creating profile for matchmaker: ${session.user.email}`);
    console.log(`[Virtual Profile API] Gender: ${gender}, Religious: ${religiousLevel}`);

    // 4. ×™×¦×™×¨×ª ×”×¤×¨×•×¤×™×œ ×‘×××¦×¢×•×ª AI
    const generatedProfile = await aiService.generateVirtualProfile(
      sourceText.trim(),
      gender as 'MALE' | 'FEMALE',
      religiousLevel
    );

    if (!generatedProfile) {
      return NextResponse.json({ 
        success: false, 
        message: 'Failed to generate virtual profile. Please try again.' 
      }, { status: 500 });
    }

    // 5. ×™×¦×™×¨×ª ×•×§×˜×•×¨ ××”×¡×™×›×•× (×œ×—×™×¤×•×© ×•×§×˜×•×¨×™)
    const textForEmbedding = `
      ${generatedProfile.personalitySummary}
      ${generatedProfile.lookingForSummary}
      ×ª×›×•× ×•×ª: ${generatedProfile.keyTraits?.join(', ') || ''}
      ××—×¤×©: ${generatedProfile.idealPartnerTraits?.join(', ') || ''}
    `;
    
    const vector = await aiService.generateTextEmbedding(textForEmbedding);

    // 6. ×©××™×¨×” ×‘-DB
    const virtualProfile = await prisma.virtualProfile.create({
      data: {
        matchmakerId,
        name: name?.trim() || null,
        sourceText: sourceText.trim(),
        gender: gender as Gender,
        religiousLevel,
        generatedProfile: generatedProfile as any,
        // ×”×•×§×˜×•×¨ ×™×™×©××¨ ×‘× ×¤×¨×“ ×× × ×“×¨×© (pgvector)
      },
    });

    // 6.1 ×©××™×¨×ª ×”×•×§×˜×•×¨ (×× × ×•×¦×¨ ×‘×”×¦×œ×—×”)
    if (vector && vector.length === 768) {
      try {
        const vectorSqlString = `[${vector.join(',')}]`;
        await prisma.$executeRaw`
          UPDATE "VirtualProfile"
          SET vector = ${vectorSqlString}::vector
          WHERE id = ${virtualProfile.id}
        `;
        console.log(`[Virtual Profile API] Vector saved successfully`);
      } catch (vectorError) {
        console.error(`[Virtual Profile API] Failed to save vector:`, vectorError);
        // ×œ× × ×›×©×™×œ ××ª ×›×œ ×”×‘×§×©×” ×‘×’×œ×œ ×”×•×§×˜×•×¨
      }
    }

    console.log(`[Virtual Profile API] âœ… Created profile: ${virtualProfile.id}`);

    // 7. ×”×—×–×¨×ª ×”×ª×•×¦××”
    return NextResponse.json({
      success: true,
      virtualProfile: {
        id: virtualProfile.id,
        name: virtualProfile.name,
        gender: virtualProfile.gender,
        religiousLevel: virtualProfile.religiousLevel,
        generatedProfile,
        createdAt: virtualProfile.createdAt,
      }
    });

  } catch (error) {
    console.error('[Virtual Profile API] POST Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error',
      details: errorMessage 
    }, { status: 500 });
  }
}

// ============================================================================
// GET - ×©×œ×™×¤×ª ×¤×¨×•×¤×™×œ×™× ×•×™×¨×˜×•××œ×™×™× ×©××•×¨×™×
// ============================================================================

export async function GET(req: NextRequest) {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;
    const { searchParams } = new URL(req.url);
    
    // ×¤×¨××˜×¨×™× ××•×¤×¦×™×•× ×œ×™×™×
    const starred = searchParams.get('starred') === 'true';
    const profileId = searchParams.get('id');

    // 2. ×©×œ×™×¤×ª ×¤×¨×•×¤×™×œ ×‘×•×“×“
    if (profileId) {
      const profile = await prisma.virtualProfile.findFirst({
        where: {
          id: profileId,
          matchmakerId, // ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×©×™×™×š ×œ×©×“×›×Ÿ ×”×–×”
        },
      });

      if (!profile) {
        return NextResponse.json({ 
          success: false, 
          message: 'Profile not found' 
        }, { status: 404 });
      }

      return NextResponse.json({
        success: true,
        virtualProfile: profile,
      });
    }

    // 3. ×©×œ×™×¤×ª ×¨×©×™××ª ×¤×¨×•×¤×™×œ×™×
    const whereClause: any = { matchmakerId };
    if (starred) {
      whereClause.isStarred = true;
    }

    const profiles = await prisma.virtualProfile.findMany({
      where: whereClause,
      orderBy: [
        { isStarred: 'desc' },
        { lastUsedAt: 'desc' },
        { createdAt: 'desc' },
      ],
      select: {
        id: true,
        name: true,
        gender: true,
        religiousLevel: true,
        generatedProfile: true,
        editedSummary: true,
        wasEdited: true,
        isStarred: true,
        lastUsedAt: true,
        usageCount: true,
        createdAt: true,
      },
      take: 50, // ××§×¡×™××•× 50 ×¤×¨×•×¤×™×œ×™×
    });

    return NextResponse.json({
      success: true,
      profiles,
      count: profiles.length,
    });

  } catch (error) {
    console.error('[Virtual Profile API] GET Error:', error);
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error' 
    }, { status: 500 });
  }
}

// ============================================================================
// PATCH - ×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ (×©×, ×›×•×›×‘, ×¡×™×›×•× ×¢×¨×•×š)
// ============================================================================

export async function PATCH(req: NextRequest) {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™×
    const body = await req.json();
    const { id, name, isStarred, editedSummary, markAsUsed } = body;

    if (!id || typeof id !== 'string') {
      return NextResponse.json({ 
        success: false, 
        message: 'id is required' 
      }, { status: 400 });
    }

    // 3. ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×©×™×™×š ×œ×©×“×›×Ÿ
    const existingProfile = await prisma.virtualProfile.findFirst({
      where: { id, matchmakerId },
    });

    if (!existingProfile) {
      return NextResponse.json({ 
        success: false, 
        message: 'Profile not found or access denied' 
      }, { status: 404 });
    }

    // 4. ×‘× ×™×™×ª ××•×‘×™×™×§×˜ ×”×¢×“×›×•×Ÿ
    const updateData: any = {};

    if (name !== undefined) {
      updateData.name = name?.trim() || null;
    }

    if (isStarred !== undefined) {
      updateData.isStarred = Boolean(isStarred);
    }

    if (editedSummary !== undefined) {
      updateData.editedSummary = editedSummary?.trim() || null;
      updateData.wasEdited = Boolean(editedSummary?.trim());
      
      // ×× ×”×¡×™×›×•× ×¢×•×“×›×Ÿ, × ×™×¦×•×¨ ×•×§×˜×•×¨ ×—×“×©
      if (editedSummary?.trim()) {
        const newVector = await aiService.generateTextEmbedding(editedSummary.trim());
        if (newVector && newVector.length === 768) {
          try {
            const vectorSqlString = `[${newVector.join(',')}]`;
            await prisma.$executeRaw`
              UPDATE "VirtualProfile"
              SET vector = ${vectorSqlString}::vector
              WHERE id = ${id}
            `;
          } catch (vectorError) {
            console.error(`[Virtual Profile API] Failed to update vector:`, vectorError);
          }
        }
      }
    }

    if (markAsUsed) {
      updateData.lastUsedAt = new Date();
      updateData.usageCount = { increment: 1 };
    }

    // 5. ×‘×™×¦×•×¢ ×”×¢×“×›×•×Ÿ
    const updatedProfile = await prisma.virtualProfile.update({
      where: { id },
      data: updateData,
    });

    console.log(`[Virtual Profile API] âœ… Updated profile: ${id}`);

    return NextResponse.json({
      success: true,
      virtualProfile: updatedProfile,
    });

  } catch (error) {
    console.error('[Virtual Profile API] PATCH Error:', error);
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error' 
    }, { status: 500 });
  }
}

// ============================================================================
// DELETE - ××—×™×§×ª ×¤×¨×•×¤×™×œ
// ============================================================================

export async function DELETE(req: NextRequest) {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;
    const { searchParams } = new URL(req.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json({ 
        success: false, 
        message: 'id is required' 
      }, { status: 400 });
    }

    // 2. ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×©×™×™×š ×œ×©×“×›×Ÿ ×•××—×™×§×”
    const deletedProfile = await prisma.virtualProfile.deleteMany({
      where: { 
        id, 
        matchmakerId 
      },
    });

    if (deletedProfile.count === 0) {
      return NextResponse.json({ 
        success: false, 
        message: 'Profile not found or access denied' 
      }, { status: 404 });
    }

    console.log(`[Virtual Profile API] âœ… Deleted profile: ${id}`);

    return NextResponse.json({
      success: true,
      message: 'Profile deleted successfully',
    });

  } catch (error) {
    console.error('[Virtual Profile API] DELETE Error:', error);
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error' 
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

