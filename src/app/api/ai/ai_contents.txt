################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
# Generated on: 2026-01-25 15:15:37
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

// -----------------------------------------------------------------------------
// ×”×’×“×¨×•×ª ×ª×¦×•×¨×” ×œ-Next.js ×›×“×™ ×œ×× ×•×¢ Timeout ×•-Caching
// -----------------------------------------------------------------------------

// ×××¤×©×¨ ×œ×¤×•× ×§×¦×™×” ×œ×¨×•×¥ ×¢×“ 300 ×©× ×™×•×ª (×‘××§×•× ×‘×¨×™×¨×ª ×”××—×“×œ ×©×œ 10-15 ×©× ×™×•×ª).
// ×–×” ×§×¨×™×˜×™ ×œ×§×¨×™××•×ª AI ×©×œ×•×§×—×•×ª ×–××Ÿ.
export const maxDuration = 300; 

// ××•×•×“× ×©×”× ×ª×™×‘ ×ª××™×“ ×“×™× ××™ ×•×œ× × ×©××¨ ×‘-Cache ×©×œ ×”×©×¨×ª
export const dynamic = 'force-dynamic';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×”××©×ª××© ×‘×××¦×¢×•×ª AI.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£,
 * ×©×•×œ×—×ª ××•×ª×• ×œ× ×™×ª×•×— AI, ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
  // ×‘×“×™×§×ª Rate Limit
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ××©×ª××©
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // ×©×œ×‘ 2: ×•×“× ×©×”××©×ª××© ×•×”×¤×¨×•×¤×™×œ ×§×™×™××™× ×œ×¤× ×™ ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] ×œ× × ××¦× ×¤×¨×•×¤×™×œ ×¢×‘×•×¨ ××©×ª××©: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    // ×©×™××•×© ×—×•×–×¨ ×‘×œ×•×’×™×§×” ×”×§×™×™××ª ×•×”××¦×•×™× ×ª ×-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×”×¦×¢×ª ×©×™×“×•×š ×¢×‘×•×¨ ×”××©×ª××© ×”××—×•×‘×¨.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×××—×–×¨×ª ××ª ×”×¤×¨×•×¤×™×œ ×©×œ×• ×•××ª ×”×¤×¨×•×¤×™×œ ×©×œ ×”××©×ª××© ×”××•×¦×¢,
 * ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™×”×, ×©×•×œ×—×ª ××•×ª× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©,
 * ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×§×‘×œ×ª ×”××©×ª××© ×”× ×•×›×—×™
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. ×§×‘×œ×ª ID ×©×œ ×”××©×ª××© ×”××•×¦×¢ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3. ×•×“× ×©×©× ×™ ×”×¤×¨×•×¤×™×œ×™× ×§×™×™××™×
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] ××—×“ ×”×¤×¨×•×¤×™×œ×™× ××• ×©× ×™×”× ×œ× × ××¦××•. × ××¦××•: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™ ×”××©×ª××©×™× ×‘××§×‘×™×œ
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ××—×“ ×”××©×ª××©×™×.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘×™× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××ª × ×™×ª×•×— ×”×¦×¢×”.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\batch-scan-all
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\batch-scan-all\route.ts
--------------------------------------------------------------------------------
Content:
// =============================================================================
// ğŸ“ src/app/api/ai/batch-scan-all/route.ts
// =============================================================================
// ğŸ¯ Batch Scan All - ×¡×¨×™×§×” ×œ×™×œ×™×ª ×—×›××” V2.1
// 
// ğŸ†• ×©×™×¤×•×¨×™× ×‘×’×¨×¡×” ×–×•:
// 1. âœ… ×¡×¨×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª ×××™×ª×™×ª - ×¡×•×¨×§ ×¨×§ ×–×•×’×•×ª ×©×¦×¨×™×š!
// 2. âœ… Progress ×˜×•×‘ ×™×•×ª×¨ - ×›×•×œ×œ ××—×•×– ××“×•×™×§ ×•××•××“×Ÿ ×–××Ÿ
// 3. âœ… ×œ×•×’×™× ××¤×•×¨×˜×™× ×™×•×ª×¨
// 4. âœ… ×¡×˜×˜×™×¡×˜×™×§×•×ª ××¤×•×¨×˜×•×ª ×œ××¢×§×‘
// =============================================================================

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { Gender, AvailabilityStatus } from "@prisma/client";
import { GoogleGenerativeAI } from '@google/generative-ai';
import { 
  getCompatibleReligiousLevels,
  calculateAge,
  calculateAgeScore,
  createBackgroundProfile,
  calculateBackgroundMatch,
  filterBlockedFemales,
  saveScannedPairsBatch,
  getActiveUsersWhereClause,
  type ScannedPairResult,
} from "@/lib/services/matchingAlgorithmService";
import profileAiService from "@/lib/services/profileAiService";

export const dynamic = 'force-dynamic';
export const maxDuration = 300; // 5 ×“×§×•×ª

// =============================================================================
// CONSTANTS
// =============================================================================

const MIN_SCORE_THRESHOLD = 70;
const BATCH_SIZE = 15; // ×›××” ×‘×—×•×¨×•×ª ×œ×©×œ×•×— ×œ-AI ×‘×›×œ ×§×¨×™××”
const PROGRESS_UPDATE_INTERVAL = 5; // ×¢×“×›×•×Ÿ progress ×›×œ X ×’×‘×¨×™×

// =============================================================================
// TYPES
// =============================================================================

interface ScanStats {
  totalMales: number;
  malesProcessed: number;
  totalPairsToScan: number;
  pairsScanned: number;
  pairsSkippedByHistory: number;
  pairsSkippedByNoChange: number;
  pairsSkippedByAgeGap: number;
  pairsSkippedByReligion: number;
  matchesFound: number;
  newMatches: number;
  updatedMatches: number;
  aiCallsCount: number;
  startTime: number;
}

// =============================================================================
// POST - ×”×ª×—×œ×ª ×¡×¨×™×§×” ×œ×™×œ×™×ª
// =============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  try {
    const body = await req.json().catch(() => ({}));
    const { 
      method = 'algorithmic',
      forceRefresh = false,
    } = body;

    console.log(`\n${'='.repeat(70)}`);
    console.log(`[BatchScan] ğŸŒ™ Starting Nightly Differential Scan V2.1`);
    console.log(`[BatchScan] Method: ${method}`);
    console.log(`[BatchScan] Force Refresh: ${forceRefresh}`);
    console.log(`${'='.repeat(70)}\n`);

    // ×‘×“×™×§×” ×× ×™×© ×¡×¨×™×§×” ×¨×¦×” ×›×‘×¨
    const runningScan = await prisma.nightlyScanLog.findFirst({
      where: { status: 'running' },
      orderBy: { startedAt: 'desc' }
    });

    if (runningScan) {
      // ×‘×“×™×§×” ×× ×”×¡×¨×™×§×” ×ª×§×•×¢×” (×™×•×ª×¨ ××©×¢×”)
      const runningTime = Date.now() - runningScan.startedAt.getTime();
      if (runningTime > 60 * 60 * 1000) {
        console.log(`[BatchScan] âš ï¸ Previous scan seems stuck, marking as failed`);
        await prisma.nightlyScanLog.update({
          where: { id: runningScan.id },
          data: {
            status: 'failed',
            error: 'Scan timed out after 1 hour',
            completedAt: new Date(),
          }
        });
      } else {
        console.log(`[BatchScan] âš ï¸ Scan already running: ${runningScan.id}`);
        return NextResponse.json({
          success: false,
          status: 'already_running',
          scanId: runningScan.id,
          message: '×¡×¨×™×§×” ×›×‘×¨ ×¨×¦×” ×›×¨×’×¢',
          runningFor: Math.round(runningTime / 1000 / 60) + ' minutes'
        });
      }
    }

    // ×™×¦×™×¨×ª ×¨×©×•××ª ×œ×•×’ ×—×“×©×”
    const scanLog = await prisma.nightlyScanLog.create({
      data: {
        status: 'running',
        totalCandidates: 0,
        candidatesScanned: 0,
        matchesFound: 0,
        newMatches: 0,
        updatedMatches: 0,
        startedAt: new Date(),
        method,
        minScoreThreshold: MIN_SCORE_THRESHOLD,
      }
    });

    console.log(`[BatchScan] Created scan log: ${scanLog.id}`);

    // ×”×¤×¢×œ×ª ×”×¡×¨×™×§×” ×‘×¨×§×¢
    runOptimizedDifferentialScan(scanLog.id, method, forceRefresh)
      .catch(err => {
        console.error(`[BatchScan] Background scan failed:`, err);
      });

    return NextResponse.json({
      success: true,
      scanId: scanLog.id,
      message: '×”×¡×¨×™×§×” ×”×—×œ×”'
    });

  } catch (error) {
    console.error('[BatchScan] Error starting scan:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to start scan'
    }, { status: 500 });
  }
}

// =============================================================================
// GET - ×‘×“×™×§×ª ×¡×˜×˜×•×¡ ×¡×¨×™×§×” (××©×•×¤×¨!)
// =============================================================================

export async function GET(req: NextRequest): Promise<NextResponse> {
  try {
    const { searchParams } = new URL(req.url);
    const scanId = searchParams.get('scanId');

    if (scanId) {
      const scan = await prisma.nightlyScanLog.findUnique({
        where: { id: scanId }
      });

      if (!scan) {
        return NextResponse.json({ 
          success: false, 
          error: 'Scan not found' 
        }, { status: 404 });
      }

      // ×—×™×©×•×‘ ××—×•×– ×”×ª×§×“××•×ª ×•×–××Ÿ ××©×•×¢×¨
      const progress = scan.totalCandidates > 0 
        ? Math.round((scan.candidatesScanned / scan.totalCandidates) * 100)
        : 0;
      
      let estimatedRemainingMinutes: number | null = null;
      if (scan.status === 'running' && scan.candidatesScanned > 0) {
        const elapsedMs = Date.now() - scan.startedAt.getTime();
        const msPerCandidate = elapsedMs / scan.candidatesScanned;
        const remainingCandidates = scan.totalCandidates - scan.candidatesScanned;
        estimatedRemainingMinutes = Math.round(msPerCandidate * remainingCandidates / 1000 / 60);
      }

      return NextResponse.json({
        success: true,
        scan: {
          id: scan.id,
          status: scan.status,
          progress, // ğŸ†• ××—×•×– ×”×ª×§×“××•×ª
          totalCandidates: scan.totalCandidates,
          candidatesScanned: scan.candidatesScanned,
          matchesFound: scan.matchesFound,
          newMatches: scan.newMatches,
          updatedMatches: scan.updatedMatches,
          durationMs: scan.durationMs,
          estimatedRemainingMinutes, // ğŸ†• ××•××“×Ÿ ×–××Ÿ ×©× ×•×ª×¨
          error: scan.error,
          startedAt: scan.startedAt,
          completedAt: scan.completedAt,
        }
      });
    }

    // ×”×—×–×¨×ª ×”×¡×¨×™×§×” ×”××—×¨×•× ×”
    const lastScan = await prisma.nightlyScanLog.findFirst({
      orderBy: { startedAt: 'desc' }
    });

    return NextResponse.json({
      success: true,
      lastScan: lastScan ? {
        id: lastScan.id,
        status: lastScan.status,
        matchesFound: lastScan.matchesFound,
        durationMs: lastScan.durationMs,
        startedAt: lastScan.startedAt,
        completedAt: lastScan.completedAt,
      } : null
    });

  } catch (error) {
    console.error('[BatchScan] Error getting status:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to get scan status'
    }, { status: 500 });
  }
}

// =============================================================================
// ğŸ†• Optimized Differential Scan - ×¡×¨×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª ×××™×ª×™×ª!
// =============================================================================

async function runOptimizedDifferentialScan(
  scanLogId: string,
  method: string,
  forceRefresh: boolean
): Promise<void> {
  const stats: ScanStats = {
    totalMales: 0,
    malesProcessed: 0,
    totalPairsToScan: 0,
    pairsScanned: 0,
    pairsSkippedByHistory: 0,
    pairsSkippedByNoChange: 0,
    pairsSkippedByAgeGap: 0,
    pairsSkippedByReligion: 0,
    matchesFound: 0,
    newMatches: 0,
    updatedMatches: 0,
    aiCallsCount: 0,
    startTime: Date.now(),
  };

  const scannedPairsToSave: ScannedPairResult[] = [];

  try {
    console.log(`\n[BatchScan] ğŸš€ Starting optimized differential scan...`);

    // ==========================================================================
    // ×©×œ×‘ 1: ×©×œ×™×¤×ª ×›×œ ×”×’×‘×¨×™× ×•×”×‘×—×•×¨×•×ª ×”×¤×¢×™×œ×™×
    // ==========================================================================
    
    const males = await fetchActiveMales();
    const allFemales = await fetchActiveFemales();
    
    stats.totalMales = males.length;
    
    console.log(`[BatchScan] Found ${males.length} active males`);
    console.log(`[BatchScan] Found ${allFemales.length} active females`);
    console.log(`[BatchScan] Maximum possible pairs: ${males.length * allFemales.length}`);

    // ==========================================================================
    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×›×œ ×”-ScannedPairs ×”×§×™×™××™× ×‘×‘×ª ××—×ª (×œ×—×™×¡×›×•×Ÿ ×‘×©××™×œ×ª×•×ª)
    // ==========================================================================

    const existingScannedPairs = await prisma.scannedPair.findMany({
      select: {
        maleUserId: true,
        femaleUserId: true,
        maleProfileUpdatedAt: true,
        femaleProfileUpdatedAt: true,
        passedThreshold: true,
        lastScannedAt: true,
      }
    });

    // ×™×¦×™×¨×ª ××¤×” ×œ×’×™×©×” ××”×™×¨×”
    const scannedPairsMap = new Map<string, typeof existingScannedPairs[0]>();
    for (const pair of existingScannedPairs) {
      scannedPairsMap.set(`${pair.maleUserId}_${pair.femaleUserId}`, pair);
    }

    console.log(`[BatchScan] Loaded ${existingScannedPairs.length} existing scanned pairs`);

    // ==========================================================================
    // ×©×œ×‘ 3: ×©×œ×™×¤×ª ×›×œ ×”×”×™×¡×˜×•×¨×™×” ×”×—×•×¡××ª ×‘×‘×ª ××—×ª
    // ==========================================================================

    const maleIds = males.map(m => m.id);
    const femaleIds = allFemales.map(f => f.id);

    const { blockedPairsSet } = await fetchAllBlockingHistory(maleIds, femaleIds);
    
    console.log(`[BatchScan] Found ${blockedPairsSet.size} blocked pairs from history`);

    // ×¢×“×›×•×Ÿ ×”×œ×•×’
    await prisma.nightlyScanLog.update({
      where: { id: scanLogId },
      data: { totalCandidates: males.length }
    });

    // ==========================================================================
    // ×©×œ×‘ 4: ×¡×¨×™×§×” ×—×›××” ×œ×›×œ ×’×‘×¨
    // ==========================================================================

    for (let maleIndex = 0; maleIndex < males.length; maleIndex++) {
      const male = males[maleIndex];
      
      if (!male.profile?.birthDate) {
        console.log(`[BatchScan] Skipping male ${male.firstName} - no birthDate`);
        continue;
      }

      const maleAge = calculateAge(male.profile.birthDate);
      const maleReligiousLevel = male.profile.religiousLevel;
      const maleProfileUpdatedAt = male.profile.updatedAt;
      const compatibleReligious = getCompatibleReligiousLevels(maleReligiousLevel);

      // ××¦×™××ª ×‘×—×•×¨×•×ª ×©×¦×¨×™×›×•×ª ×¡×¨×™×§×”
      const femalesToScan: typeof allFemales = [];

      for (const female of allFemales) {
        if (!female.profile) continue;

        // 1. ×‘×“×™×§×ª ×”×™×¡×˜×•×¨×™×” ×—×•×¡××ª
        const pairKey = `${male.id}_${female.id}`;
        if (blockedPairsSet.has(pairKey)) {
          stats.pairsSkippedByHistory++;
          continue;
        }

        // 2. ×‘×“×™×§×ª ×¨××” ×“×ª×™×ª
        if (female.profile.religiousLevel && 
            !compatibleReligious.includes(female.profile.religiousLevel)) {
          stats.pairsSkippedByReligion++;
          continue;
        }

        // 3. ×‘×“×™×§×ª ×’×™×œ
        if (female.profile.birthDate) {
          const femaleAge = calculateAge(female.profile.birthDate);
          const ageScore = calculateAgeScore(maleAge, femaleAge);
          if (!ageScore.eligible) {
            stats.pairsSkippedByAgeGap++;
            continue;
          }
        }

        // 4. ×‘×“×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª - ×”×× ×¦×¨×™×š ×œ×¡×¨×•×§ ××—×“×©?
        if (!forceRefresh) {
          const existingPair = scannedPairsMap.get(pairKey);
          if (existingPair) {
            const maleUpdated = maleProfileUpdatedAt > (existingPair.maleProfileUpdatedAt || new Date(0));
            const femaleUpdated = female.profile.updatedAt > (existingPair.femaleProfileUpdatedAt || new Date(0));
            
            if (!maleUpdated && !femaleUpdated) {
              stats.pairsSkippedByNoChange++;
              continue;
            }
          }
        }

        // ×¢×‘×¨×” ××ª ×›×œ ×”×‘×“×™×§×•×ª - ×¦×¨×™×š ×œ×¡×¨×•×§!
        femalesToScan.push(female);
      }

      stats.totalPairsToScan += femalesToScan.length;

      // ×œ×•×’ ×”×ª×§×“××•×ª
      if ((maleIndex + 1) % 10 === 0 || maleIndex === 0) {
        console.log(`\n[BatchScan] ğŸ“Š Progress Report:`);
        console.log(`  Males: ${maleIndex + 1}/${males.length} (${Math.round((maleIndex + 1) / males.length * 100)}%)`);
        console.log(`  Current: ${male.firstName} ${male.lastName} -> ${femalesToScan.length} females to scan`);
        console.log(`  Stats: skipped ${stats.pairsSkippedByHistory} history, ${stats.pairsSkippedByNoChange} unchanged, ${stats.pairsSkippedByAgeGap} age, ${stats.pairsSkippedByReligion} religion`);
        console.log(`  Matches found so far: ${stats.matchesFound}`);
      }

      if (femalesToScan.length === 0) {
        stats.malesProcessed++;
        continue;
      }

      // ==========================================================================
      // ×©×œ×‘ 4.1: ×¡×¨×™×§×ª AI ×¨×§ ×œ×–×•×’×•×ª ×©×¦×¨×™×š!
      // ==========================================================================

      try {
        // ×”×›× ×ª ×¤×¨×•×¤×™×œ ×”×’×‘×¨
        const maleNarrativeProfile = await buildNarrativeProfile(male);
        const maleBackgroundProfile = createBackgroundProfile(
          male.profile.nativeLanguage,
          male.profile.additionalLanguages || [],
          male.profile.aliyaCountry,
          male.profile.aliyaYear,
          male.profile.origin,
          male.profile.about,
          male.profile.matchingNotes
        );

        // ×¡×¨×™×§×ª ×‘×—×•×¨×•×ª ×‘-batches
        for (let i = 0; i < femalesToScan.length; i += BATCH_SIZE) {
          const batch = femalesToScan.slice(i, i + BATCH_SIZE);
          
          const batchResults = await scanBatchWithAI(
            male,
            maleNarrativeProfile,
            maleBackgroundProfile,
            maleAge,
            batch
          );

          stats.aiCallsCount++;
          stats.pairsScanned += batch.length;

          // ×¢×™×‘×•×“ ×ª×•×¦××•×ª
          for (const result of batchResults) {
            const passedThreshold = result.score >= MIN_SCORE_THRESHOLD;

            // ×©××™×¨×” ×‘-ScannedPair
            scannedPairsToSave.push({
              maleUserId: male.id,
              femaleUserId: result.femaleId,
              aiScore: result.score,
              passedThreshold,
              rejectionReason: passedThreshold ? null : 'low_ai_score',
              maleProfileUpdatedAt,
              femaleProfileUpdatedAt: result.femaleProfileUpdatedAt,
            });

            if (passedThreshold) {
              stats.matchesFound++;

              const saved = await saveToPotentialMatch(
                male.id,
                result.femaleId,
                result
              );

              if (saved === 'new') stats.newMatches++;
              if (saved === 'updated') stats.updatedMatches++;
            }
          }
        }

      } catch (error) {
        console.error(`[BatchScan] Error scanning male ${male.id}:`, error);
      }

      stats.malesProcessed++;

      // ×¢×“×›×•×Ÿ progress ×‘DB
      if ((maleIndex + 1) % PROGRESS_UPDATE_INTERVAL === 0) {
        await prisma.nightlyScanLog.update({
          where: { id: scanLogId },
          data: {
            candidatesScanned: stats.malesProcessed,
            matchesFound: stats.matchesFound,
            newMatches: stats.newMatches,
            updatedMatches: stats.updatedMatches,
          }
        });
      }
    }

    // ==========================================================================
    // ×©×œ×‘ 5: ×©××™×¨×ª ×›×œ ×”-ScannedPairs
    // ==========================================================================

    console.log(`\n[BatchScan] ğŸ’¾ Saving ${scannedPairsToSave.length} scanned pairs...`);
    await saveScannedPairsBatch(scannedPairsToSave);

    // ==========================================================================
    // ×©×œ×‘ 6: ×¡×™×•× ×•×¡×™×›×•×
    // ==========================================================================

    const duration = Date.now() - stats.startTime;

    await prisma.nightlyScanLog.update({
      where: { id: scanLogId },
      data: {
        status: 'completed',
        candidatesScanned: stats.malesProcessed,
        matchesFound: stats.matchesFound,
        newMatches: stats.newMatches,
        updatedMatches: stats.updatedMatches,
        durationMs: duration,
        completedAt: new Date(),
      }
    });

    console.log(`\n${'='.repeat(70)}`);
    console.log(`[BatchScan] âœ… Scan completed!`);
    console.log(`${'='.repeat(70)}`);
    console.log(`\nğŸ“Š Final Statistics:`);
    console.log(`  Duration: ${(duration / 1000 / 60).toFixed(2)} minutes`);
    console.log(`  Males scanned: ${stats.malesProcessed}/${stats.totalMales}`);
    console.log(`  \n  Pairs breakdown:`);
    console.log(`    - Total potential: ${stats.totalMales * allFemales.length}`);
    console.log(`    - Skipped (history): ${stats.pairsSkippedByHistory}`);
    console.log(`    - Skipped (unchanged): ${stats.pairsSkippedByNoChange}`);
    console.log(`    - Skipped (age gap): ${stats.pairsSkippedByAgeGap}`);
    console.log(`    - Skipped (religion): ${stats.pairsSkippedByReligion}`);
    console.log(`    - Actually scanned: ${stats.pairsScanned}`);
    console.log(`  \n  Results:`);
    console.log(`    - AI calls made: ${stats.aiCallsCount}`);
    console.log(`    - Matches found (â‰¥70): ${stats.matchesFound}`);
    console.log(`    - New matches: ${stats.newMatches}`);
    console.log(`    - Updated matches: ${stats.updatedMatches}`);
    console.log(`\n${'='.repeat(70)}\n`);

  } catch (error) {
    console.error('[BatchScan] âŒ Scan failed:', error);

    await prisma.nightlyScanLog.update({
      where: { id: scanLogId },
      data: {
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        durationMs: Date.now() - stats.startTime,
        completedAt: new Date(),
      }
    });
  }
}

// =============================================================================
// Helper Functions
// =============================================================================

async function fetchActiveMales() {
  return prisma.user.findMany({
    where: {
      ...getActiveUsersWhereClause(),
      profile: {
        gender: 'MALE',
        availabilityStatus: AvailabilityStatus.AVAILABLE,
        isProfileVisible: true,
        OR: [
          { about: { not: null } },
          { manualEntryText: { not: null } },
        ]
      }
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      profile: {
        select: {
          birthDate: true,
          religiousLevel: true,
          updatedAt: true,
          nativeLanguage: true,
          additionalLanguages: true,
          aliyaCountry: true,
          aliyaYear: true,
          origin: true,
          about: true,
          matchingNotes: true,
          city: true,
          occupation: true,
          aiProfileSummary: true,
        }
      }
    }
  });
}

async function fetchActiveFemales() {
  return prisma.user.findMany({
    where: {
      ...getActiveUsersWhereClause(),
      profile: {
        gender: 'FEMALE',
        availabilityStatus: AvailabilityStatus.AVAILABLE,
        isProfileVisible: true,
        OR: [
          { about: { not: null } },
          { manualEntryText: { not: null } },
        ]
      }
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      profile: {
        select: {
          birthDate: true,
          religiousLevel: true,
          updatedAt: true,
          nativeLanguage: true,
          additionalLanguages: true,
          aliyaCountry: true,
          aliyaYear: true,
          origin: true,
          about: true,
          matchingNotes: true,
          city: true,
          occupation: true,
          aiProfileSummary: true,
        }
      }
    }
  });
}

async function fetchAllBlockingHistory(
  maleIds: string[],
  femaleIds: string[]
): Promise<{ blockedPairsSet: Set<string> }> {
  const blockedPairsSet = new Set<string>();

  // 1. MatchSuggestions ×©× ×›×©×œ×•
  const blockingSuggestions = await prisma.matchSuggestion.findMany({
    where: {
      status: { 
        in: [
          'ENDED_AFTER_FIRST_DATE',
          'MATCH_DECLINED',
          'FIRST_PARTY_DECLINED',
          'SECOND_PARTY_DECLINED',
          'CLOSED',
          'CANCELLED',
          'EXPIRED'
        ] 
      },
      OR: [
        { firstPartyId: { in: maleIds }, secondPartyId: { in: femaleIds } },
        { firstPartyId: { in: femaleIds }, secondPartyId: { in: maleIds } },
      ]
    },
    select: {
      firstPartyId: true,
      secondPartyId: true,
    }
  });

  for (const s of blockingSuggestions) {
    // ××•×¡×™×£ ××ª ×©× ×™ ×”×›×™×•×•× ×™×
    blockedPairsSet.add(`${s.firstPartyId}_${s.secondPartyId}`);
    blockedPairsSet.add(`${s.secondPartyId}_${s.firstPartyId}`);
  }

  // 2. PotentialMatches ×©× ×“×—×•
  const dismissedMatches = await prisma.potentialMatch.findMany({
    where: {
      maleUserId: { in: maleIds },
      femaleUserId: { in: femaleIds },
      status: 'DISMISSED'
    },
    select: {
      maleUserId: true,
      femaleUserId: true,
    }
  });

  for (const m of dismissedMatches) {
    blockedPairsSet.add(`${m.maleUserId}_${m.femaleUserId}`);
  }

  return { blockedPairsSet };
}

async function buildNarrativeProfile(user: any): Promise<string> {
  const p = user.profile;
  if (!p) return '';

  // ×× ×™×© ×¡×™×›×•× AI - × ×©×ª××© ×‘×•
  if (p.aiProfileSummary?.personalitySummary) {
    return `
×©×: ${user.firstName} ${user.lastName}
×’×™×œ: ${p.birthDate ? calculateAge(p.birthDate) : '×œ× ×™×“×•×¢'}
×¢×™×¨: ${p.city || '×œ× ×¦×•×™×Ÿ'}
×¢×™×¡×•×§: ${p.occupation || '×œ× ×¦×•×™×Ÿ'}
×¨××” ×“×ª×™×ª: ${p.religiousLevel || '×œ× ×¦×•×™×Ÿ'}

=== ×¡×™×›×•× ××™×©×™×•×ª ===
${p.aiProfileSummary.personalitySummary}

=== ××” ××—×¤×©/×ª ===
${p.aiProfileSummary.lookingForSummary || '×œ× ×¦×•×™×Ÿ'}

=== ×¢×œ ×¢×¦××™ ===
${p.about || p.manualEntryText || '×œ× ×¦×•×™×Ÿ'}
    `.trim();
  }

  // ××—×¨×ª - × ×‘× ×” ××”× ×ª×•× ×™× ×”×§×™×™××™×
  return `
×©×: ${user.firstName} ${user.lastName}
×’×™×œ: ${p.birthDate ? calculateAge(p.birthDate) : '×œ× ×™×“×•×¢'}
×¢×™×¨: ${p.city || '×œ× ×¦×•×™×Ÿ'}
×¢×™×¡×•×§: ${p.occupation || '×œ× ×¦×•×™×Ÿ'}
×¨××” ×“×ª×™×ª: ${p.religiousLevel || '×œ× ×¦×•×™×Ÿ'}

=== ×¢×œ ×¢×¦××™ ===
${p.about || p.manualEntryText || '×œ× ×¦×•×™×Ÿ'}

=== ×”×¢×¨×•×ª ×©×“×›×Ÿ ===
${p.matchingNotes || '××™×Ÿ'}
  `.trim();
}

interface BatchScanResult {
  femaleId: string;
  score: number;
  reasoning: string;
  femaleProfileUpdatedAt: Date;
}

async function scanBatchWithAI(
  male: any,
  maleNarrativeProfile: string,
  maleBackgroundProfile: any,
  maleAge: number,
  females: any[]
): Promise<BatchScanResult[]> {
  const apiKey = process.env.GOOGLE_API_KEY;
  if (!apiKey) {
    throw new Error('GOOGLE_API_KEY is not configured');
  }

  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({
    model: 'gemini-2.5-flash',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.3,
    },
  });

  // ×‘× ×™×™×ª ×¤×¨×•×¤×™×œ×™× ×©×œ ×”×‘×—×•×¨×•×ª
  const candidatesText = females.map((female, index) => {
    const femaleAge = female.profile?.birthDate 
      ? calculateAge(female.profile.birthDate) 
      : null;
    
    const femaleBackgroundProfile = createBackgroundProfile(
      female.profile?.nativeLanguage,
      female.profile?.additionalLanguages || [],
      female.profile?.aliyaCountry,
      female.profile?.aliyaYear,
      female.profile?.origin,
      female.profile?.about,
      female.profile?.matchingNotes
    );

    const bgMatch = calculateBackgroundMatch(maleBackgroundProfile, femaleBackgroundProfile);

    return `
[××•×¢××“×ª ${index + 1}]
×©×: ${female.firstName} ${female.lastName}
×’×™×œ: ${femaleAge ?? '×œ× ×™×“×•×¢'}
×¨××” ×“×ª×™×ª: ${female.profile?.religiousLevel || '×œ× ×¦×•×™×Ÿ'}
×¢×™×¨: ${female.profile?.city || '×œ× ×¦×•×™×Ÿ'}
×¢×™×¡×•×§: ${female.profile?.occupation || '×œ× ×¦×•×™×Ÿ'}
×”×ª×××ª ×¨×§×¢: ${bgMatch.compatibility}

${female.profile?.aiProfileSummary?.personalitySummary || female.profile?.about || female.profile?.manualEntryText || '××™×Ÿ ××™×“×¢'}
---`;
  }).join('\n\n');

  const prompt = `××ª×” ×©×“×›×Ÿ AI ××•××—×” ×‘××¢×¨×›×ª NeshamaTech.

=== ×¤×¨×•×¤×™×œ ×”×’×‘×¨ ===
${maleNarrativeProfile}

=== ${females.length} ××•×¢××“×•×ª ×œ×‘×“×™×§×” ===
${candidatesText}

=== ×”××©×™××” ===
×“×¨×’ ×›×œ ××•×¢××“×ª ×-0 ×¢×“ 100 ×œ×¤×™ ×”×ª×××” ×œ×’×‘×¨.

×§×¨×™×˜×¨×™×•× ×™× ×¢×™×§×¨×™×™×:
1. ×”×ª×××” ×“×ª×™×ª ×•×”×©×§×¤×ª×™×ª (30 × ×§×•×“×•×ª)
2. ×”×ª×××ª ×’×™×œ (10 × ×§×•×“×•×ª)
3. ××™×–×•×Ÿ ×§×¨×™×™×¨×”-××©×¤×—×” (15 × ×§×•×“×•×ª)
4. ×¡×’× ×•×Ÿ ×—×™×™× (13 × ×§×•×“×•×ª)
5. ×©××¤×ª× ×•×ª ×•××•×˜×™×‘×¦×™×” (11 × ×§×•×“×•×ª)
6. ×¡×’× ×•×Ÿ ×ª×§×©×•×¨×ª (11 × ×§×•×“×•×ª)
7. ×¢×¨×›×™× (10 × ×§×•×“×•×ª)

=== ×¤×•×¨××˜ ×”×ª×©×•×‘×” (JSON ×‘×œ×‘×“) ===
{
  "results": [
    { "index": 1, "score": 85, "reasoning": "× ×™××•×§ ×§×¦×¨" },
    { "index": 2, "score": 72, "reasoning": "× ×™××•×§ ×§×¦×¨" }
  ]
}

×”×ª×©×•×‘×” ×—×™×™×‘×ª ×œ×”×™×•×ª JSON ×ª×§×™×Ÿ ×‘×œ×‘×“.`;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    let jsonString = response.text();
    
    // × ×™×§×•×™ ×× ×™×© markdown
    if (jsonString.startsWith('```json')) {
      jsonString = jsonString.slice(7, -3).trim();
    } else if (jsonString.startsWith('```')) {
      jsonString = jsonString.slice(3, -3).trim();
    }

    const parsed = JSON.parse(jsonString) as {
      results: Array<{ index: number; score: number; reasoning: string }>;
    };

    return parsed.results.map(r => {
      const female = females[r.index - 1];
      return {
        femaleId: female.id,
        score: Math.min(100, Math.max(0, r.score)),
        reasoning: r.reasoning || '',
        femaleProfileUpdatedAt: female.profile?.updatedAt || new Date(),
      };
    });

  } catch (error) {
    console.error(`[BatchScan] AI error:`, error);
    // ×‘××§×¨×” ×©×œ ×©×’×™××”, × ×—×–×™×¨ ×¦×™×•×Ÿ 0 ×œ×›×œ ×”×‘×—×•×¨×•×ª
    return females.map(f => ({
      femaleId: f.id,
      score: 0,
      reasoning: 'AI error',
      femaleProfileUpdatedAt: f.profile?.updatedAt || new Date(),
    }));
  }
}

async function saveToPotentialMatch(
  maleUserId: string,
  femaleUserId: string,
  result: BatchScanResult
): Promise<'new' | 'updated' | 'unchanged'> {
  try {
    const existing = await prisma.potentialMatch.findUnique({
      where: {
        maleUserId_femaleUserId: { maleUserId, femaleUserId }
      }
    });

    if (existing) {
      if (Math.abs(existing.aiScore - result.score) > 2 || existing.status === 'EXPIRED') {
        await prisma.potentialMatch.update({
          where: { id: existing.id },
          data: {
            aiScore: result.score,
            shortReasoning: result.reasoning,
            scannedAt: new Date(),
            status: existing.status === 'EXPIRED' ? 'PENDING' : existing.status,
          }
        });
        return 'updated';
      }
      return 'unchanged';
    }

    await prisma.potentialMatch.create({
      data: {
        maleUserId,
        femaleUserId,
        aiScore: result.score,
        shortReasoning: result.reasoning,
        status: 'PENDING',
        scannedAt: new Date(),
      }
    });
    return 'new';

  } catch (error) {
    console.warn(`[BatchScan] Could not save PotentialMatch:`, error);
    return 'unchanged';
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\batch-scan-symmetric
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\batch-scan-symmetric\route.ts
--------------------------------------------------------------------------------
Content:
// =============================================================================
// ğŸ“ src/app/api/ai/batch-scan-symmetric/route.ts
// =============================================================================
// ğŸ¯ Symmetric Batch Scan API V1.0 - NeshamaTech
// 
// ×¡×¨×™×§×” ×¡×™××˜×¨×™×ª ×¢× Tiered Matching
// =============================================================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import symmetricScanService from "@/lib/services/symmetricScanService";

// =============================================================================
// GET - ××™×“×¢ ×¢×œ ×”×¡×¨×™×§×”
// =============================================================================

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const userRole = (session.user as any).role;
    if (userRole !== 'MATCHMAKER' && userRole !== 'ADMIN') {
      return NextResponse.json(
        { error: "Access denied" },
        { status: 403 }
      );
    }
    
    // ××™×“×¢ ×¢×œ ×”×’×“×¨×•×ª ×”×¡×¨×™×§×”
    return NextResponse.json({
      version: "1.0",
      scanType: "symmetric_tiered",
      tiers: {
        quickFilter: {
          description: "××¡× ×Ÿ ××”×™×¨ - ×’×™×œ, ×“×ª, ×”×™×¡×˜×•×¨×™×”",
          thresholds: symmetricScanService.QUICK_FILTER,
        },
        vectorFilter: {
          description: "×¡×™× ×•×Ÿ ×•×§×˜×•×¨×™ - ×“××™×•×Ÿ ×¤×¨×•×¤×™×œ×™×",
          thresholds: symmetricScanService.VECTOR_FILTER,
        },
        softScoring: {
          description: "×¦×™×•×Ÿ ×¨×š - ×”×ª×××•×ª ×‘×¡×™×¡×™×•×ª",
          thresholds: symmetricScanService.SOFT_SCORING,
        },
        aiScoring: {
          description: "× ×™×ª×•×— AI - ×¨×§ Top 30",
          thresholds: symmetricScanService.AI_SCORING,
        },
      },
      features: [
        "âœ… ×¡×¨×™×§×” ×“×•-×›×™×•×•× ×™×ª (×’×‘×¨×™× + × ×©×™×)",
        "âœ… Tiered Matching ×œ×—×™×¡×›×•×Ÿ ×‘-API",
        "âœ… Asymmetric Scoring",
        "âœ… Vector Similarity",
      ],
    });
    
  } catch (error) {
    console.error("[SymmetricScan API] Error:", error);
    return NextResponse.json(
      { error: "Failed to get scan info" },
      { status: 500 }
    );
  }
}

// =============================================================================
// POST - ×”×¨×¦×ª ×¡×¨×™×§×”
// =============================================================================

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const userRole = (session.user as any).role;
    if (userRole !== 'MATCHMAKER' && userRole !== 'ADMIN') {
      return NextResponse.json(
        { error: "Access denied" },
        { status: 403 }
      );
    }
    
    const body = await request.json();
    const { 
      action,
      usersToScan,
      forceRefresh,
      skipVectorTier,
      minAiScore,
    } = body;
    
    switch (action) {
      case 'full_scan': { 
        // ×¡×¨×™×§×” ××œ××”
        console.log(`[SymmetricScan API] Starting full scan (forceRefresh: ${forceRefresh})`);
        
        const fullResult = await symmetricScanService.runSymmetricScan({
          forceRefresh: forceRefresh ?? false,
          skipVectorTier: skipVectorTier ?? false,
          minAiScore: minAiScore ?? 70,
        });
        
        return NextResponse.json(fullResult);
      }
 case 'scan_users': { // <--- ×”×•×¡×¤×ª ×¡×•×’×¨×™×™× ××¡×•×œ×¡×œ×™× ×›××Ÿ
        // ×¡×¨×™×§×” ×œ××©×ª××©×™× ×¡×¤×¦×™×¤×™×™×
        if (!usersToScan || !Array.isArray(usersToScan) || usersToScan.length === 0) {
          return NextResponse.json(
            { error: "usersToScan array required" },
            { status: 400 }
          );
        }
        
        console.log(`[SymmetricScan API] Scanning ${usersToScan.length} specific users`);
        
        const usersResult = await symmetricScanService.runSymmetricScan({
          usersToScan,
          forceRefresh: true,
        });
        
        return NextResponse.json(usersResult);
      } // <--- ×¡×’×™×¨×ª ×¡×•×’×¨×™×™× ××¡×•×œ×¡×œ×™× ×›××Ÿ

        
      case 'scan_single':{ 
        // ×¡×¨×™×§×” ×œ××©×ª××© ×‘×•×“×“
        const { userId } = body;
        
        if (!userId) {
          return NextResponse.json(
            { error: "userId required" },
            { status: 400 }
          );
        }
        
        console.log(`[SymmetricScan API] Scanning single user: ${userId}`);
        
        const singleResult = await symmetricScanService.scanSingleUser(userId);
        
        return NextResponse.json({ 
          success: true, 
          ...singleResult 
        });
      }
      case 'scan_new_users':{ 
        // ×¡×¨×™×§×ª ××©×ª××©×™× ×—×“×©×™× (24 ×©×¢×•×ª ××—×¨×•× ×•×ª)
        console.log(`[SymmetricScan API] Scanning new users`);
        
        const newUsersResult = await symmetricScanService.scanNewUsers();
        
        return NextResponse.json(newUsersResult);
      }
      default:
        return NextResponse.json(
          { error: "Unknown action. Valid actions: full_scan, scan_users, scan_single, scan_new_users" },
          { status: 400 }
        );
    }
    
  } catch (error) {
    console.error("[SymmetricScan API] POST Error:", error);
    
    return NextResponse.json(
      { 
        error: "Scan failed",
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches-v2
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches-v2\route.ts
--------------------------------------------------------------------------------
Content:
// ===========================================
// src/app/api/ai/find-matches-v2/route.ts
// ===========================================
// ğŸ¯ API Route ×¢× ×ª××™×›×” ×‘-Background Jobs
// ×¤×•×ª×¨ ××ª ×‘×¢×™×™×ª ×”-30 ×©× ×™×•×ª timeout ×©×œ Heroku
// ğŸ”§ ×ª×™×§×•×Ÿ: ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ ××¢×•×‘×“ ×™×©×™×¨×•×ª (×œ× fire-and-forget)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole, Gender } from "@prisma/client";
import prisma from "@/lib/prisma";
import { findMatchesForVirtualUser } from '@/lib/services/matchingAlgorithmService';
import { findMatchesForVirtualUserVector } from '@/lib/services/vectorMatchingService';

export const dynamic = 'force-dynamic';
export const maxDuration = 300; // 5 ×“×§×•×ª ×œ×—×™×¤×•×©×™× ××¨×•×›×™×

// ============================================================================
// TYPES
// ============================================================================

interface VirtualProcessingParams {
  virtualProfileId: string;
  virtualProfile: any;
  gender: string;
  religiousLevel: string;
  editedSummary?: string;
  method: string;
  matchmakerId: string;
}

// ============================================================================
// POST - ×”×ª×—×œ×ª Job ×—×“×© (××—×–×™×¨ ××™×“!)
// ============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  try {
    // Authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ 
        success: false, 
        error: "Unauthorized" 
      }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ 
        success: false, 
        error: "Forbidden" 
      }, { status: 403 });
    }

    // Parse body
    const body = await req.json();
    const { 
      targetUserId, 
      forceRefresh = false, 
      method = 'algorithmic',
      // ğŸ†• ×¤×¨××˜×¨×™× ×œ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™
      isVirtualSearch = false,
      virtualProfileId,
      virtualProfile,
      gender,
      religiousLevel,
      editedSummary,
    } = body;

    const matchmakerId = session.user.id;

    // ================================================================
    // ğŸ”® ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ - ××¢×•×‘×“ ×™×©×™×¨×•×ª (×œ× fire-and-forget)
    // ================================================================
    if (isVirtualSearch) {
      if (!virtualProfileId || !virtualProfile || !gender || !religiousLevel) {
        return NextResponse.json({ 
          success: false, 
          error: "Missing required virtual profile parameters" 
        }, { status: 400 });
      }

      console.log(`\n${'='.repeat(60)}`);
      console.log(`[MatchingJob] ğŸ”® Virtual search request from ${session.user.email}`);
      console.log(`[MatchingJob] Virtual Profile: ${virtualProfileId}, Method: ${method}`);
      console.log(`${'='.repeat(60)}\n`);

      // ×™×¦×™×¨×ª Job ×—×“×© ×œ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™
      const newJob = await prisma.matchingJob.create({
        data: {
          targetUserId: virtualProfileId,
          matchmakerId,
          method: `${method}-virtual`,
          status: 'processing', // ××ª×—×™×œ ×™×©×¨ ×‘-processing
          progress: 5,
          progressMessage: '××ª×—×™×œ ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™...'
        }
      });

      console.log(`[MatchingJob] ğŸ†• Created virtual job: ${newJob.id}`);

      // ğŸ”¥ ×”×¤×¢×œ×ª ×¢×™×‘×•×“ ×™×©×™×¨ (×œ× fire-and-forget!)
      // ××©×ª××©×™× ×‘-Promise ×©×œ× ××—×›×™× ×œ×•, ××‘×œ ××¢×‘×“×™× ×™×©×™×¨×•×ª
      processVirtualSearchDirectly(newJob.id, {
        virtualProfileId,
        virtualProfile,
        gender,
        religiousLevel,
        editedSummary,
        method,
        matchmakerId,
      }).catch(err => {
        console.error(`[MatchingJob] âŒ Virtual search processing error:`, err);
      });

      // ××—×–×™×¨×™× ×ª×©×•×‘×” ××™×™×“×™×ª ×¢× ×”-jobId
      return NextResponse.json({
        success: true,
        jobId: newJob.id,
        status: 'processing',
        progress: 5,
        progressMessage: '××ª×—×™×œ ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™...',
        isVirtualSearch: true,
      });
    }

    // ================================================================
    // ğŸ‘¤ ×—×™×¤×•×© ×¨×’×™×œ - ×××©×™×š ×›×¨×’×™×œ
    // ================================================================
    
    if (!targetUserId || typeof targetUserId !== 'string') {
      return NextResponse.json({ 
        success: false, 
        error: "targetUserId is required" 
      }, { status: 400 });
    }

    console.log(`[MatchingJob] ğŸ“‹ New request from ${session.user.email}`);
    console.log(`[MatchingJob] Target: ${targetUserId}, Method: ${method}`);

    // ×‘×“×™×§×” ×× ×™×© Job ×¤×¢×™×œ ×§×™×™× ×œ××•×ª×• ××©×ª××©
    const existingActiveJob = await prisma.matchingJob.findFirst({
      where: {
        targetUserId,
        method,
        status: { in: ['pending', 'processing'] }
      }
    });

    if (existingActiveJob) {
      console.log(`[MatchingJob] â³ Found existing active job: ${existingActiveJob.id}`);
      return NextResponse.json({
        success: true,
        jobId: existingActiveJob.id,
        status: existingActiveJob.status,
        progress: existingActiveJob.progress,
        progressMessage: existingActiveJob.progressMessage,
        isExisting: true
      });
    }

    // ×‘×“×™×§×ª Cache
    if (!forceRefresh) {
      const recentCompletedJob = await prisma.matchingJob.findFirst({
        where: {
          targetUserId,
          method,
          status: 'completed',
          completedAt: { 
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
          }
        },
        orderBy: { completedAt: 'desc' }
      });

      if (recentCompletedJob && recentCompletedJob.result) {
        console.log(`[MatchingJob] âœ… Using cached results from ${recentCompletedJob.completedAt}`);
        return NextResponse.json({
          success: true,
          jobId: recentCompletedJob.id,
          status: 'completed',
          progress: 100,
          fromCache: true,
          result: recentCompletedJob.result,
          meta: {
            completedAt: recentCompletedJob.completedAt,
            matchesFound: recentCompletedJob.matchesFound,
            totalCandidates: recentCompletedJob.totalCandidates
          }
        });
      }
    }

    // ×™×¦×™×¨×ª Job ×—×“×©
    const newJob = await prisma.matchingJob.create({
      data: {
        targetUserId,
        matchmakerId,
        method,
        status: 'pending',
        progress: 0,
        progressMessage: '×××ª×™×Ÿ ×œ×”×ª×—×œ×”...'
      }
    });

    console.log(`[MatchingJob] ğŸ†• Created new job: ${newJob.id}`);

    // ×”×¤×¢×œ×ª ×¢×™×‘×•×“ ×‘×¨×§×¢ (×œ×—×™×¤×•×© ×¨×’×™×œ)
    triggerBackgroundProcessing(newJob.id).catch(err => {
      console.error(`[MatchingJob] Failed to trigger background processing:`, err);
    });

    return NextResponse.json({
      success: true,
      jobId: newJob.id,
      status: 'pending',
      progress: 0,
      progressMessage: '×××ª×™×Ÿ ×œ×”×ª×—×œ×”...'
    });

  } catch (error) {
    console.error('[MatchingJob] POST Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Internal server error" 
    }, { status: 500 });
  }
}

// ============================================================================
// ğŸ”® ×¢×™×‘×•×“ ×™×©×™×¨ ×©×œ ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ (×œ× fire-and-forget!)
// ============================================================================

async function processVirtualSearchDirectly(
  jobId: string,
  params: VirtualProcessingParams
): Promise<void> {
  const startTime = Date.now();
  
  console.log(`\n${'='.repeat(60)}`);
  console.log(`[VirtualSearch] ğŸš€ Starting direct processing for job: ${jobId}`);
  console.log(`[VirtualSearch] Method: ${params.method}`);
  console.log(`${'='.repeat(60)}\n`);

  try {
    // ×¢×“×›×•×Ÿ ×”×ª×§×“××•×ª
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        progress: 10,
        progressMessage: '×˜×•×¢×Ÿ ×¤×¨×•×¤×™×œ ×•×™×¨×˜×•××œ×™...'
      }
    });

    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        progress: 20,
        progressMessage: '××—×¤×© ×”×ª×××•×ª...'
      }
    });

    let result;

    // ×‘×—×™×¨×ª ×©×™×˜×ª ×—×™×¤×•×©
    if (params.method === 'vector' || params.method === 'vector-virtual') {
      console.log(`[VirtualSearch] ğŸ”· Using Vector Search`);
      
      await prisma.matchingJob.update({
        where: { id: jobId },
        data: {
          progress: 40,
          progressMessage: '××‘×¦×¢ ×—×™×¤×•×© ×•×§×˜×•×¨×™...'
        }
      });

      result = await findMatchesForVirtualUserVector(
        params.virtualProfileId,
        params.virtualProfile,
        params.gender as Gender,
        params.religiousLevel,
        params.matchmakerId,
        params.editedSummary
      );

    } else {
      console.log(`[VirtualSearch] ğŸ§  Using Algorithmic Search`);
      
      await prisma.matchingJob.update({
        where: { id: jobId },
        data: {
          progress: 40,
          progressMessage: '×× ×ª×— ××•×¢××“×™× ×¤×•×˜× ×¦×™××œ×™×™×...'
        }
      });

      result = await findMatchesForVirtualUser(
        params.virtualProfileId,
        null, // name - ×œ× × ×“×¨×©
        params.virtualProfile,
        params.gender as Gender,
        params.religiousLevel,
        params.matchmakerId,
        params.editedSummary
      );
    }

    // ×—×™×©×•×‘ ×–××Ÿ ×¨×™×¦×”
    const duration = Date.now() - startTime;
    const durationSeconds = (duration / 1000).toFixed(1);

    // ×©××™×¨×ª ×”×ª×•×¦××•×ª
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'completed',
        progress: 100,
        progressMessage: `×”×•×©×œ×! × ××¦××• ${result.matches.length} ×”×ª×××•×ª`,
        result: result.matches as any,
        matchesFound: result.matches.length,
        totalCandidates: result.meta?.totalCandidatesScanned || 0,
        completedAt: new Date()
      }
    });

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[VirtualSearch] âœ… Job ${jobId} completed successfully!`);
    console.log(`[VirtualSearch] â±ï¸ Duration: ${durationSeconds} seconds`);
    console.log(`[VirtualSearch] ğŸ“Š Matches found: ${result.matches.length}`);
    console.log(`${'='.repeat(60)}\n`);

  } catch (error) {
    const duration = Date.now() - startTime;
    
    console.error(`\n${'='.repeat(60)}`);
    console.error(`[VirtualSearch] âŒ Job ${jobId} FAILED after ${(duration/1000).toFixed(1)}s`);
    console.error(`[VirtualSearch] Error:`, error);
    console.error(`${'='.repeat(60)}\n`);

    // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×œ×›×™×©×œ×•×Ÿ
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        progress: 0,
        progressMessage: '×”×—×™×¤×•×© × ×›×©×œ',
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }).catch(err => {
      console.error(`[VirtualSearch] Failed to update job status:`, err);
    });
  }
}

// ============================================================================
// GET - ×‘×“×™×§×ª ×¡×˜×˜×•×¡ Job
// ============================================================================

export async function GET(req: NextRequest): Promise<NextResponse> {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const jobId = searchParams.get('jobId');
    const targetUserId = searchParams.get('targetUserId');

    // ×× ××™×Ÿ jobId - ××—×–×™×¨ ×¨×©×™××ª jobs ××• ××™×“×¢ ×¢×œ ×”-API
    if (!jobId) {
      // ×× ×™×© targetUserId - ××—×–×™×¨ ××ª ×”-jobs ×©×œ×•
      if (targetUserId) {
        const jobs = await prisma.matchingJob.findMany({
          where: { targetUserId },
          orderBy: { createdAt: 'desc' },
          take: 5,
          select: {
            id: true,
            status: true,
            progress: true,
            method: true,
            matchesFound: true,
            createdAt: true,
            completedAt: true
          }
        });
        return NextResponse.json({ success: true, jobs });
      }

      // ××—×¨×ª - ××—×–×™×¨ ××™×“×¢ ×¢×œ ×”-API
      return NextResponse.json({
        name: "NeshamaTech Matching API with Background Jobs",
        version: "4.1",
        endpoints: {
          "POST": "Start a new matching job",
          "GET ?jobId=xxx": "Check job status",
          "GET ?targetUserId=xxx": "List jobs for user",
          "DELETE ?jobId=xxx": "Cancel/delete a job"
        }
      });
    }

    // ×©×œ×™×¤×ª Job ×¡×¤×¦×™×¤×™
    const job = await prisma.matchingJob.findUnique({
      where: { id: jobId }
    });

    if (!job) {
      return NextResponse.json({ 
        success: false, 
        error: "Job not found" 
      }, { status: 404 });
    }

    // ××—×–×™×¨ ××ª ×”×¡×˜×˜×•×¡
    return NextResponse.json({
      success: true,
      jobId: job.id,
      targetUserId: job.targetUserId,
      method: job.method,
      status: job.status,
      progress: job.progress,
      progressMessage: job.progressMessage,
      result: job.status === 'completed' ? job.result : null,
      error: job.error,
      meta: {
        createdAt: job.createdAt,
        completedAt: job.completedAt,
        matchesFound: job.matchesFound,
        totalCandidates: job.totalCandidates
      }
    });

  } catch (error) {
    console.error('[MatchingJob] GET Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Internal server error" 
    }, { status: 500 });
  }
}

// ============================================================================
// DELETE - ×‘×™×˜×•×œ/××—×™×§×ª Job
// ============================================================================

export async function DELETE(req: NextRequest): Promise<NextResponse> {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const jobId = searchParams.get('jobId');

    if (!jobId) {
      return NextResponse.json({ 
        success: false, 
        error: "jobId is required" 
      }, { status: 400 });
    }

    // ××•×—×§ ××• ××¡××Ÿ ×›-cancelled
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: { 
        status: 'failed',
        error: 'Cancelled by user'
      }
    });

    return NextResponse.json({
      success: true,
      message: "Job cancelled"
    });

  } catch (error) {
    console.error('[MatchingJob] DELETE Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Internal server error" 
    }, { status: 500 });
  }
}

// ============================================================================
// Background Processing Trigger (×œ×—×™×¤×•×© ×¨×’×™×œ ×‘×œ×‘×“)
// ============================================================================

async function triggerBackgroundProcessing(jobId: string): Promise<void> {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || process.env.NEXTAUTH_URL || 'http://localhost:3000';
  
  console.log(`[MatchingJob] ğŸš€ Triggering background processing for job: ${jobId}`);
  console.log(`[MatchingJob] ğŸŒ Base URL: ${baseUrl}`);
  
  try {
    const response = await fetch(`${baseUrl}/api/ai/process-matching-job`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'x-internal-secret': process.env.INTERNAL_API_SECRET || 'default-secret'
      },
      body: JSON.stringify({ jobId })
    });
    
    console.log(`[MatchingJob] âœ… Background job triggered, status: ${response.status}`);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[MatchingJob] âš ï¸ Background trigger returned error:`, errorText);
    }
    
  } catch (err) {
    // ×× ×”×§×¨×™××” × ×›×©×œ×”, ××¢×“×›× ×™× ××ª ×”-Job ×¢× ×©×’×™××”
    console.error(`[MatchingJob] âŒ Failed to trigger background processing:`, err);
    
    // ×¢×“×›×•×Ÿ Job ×œ×¡×˜×˜×•×¡ ×©×’×™××”
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        error: `Failed to start background processing: ${err instanceof Error ? err.message : 'Unknown error'}`,
        progressMessage: '×©×’×™××” ×‘×”×¤×¢×œ×ª ×”×—×™×¤×•×©'
      }
    }).catch(updateErr => {
      console.error(`[MatchingJob] Failed to update job status:`, updateErr);
    });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
# Generated on: 2026-01-15 23:52:00
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ×™×¦×™×¨×ª ×¡×™×›×•× ×¤×¨×•×¤×™×œ (××™×©×™×•×ª + ××” ××—×¤×©) ×¢×‘×•×¨ ×©×“×›×Ÿ.
 * ×‘×•×“×§ ××˜××•×Ÿ ×‘×“××˜×” ×‘×™×™×¡ ×œ×¤× ×™ ×¤× ×™×™×” ×œ-AI.
 */
export async function POST(req: NextRequest) {
  // ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™× ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId, forceRefresh } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ ×•×”×©×“×” ×”×—×“×© ××”×“××˜×” ×‘×™×™×¡ ×œ×‘×“×™×§×ª ××˜××•×Ÿ
    const existingProfile = await prisma.profile.findUnique({
      where: { userId },
      select: { 
        aiProfileSummary: true, 
        needsAiProfileUpdate: true 
      }
    });

    if (!existingProfile) {
      return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 4. ×œ×•×’×™×§×ª ××˜××•×Ÿ: ×× ×™×© ×¡×™×›×•× ×©××•×¨, ×”×¤×¨×•×¤×™×œ ×œ× ×”×©×ª× ×”, ×•×œ× ×‘×™×§×©× ×• ×¨×¢× ×•×Ÿ ×‘×›×•×— -> × ×—×–×™×¨ ××ª ×”×§×™×™×
    if (
      existingProfile.aiProfileSummary && 
      !existingProfile.needsAiProfileUpdate && 
      !forceRefresh
    ) {
      console.log(`[API analyze-profile] Returning cached summary for user: ${userId}`);
      return NextResponse.json({ success: true, data: existingProfile.aiProfileSummary });
    }

    console.log(`[API analyze-profile] Generating NEW summary for user: ${userId} (Force: ${forceRefresh})`);

    // 5. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£ (×˜×§×¡×˜ ×’×•×œ××™ ×œ-AI)
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 6. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI (×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”×—×“×©×” ×•×”×××•×§×“×ª)
    const summaryResult = await aiService.generateProfileSummary(narrativeProfile);

    if (!summaryResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 7. ×©××™×¨×ª ×”×ª×•×¦××” ×‘×“××˜×” ×‘×™×™×¡ (×‘×©×“×” ×”×—×“×© aiProfileSummary) ×•××™×¤×•×¡ ×”×“×’×œ needsAiProfileUpdate
    await prisma.profile.update({
      where: { userId },
      data: {
        aiProfileSummary: summaryResult as any, // ×”××¨×” ×œ-Json ×©×œ ×¤×¨×™×–××”
        needsAiProfileUpdate: false // ×”×“×•×— ××¢×•×“×›×Ÿ ×›×¢×ª
      }
    });

    // 8. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”×—×“×©×” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: summaryResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export const maxDuration = 60; // ×–××Ÿ ×¨×™×¦×” ××§×¡×™××œ×™ (×× ×”×©×¨×ª ×ª×•××š)
export const dynamic = 'force-dynamic';

export async function POST(req: NextRequest) {
  try {
    // 1. ×‘×“×™×§×ª ×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { action, batchSize = 5 } = await req.json();

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 1: RESET_FLAGS
    // ×¡×™××•×Ÿ ×›×œ ×”××•×¢××“×™× ×”×¤×¢×™×œ×™× ×›"× ×“×¨×©×™× ×œ×¢×“×›×•×Ÿ"
    // ×× ×—× ×• ××¡×× ×™× ××ª ×›×•×œ×, ×”×¡×™× ×•×Ÿ ×”×××™×ª×™ ×™×§×¨×” ×‘×–××Ÿ ×”×¢×™×‘×•×“ ×›×“×™ ×œ×—×¡×•×š ×‘×™×¦×•×¢×™×
    // ---------------------------------------------------------
    if (action === 'RESET_FLAGS') {
      const updateResult = await prisma.profile.updateMany({
        where: {
          user: {
            role: 'CANDIDATE',
            // ××¡× × ×™× ×¨×§ ×™×•×–×¨×™× ×¤×¢×™×œ×™× ××• ×‘×ª×”×œ×™×š ××™××•×ª (×œ× ×—×¡×•××™×)
            status: { in: ['ACTIVE', 'PENDING_EMAIL_VERIFICATION', 'PENDING_PHONE_VERIFICATION'] }
          }
        },
        data: { needsAiProfileUpdate: true }
      });
      
      return NextResponse.json({ 
        success: true, 
        message: 'Flags reset successfully', 
        count: updateResult.count 
      });
    }

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 2: PROCESS_BATCH
    // ×©×œ×™×¤×” ×•×¢×™×‘×•×“ ×©×œ ×§×‘×•×¦×ª ××©×ª××©×™×
    // ---------------------------------------------------------
    if (action === 'PROCESS_BATCH') {
      // 1. ×©×œ×™×¤×ª ××•×¢××“×™× ×©×¦×¨×™×›×™× ×¢×“×›×•×Ÿ
      const candidatesToProcess = await prisma.user.findMany({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: {
            needsAiProfileUpdate: true
          }
        },
        take: batchSize,
        // ×©×œ×™×¤×ª ×”××™×“×¢ ×”×¨×œ×•×•× ×˜×™ ×œ×‘×“×™×§×ª "×”×× ×™×© ×“××˜×”"
        include: {
          profile: {
            select: { id: true, about: true, needsAiProfileUpdate: true }
          },
          questionnaireResponses: {
            select: { id: true } // ××¡×¤×™×§ ×œ×“×¢×ª ×× ×§×™×™× ID ×›×“×™ ×œ×“×¢×ª ×©×™×© ×©××œ×•×Ÿ
          }
        }
      });

      // ×‘×“×™×§×” ×›××” × ×©××¨×• ×¡×”"×› (×œ×¦×•×¨×š ×”-Progress Bar)
      const remainingCount = await prisma.user.count({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: { needsAiProfileUpdate: true }
        }
      });

      // ×× ××™×Ÿ ×™×•×ª×¨ ××•×¢××“×™× ×œ×¢×“×›×•×Ÿ - ×¡×™×™×× ×•
      if (candidatesToProcess.length === 0) {
        return NextResponse.json({ success: true, processed: 0, remaining: 0, completed: true });
      }

      console.log(`[Batch AI] Processing batch of ${candidatesToProcess.length} candidates...`);

      // 2. ×¢×™×‘×•×“ ×‘××§×‘×™×œ
      const results = await Promise.all(
        candidatesToProcess.map(async (user) => {
          try {
            // --- ×©×œ×‘ ×”×¡×™× ×•×Ÿ ×”×—×›× ---
            // × ×‘×“×•×§ ×”×× ×œ×™×•×–×¨ ×™×© ××™×“×¢ ×¨×œ×•×•× ×˜×™ ×œ-AI
            
            const hasAbout = user.profile?.about && user.profile.about.trim().length > 10; // ×œ×¤×—×•×ª 10 ×ª×•×•×™×
            const hasQuestionnaire = user.questionnaireResponses && user.questionnaireResponses.length > 0;

            // ×× ××™×Ÿ ×©×•× ××™×“×¢ - ××“×œ×’×™× (××‘×œ ××›×‘×™× ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×—×–×•×¨ ××œ×™×•)
            if (!hasAbout && !hasQuestionnaire) {
              await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
              });
              return { id: user.id, status: 'skipped_no_data' };
            }

            // --- ×™×© ××™×“×¢? ×××©×™×›×™× ×œ-AI ---

            // 1. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ (×”×¤×•× ×§×¦×™×” ×”×–×• ×›×‘×¨ ×™×•×“×¢×ª ×œ×§×—×ª ×©××œ×•× ×™× ×•-about)
            const narrative = await profileAiService.generateNarrativeProfile(user.id);
            
            // ×”×’× ×” × ×•×¡×¤×ª ×œ××§×¨×” ×©×”× ×¨×˜×™×‘ ×™×¦× ×¨×™×§ ×œ××¨×•×ª ×”×‘×“×™×§×”
            if (!narrative || narrative.length < 20) {
                await prisma.profile.update({
                    where: { userId: user.id },
                    data: { needsAiProfileUpdate: false }
                });
                return { id: user.id, status: 'skipped_empty_narrative' };
            }

            // 2. ×™×¦×™×¨×ª ×”×“×•×— ×‘-AI
            const summary = await aiService.generateProfileSummary(narrative);
            
            if (!summary) throw new Error("AI Summary failed");

            // 3. ×©××™×¨×” ×‘×“××˜×” ×‘×™×™×¡ ×•×›×™×‘×•×™ ×”×“×’×œ
            await prisma.profile.update({
              where: { userId: user.id },
              data: {
                aiProfileSummary: summary as any, // ×”××¨×ª JSON ×œ×¤×•×¨××˜ ×©×œ ×¤×¨×™×–××”
                needsAiProfileUpdate: false,
                // ××•×¤×¦×™×•× ×œ×™: ×¢×“×›×•×Ÿ ××•× ×” ×”×¤×¢××™× ×©×”×•×¤×§ ×“×•×— (×× ×”×•×¡×¤×ª ××ª ×”×©×“×” ××”××•×“×œ)
                // neshamaInsightGeneratedCount: { increment: 1 },
                // neshamaInsightLastGeneratedAt: new Date()
              }
            });

            return { id: user.id, status: 'success' };

          } catch (error) {
            console.error(`[Batch AI] Failed for user ${user.id}:`, error);
            // ×‘××§×¨×” ×©×’×™××” ×˜×›× ×™×ª ×‘-AI, × ×›×‘×” ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×ª×§×•×¢ ××ª ×”×ª×”×œ×™×š ×”×›×œ×œ×™
            await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
            });
            return { id: user.id, status: 'error' };
          }
        })
      );

      const successful = results.filter(r => r.status === 'success').length;
      const skipped = results.filter(r => r.status.startsWith('skipped')).length;

      return NextResponse.json({
        success: true,
        processed: candidatesToProcess.length, // ×¡×š ×”×›×œ ×©×¢×‘×¨×• ×‘×‘××¥'
        successful, // ×›××” × ×•×¦×¨×• ×‘×¤×•×¢×œ
        skipped,    // ×›××” ×“×•×œ×’×• ×›×™ ×”×™×• ×¨×™×§×™×
        remaining: Math.max(0, remainingCount - candidatesToProcess.length),
        completed: (remainingCount - candidatesToProcess.length) <= 0
      });
    }

    return NextResponse.json({ success: false, error: "Invalid action" }, { status: 400 });

  } catch (error) {
    console.error('[Batch Process] Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ×™×¦×™×¨×ª ×¡×™×›×•× ×¤×¨×•×¤×™×œ (××™×©×™×•×ª + ××” ××—×¤×©) ×¢×‘×•×¨ ×©×“×›×Ÿ.
 * ×‘×•×“×§ ××˜××•×Ÿ ×‘×“××˜×” ×‘×™×™×¡ ×œ×¤× ×™ ×¤× ×™×™×” ×œ-AI.
 */
export async function POST(req: NextRequest) {
  // ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™× ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId, forceRefresh } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ ×•×”×©×“×” ×”×—×“×© ××”×“××˜×” ×‘×™×™×¡ ×œ×‘×“×™×§×ª ××˜××•×Ÿ
    const existingProfile = await prisma.profile.findUnique({
      where: { userId },
      select: { 
        aiProfileSummary: true, 
        needsAiProfileUpdate: true 
      }
    });

    if (!existingProfile) {
      return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 4. ×œ×•×’×™×§×ª ××˜××•×Ÿ: ×× ×™×© ×¡×™×›×•× ×©××•×¨, ×”×¤×¨×•×¤×™×œ ×œ× ×”×©×ª× ×”, ×•×œ× ×‘×™×§×©× ×• ×¨×¢× ×•×Ÿ ×‘×›×•×— -> × ×—×–×™×¨ ××ª ×”×§×™×™×
    if (
      existingProfile.aiProfileSummary && 
      !existingProfile.needsAiProfileUpdate && 
      !forceRefresh
    ) {
      console.log(`[API analyze-profile] Returning cached summary for user: ${userId}`);
      return NextResponse.json({ success: true, data: existingProfile.aiProfileSummary });
    }

    console.log(`[API analyze-profile] Generating NEW summary for user: ${userId} (Force: ${forceRefresh})`);

    // 5. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£ (×˜×§×¡×˜ ×’×•×œ××™ ×œ-AI)
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 6. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI (×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”×—×“×©×” ×•×”×××•×§×“×ª)
    const summaryResult = await aiService.generateProfileSummary(narrativeProfile);

    if (!summaryResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 7. ×©××™×¨×ª ×”×ª×•×¦××” ×‘×“××˜×” ×‘×™×™×¡ (×‘×©×“×” ×”×—×“×© aiProfileSummary) ×•××™×¤×•×¡ ×”×“×’×œ needsAiProfileUpdate
    await prisma.profile.update({
      where: { userId },
      data: {
        aiProfileSummary: summaryResult as any, // ×”××¨×” ×œ-Json ×©×œ ×¤×¨×™×–××”
        needsAiProfileUpdate: false // ×”×“×•×— ××¢×•×“×›×Ÿ ×›×¢×ª
      }
    });

    // 8. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”×—×“×©×” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: summaryResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\batch-process\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export const maxDuration = 60; // ×–××Ÿ ×¨×™×¦×” ××§×¡×™××œ×™ (×× ×”×©×¨×ª ×ª×•××š)
export const dynamic = 'force-dynamic';

export async function POST(req: NextRequest) {
  try {
    // 1. ×‘×“×™×§×ª ×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { action, batchSize = 5 } = await req.json();

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 1: RESET_FLAGS
    // ×¡×™××•×Ÿ ×›×œ ×”××•×¢××“×™× ×”×¤×¢×™×œ×™× ×›"× ×“×¨×©×™× ×œ×¢×“×›×•×Ÿ"
    // ×× ×—× ×• ××¡×× ×™× ××ª ×›×•×œ×, ×”×¡×™× ×•×Ÿ ×”×××™×ª×™ ×™×§×¨×” ×‘×–××Ÿ ×”×¢×™×‘×•×“ ×›×“×™ ×œ×—×¡×•×š ×‘×™×¦×•×¢×™×
    // ---------------------------------------------------------
    if (action === 'RESET_FLAGS') {
      const updateResult = await prisma.profile.updateMany({
        where: {
          user: {
            role: 'CANDIDATE',
            // ××¡× × ×™× ×¨×§ ×™×•×–×¨×™× ×¤×¢×™×œ×™× ××• ×‘×ª×”×œ×™×š ××™××•×ª (×œ× ×—×¡×•××™×)
            status: { in: ['ACTIVE', 'PENDING_EMAIL_VERIFICATION', 'PENDING_PHONE_VERIFICATION'] }
          }
        },
        data: { needsAiProfileUpdate: true }
      });
      
      return NextResponse.json({ 
        success: true, 
        message: 'Flags reset successfully', 
        count: updateResult.count 
      });
    }

    // ---------------------------------------------------------
    // ×¤×¢×•×œ×” 2: PROCESS_BATCH
    // ×©×œ×™×¤×” ×•×¢×™×‘×•×“ ×©×œ ×§×‘×•×¦×ª ××©×ª××©×™×
    // ---------------------------------------------------------
    if (action === 'PROCESS_BATCH') {
      // 1. ×©×œ×™×¤×ª ××•×¢××“×™× ×©×¦×¨×™×›×™× ×¢×“×›×•×Ÿ
      const candidatesToProcess = await prisma.user.findMany({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: {
            needsAiProfileUpdate: true
          }
        },
        take: batchSize,
        // ×©×œ×™×¤×ª ×”××™×“×¢ ×”×¨×œ×•×•× ×˜×™ ×œ×‘×“×™×§×ª "×”×× ×™×© ×“××˜×”"
        include: {
          profile: {
            select: { id: true, about: true, needsAiProfileUpdate: true }
          },
          questionnaireResponses: {
            select: { id: true } // ××¡×¤×™×§ ×œ×“×¢×ª ×× ×§×™×™× ID ×›×“×™ ×œ×“×¢×ª ×©×™×© ×©××œ×•×Ÿ
          }
        }
      });

      // ×‘×“×™×§×” ×›××” × ×©××¨×• ×¡×”"×› (×œ×¦×•×¨×š ×”-Progress Bar)
      const remainingCount = await prisma.user.count({
        where: {
          role: 'CANDIDATE',
          status: { notIn: ['BLOCKED', 'INACTIVE'] },
          profile: { needsAiProfileUpdate: true }
        }
      });

      // ×× ××™×Ÿ ×™×•×ª×¨ ××•×¢××“×™× ×œ×¢×“×›×•×Ÿ - ×¡×™×™×× ×•
      if (candidatesToProcess.length === 0) {
        return NextResponse.json({ success: true, processed: 0, remaining: 0, completed: true });
      }

      console.log(`[Batch AI] Processing batch of ${candidatesToProcess.length} candidates...`);

      // 2. ×¢×™×‘×•×“ ×‘××§×‘×™×œ
      const results = await Promise.all(
        candidatesToProcess.map(async (user) => {
          try {
            // --- ×©×œ×‘ ×”×¡×™× ×•×Ÿ ×”×—×›× ---
            // × ×‘×“×•×§ ×”×× ×œ×™×•×–×¨ ×™×© ××™×“×¢ ×¨×œ×•×•× ×˜×™ ×œ-AI
            
            const hasAbout = user.profile?.about && user.profile.about.trim().length > 10; // ×œ×¤×—×•×ª 10 ×ª×•×•×™×
            const hasQuestionnaire = user.questionnaireResponses && user.questionnaireResponses.length > 0;

            // ×× ××™×Ÿ ×©×•× ××™×“×¢ - ××“×œ×’×™× (××‘×œ ××›×‘×™× ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×—×–×•×¨ ××œ×™×•)
            if (!hasAbout && !hasQuestionnaire) {
              await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
              });
              return { id: user.id, status: 'skipped_no_data' };
            }

            // --- ×™×© ××™×“×¢? ×××©×™×›×™× ×œ-AI ---

            // 1. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ (×”×¤×•× ×§×¦×™×” ×”×–×• ×›×‘×¨ ×™×•×“×¢×ª ×œ×§×—×ª ×©××œ×•× ×™× ×•-about)
            const narrative = await profileAiService.generateNarrativeProfile(user.id);
            
            // ×”×’× ×” × ×•×¡×¤×ª ×œ××§×¨×” ×©×”× ×¨×˜×™×‘ ×™×¦× ×¨×™×§ ×œ××¨×•×ª ×”×‘×“×™×§×”
            if (!narrative || narrative.length < 20) {
                await prisma.profile.update({
                    where: { userId: user.id },
                    data: { needsAiProfileUpdate: false }
                });
                return { id: user.id, status: 'skipped_empty_narrative' };
            }

            // 2. ×™×¦×™×¨×ª ×”×“×•×— ×‘-AI
            const summary = await aiService.generateProfileSummary(narrative);
            
            if (!summary) throw new Error("AI Summary failed");

            // 3. ×©××™×¨×” ×‘×“××˜×” ×‘×™×™×¡ ×•×›×™×‘×•×™ ×”×“×’×œ
            await prisma.profile.update({
              where: { userId: user.id },
              data: {
                aiProfileSummary: summary as any, // ×”××¨×ª JSON ×œ×¤×•×¨××˜ ×©×œ ×¤×¨×™×–××”
                needsAiProfileUpdate: false,
                // ××•×¤×¦×™×•× ×œ×™: ×¢×“×›×•×Ÿ ××•× ×” ×”×¤×¢××™× ×©×”×•×¤×§ ×“×•×— (×× ×”×•×¡×¤×ª ××ª ×”×©×“×” ××”××•×“×œ)
                // neshamaInsightGeneratedCount: { increment: 1 },
                // neshamaInsightLastGeneratedAt: new Date()
              }
            });

            return { id: user.id, status: 'success' };

          } catch (error) {
            console.error(`[Batch AI] Failed for user ${user.id}:`, error);
            // ×‘××§×¨×” ×©×’×™××” ×˜×›× ×™×ª ×‘-AI, × ×›×‘×” ××ª ×”×“×’×œ ×›×“×™ ×œ× ×œ×ª×§×•×¢ ××ª ×”×ª×”×œ×™×š ×”×›×œ×œ×™
            await prisma.profile.update({
                where: { userId: user.id },
                data: { needsAiProfileUpdate: false }
            });
            return { id: user.id, status: 'error' };
          }
        })
      );

      const successful = results.filter(r => r.status === 'success').length;
      const skipped = results.filter(r => r.status.startsWith('skipped')).length;

      return NextResponse.json({
        success: true,
        processed: candidatesToProcess.length, // ×¡×š ×”×›×œ ×©×¢×‘×¨×• ×‘×‘××¥'
        successful, // ×›××” × ×•×¦×¨×• ×‘×¤×•×¢×œ
        skipped,    // ×›××” ×“×•×œ×’×• ×›×™ ×”×™×• ×¨×™×§×™×
        remaining: Math.max(0, remainingCount - candidatesToProcess.length),
        completed: (remainingCount - candidatesToProcess.length) <= 0
      });
    }

    return NextResponse.json({ success: false, error: "Invalid action" }, { status: 400 });

  } catch (error) {
    console.error('[Batch Process] Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\process-matching-job
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\process-matching-job\route.ts
--------------------------------------------------------------------------------
Content:
// ===========================================
// src/app/api/ai/process-matching-job/route.ts
// ===========================================
// ğŸ¯ Background Job Processor
// ××¢×‘×“ ×—×™×¤×•×©×™× ×¨×’×™×œ×™× (×œ× ×•×™×¨×˜×•××œ×™×™×) ×‘×¨×§×¢
// 
// ğŸ“ ×”×¢×¨×”: ×—×™×¤×•×©×™× ×•×™×¨×˜×•××œ×™×™× ××¢×•×‘×“×™× ×™×©×™×¨×•×ª ×‘-find-matches-v2
// ×•×œ× ×¢×•×‘×¨×™× ×“×¨×š route ×–×” ×™×•×ª×¨
//
// ğŸ†• ×¢×•×“×›×Ÿ: ×©×•××¨ ×ª×•×¦××•×ª ×’× ×‘-PotentialMatch ×œ×ª×¦×•×’×” ×‘×“×©×‘×•×¨×“

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { findMatchesForUser } from "@/lib/services/matchingAlgorithmService";
import { findMatchesWithVector } from "@/lib/services/vectorMatchingService";

export const dynamic = 'force-dynamic';
export const maxDuration = 300; // 5 ×“×§×•×ª

// ============================================================================
// POST - ××¢×‘×“ Job ×¨×’×™×œ (×œ× ×•×™×¨×˜×•××œ×™)
// ============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  const startTime = Date.now();
  
  try {
    // ××™××•×ª ×¤× ×™××™ - ×¨×§ ×§×¨×™××•×ª ××”×©×¨×ª ×¢×¦××•
    const internalSecret = req.headers.get('x-internal-secret');
    const expectedSecret = process.env.INTERNAL_API_SECRET || 'default-secret';
    
    if (internalSecret !== expectedSecret) {
      console.warn('[ProcessJob] âš ï¸ Unauthorized access attempt');
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { jobId } = body;

    if (!jobId) {
      return NextResponse.json({ error: "jobId required" }, { status: 400 });
    }

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[ProcessJob] ğŸ“¥ Received job: ${jobId}`);
    console.log(`${'='.repeat(60)}\n`);

    // ×©×œ×™×¤×ª ×¤×¨×˜×™ ×”-Job
    const job = await prisma.matchingJob.findUnique({
      where: { id: jobId }
    });

    if (!job) {
      console.error(`[ProcessJob] âŒ Job not found: ${jobId}`);
      return NextResponse.json({ error: "Job not found" }, { status: 404 });
    }

    // ×‘×“×™×§×” ×× ×–×” ×—×™×¤×•×© ×•×™×¨×˜×•××œ×™ - ×œ× ×××•×¨ ×œ×”×’×™×¢ ×œ×›××Ÿ ×™×•×ª×¨
    if (job.method?.includes('virtual')) {
      console.warn(`[ProcessJob] âš ï¸ Virtual search job ${jobId} arrived at wrong endpoint`);
      console.warn(`[ProcessJob] Virtual searches should be processed directly in find-matches-v2`);
      
      // ××¢×“×›× ×™× ×©×’×™××”
      await prisma.matchingJob.update({
        where: { id: jobId },
        data: {
          status: 'failed',
          error: 'Virtual search routed incorrectly - please retry',
          progressMessage: '×©×’×™××ª × ×™×ª×•×‘ - × × ×œ× ×¡×•×ª ×©×•×‘'
        }
      });
      
      return NextResponse.json({ 
        error: "Virtual searches should be processed directly",
        hint: "This is a routing error - virtual searches are now handled in find-matches-v2"
      }, { status: 400 });
    }

    // ×‘×“×™×§×” ×× ×”×’'×•×‘ ×›×‘×¨ ×”×¡×ª×™×™×
    if (job.status === 'completed' || job.status === 'failed') {
      console.log(`[ProcessJob] â­ï¸ Job ${jobId} already finished (status: ${job.status})`);
      return NextResponse.json({ 
        success: true, 
        message: "Job already finished",
        status: job.status 
      });
    }

    // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×œ-processing
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: { 
        status: 'processing',
        progress: 5,
        progressMessage: '××ª×—×™×œ ×¢×™×‘×•×“...'
      }
    });

    // ==========================================================
    // ğŸ”¥ ×¢×™×‘×•×“ ×‘×¨×§×¢ (Fire and Forget)
    // ==========================================================
    
    processJobInBackground(jobId, job.method, job.targetUserId, job.matchmakerId)
      .catch(err => {
        console.error(`[ProcessJob] Background processing failed:`, err);
      });

    // ××—×–×™×¨ ×ª×©×•×‘×” ××™×™×“×™×ª
    return NextResponse.json({ 
      success: true, 
      message: "Processing started",
      jobId 
    });

  } catch (error) {
    console.error('[ProcessJob] Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: "Failed to start processing" 
    }, { status: 500 });
  }
}

// ============================================================================
// Background Processing Function
// ============================================================================

async function processJobInBackground(
  jobId: string,
  method: string,
  targetUserId: string,
  matchmakerId: string
): Promise<void> {
  const startTime = Date.now();

  console.log(`\n${'='.repeat(60)}`);
  console.log(`[ProcessJob] ğŸš€ Starting background processing`);
  console.log(`[ProcessJob] Job ID: ${jobId}`);
  console.log(`[ProcessJob] Method: ${method}`);
  console.log(`[ProcessJob] Target: ${targetUserId}`);
  console.log(`${'='.repeat(60)}\n`);

  try {
    // ×¤×•× ×§×¦×™×™×ª callback ×œ×¢×“×›×•×Ÿ progress
    const onProgress = async (progress: number, message: string) => {
      await updateJobProgress(jobId, progress, message);
    };

    let result;

    // ==========================================================
    // ğŸ”· Vector Search
    // ==========================================================
    if (method === 'vector') {
      console.log(`[ProcessJob] ğŸ”· Running Vector Search method`);
      await onProgress(10, '××¤×¢×™×œ ×—×™×¤×•×© ×•×§×˜×•×¨×™...');
      
      result = await findMatchesWithVector(targetUserId, matchmakerId, {
        forceRefresh: true,
        autoSave: true,
      });
    } 
    // ==========================================================
    // ğŸ§  Algorithmic Search
    // ==========================================================
    else {
      console.log(`[ProcessJob] ğŸ§  Running Algorithmic method`);
      await onProgress(10, '×˜×•×¢×Ÿ × ×ª×•× ×™ ××•×¢××“ ××˜×¨×”...');
      
      result = await findMatchesForUserWithProgress(
        targetUserId, 
        matchmakerId,
        onProgress
      );
    }

    // ×—×™×©×•×‘ ×–××Ÿ ×¨×™×¦×”
    const duration = Date.now() - startTime;
    const durationMinutes = (duration / 1000 / 60).toFixed(2);

    // ×©××™×¨×ª ×”×ª×•×¦××•×ª ×‘-MatchingJob
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'completed',
        progress: 100,
        progressMessage: `×”×•×©×œ×! × ××¦××• ${result.matches.length} ×”×ª×××•×ª`,
        result: {
          matches: result.matches,
          meta: result.meta,
          fromCache: result.fromCache
        },
        matchesFound: result.matches.length,
        totalCandidates: result.meta?.totalCandidatesScanned || 0,
        completedAt: new Date()
      }
    });

    // ==========================================================
    // ğŸ†• ×©××™×¨×” ×’× ×‘-PotentialMatch ×œ×ª×¦×•×’×” ×‘×“×©×‘×•×¨×“
    // ==========================================================
    await saveToPotentialMatches(targetUserId, result.matches, 70);

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[ProcessJob] âœ… Job ${jobId} completed successfully!`);
    console.log(`[ProcessJob] â±ï¸ Duration: ${durationMinutes} minutes`);
    console.log(`[ProcessJob] ğŸ“Š Matches found: ${result.matches.length}`);
    console.log(`${'='.repeat(60)}\n`);

  } catch (error) {
    const duration = Date.now() - startTime;
    
    console.error(`\n${'='.repeat(60)}`);
    console.error(`[ProcessJob] âŒ Job ${jobId} FAILED after ${(duration/1000).toFixed(1)}s`);
    console.error(`[ProcessJob] Error:`, error);
    console.error(`${'='.repeat(60)}\n`);

    // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×œ×›×™×©×œ×•×Ÿ
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        progress: 0,
        progressMessage: '×”×—×™×¤×•×© × ×›×©×œ',
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }).catch(err => {
      console.error(`[ProcessJob] Failed to update job status:`, err);
    });
  }
}

// ============================================================================
// Helper: Update Job Progress
// ============================================================================

async function updateJobProgress(
  jobId: string, 
  progress: number, 
  message: string
): Promise<void> {
  try {
    await prisma.matchingJob.update({
      where: { id: jobId },
      data: {
        progress: Math.min(99, progress), // ××§×¡×™××•× 99 ×¢×“ ×©××¡×™×™×
        progressMessage: message
      }
    });
    console.log(`[ProcessJob] ğŸ“Š Progress: ${progress}% - ${message}`);
  } catch (error) {
    console.error(`[ProcessJob] Failed to update progress:`, error);
  }
}

// ============================================================================
// Wrapper: findMatchesForUser with Progress Updates
// ============================================================================

async function findMatchesForUserWithProgress(
  targetUserId: string,
  matchmakerId: string,
  onProgress: (progress: number, message: string) => Promise<void>
): Promise<{
  matches: any[];
  fromCache: boolean;
  meta: any;
}> {
  await onProgress(15, '×˜×•×¢×Ÿ × ×ª×•× ×™ ××•×¢××“ ××˜×¨×”...');
  await onProgress(20, '××—×¤×© ××•×¢××“×™× ××ª××™××™×...');
  await onProgress(30, '××¡× ×Ÿ ×œ×¤×™ ×§×¨×™×˜×¨×™×•× ×™×...');
  
  // ×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”××§×•×¨×™×ª
  const result = await findMatchesForUser(targetUserId, matchmakerId, {
    forceRefresh: true,
    autoSave: true,
  });

  await onProgress(95, '××¡×™×™× ×•×©×•××¨ ×ª×•×¦××•×ª...');

  return result;
}

// ============================================================================
// ğŸ†• ×©××™×¨×” ×‘-PotentialMatch (×œ×ª×¦×•×’×” ×‘×“×©×‘×•×¨×“)
// ============================================================================

async function saveToPotentialMatches(
  targetUserId: string,
  matches: any[],
  minScoreThreshold: number = 70
): Promise<void> {
  console.log(`[ProcessJob] ğŸ’¾ Saving ${matches.length} matches to PotentialMatch...`);
  
  // ×§×‘×œ×ª ×”××’×“×¨ ×©×œ ×”×™×•×–×¨
  const targetUser = await prisma.user.findUnique({
    where: { id: targetUserId },
    select: { profile: { select: { gender: true } } }
  });

  if (!targetUser?.profile?.gender) {
    console.log(`[ProcessJob] âš ï¸ Could not determine gender for ${targetUserId}`);
    return;
  }

  const isMale = targetUser.profile.gender === 'MALE';
  let saved = 0;
  let updated = 0;

  for (const match of matches) {
    const score = match.finalScore || match.score || 0;
    if (score < minScoreThreshold) continue;

    const maleUserId = isMale ? targetUserId : match.userId;
    const femaleUserId = isMale ? match.userId : targetUserId;

    try {
      const existing = await prisma.potentialMatch.findUnique({
        where: {
          maleUserId_femaleUserId: { maleUserId, femaleUserId }
        }
      });

      if (existing) {
        // ×¢×“×›×•×Ÿ ×× ×”×¦×™×•×Ÿ ×”×©×ª× ×” ××• ×©×¤×’ ×ª×•×§×£
        if (Math.abs(existing.aiScore - score) > 2 || existing.status === 'EXPIRED') {
          await prisma.potentialMatch.update({
            where: { id: existing.id },
            data: {
              aiScore: score,
              firstPassScore: match.firstPassScore || null,
              scoreBreakdown: match.scoreBreakdown || null,
              shortReasoning: match.shortReasoning || match.reasoning || null,
              detailedReasoning: match.detailedReasoning || null,
              backgroundCompatibility: match.backgroundCompatibility || null,
              backgroundMultiplier: match.backgroundMultiplier || null,
              scannedAt: new Date(),
              status: existing.status === 'EXPIRED' ? 'PENDING' : existing.status,
            }
          });
          updated++;
        }
      } else {
        // ×™×¦×™×¨×ª ×”×ª×××” ×—×“×©×”
        await prisma.potentialMatch.create({
          data: {
            maleUserId,
            femaleUserId,
            aiScore: score,
            firstPassScore: match.firstPassScore || null,
            scoreBreakdown: match.scoreBreakdown || null,
            shortReasoning: match.shortReasoning || match.reasoning || null,
            detailedReasoning: match.detailedReasoning || null,
            backgroundCompatibility: match.backgroundCompatibility || null,
            backgroundMultiplier: match.backgroundMultiplier || null,
            status: 'PENDING',
            scannedAt: new Date(),
          }
        });
        saved++;
      }
    } catch (err) {
      // ×”×ª×¢×œ× ××©×’×™××•×ª ×™×—×™×“×•×ª (××©×ª××© × ××—×§ ×•×›×•')
      console.warn(`[ProcessJob] Could not save match:`, err);
    }
  }

  console.log(`[ProcessJob] ğŸ’¾ PotentialMatch: ${saved} new, ${updated} updated`);
}

// ============================================================================
// GET - Health Check
// ============================================================================

export async function GET(req: NextRequest): Promise<NextResponse> {
  return NextResponse.json({
    status: "healthy",
    service: "process-matching-job",
    version: "4.2", // ğŸ†• ×¢×•×“×›×Ÿ
    features: [
      "Background job processing",
      "Saves to PotentialMatch for dashboard display" // ğŸ†•
    ],
    note: "Virtual searches are now processed directly in find-matches-v2",
    timestamp: new Date().toISOString()
  });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\scan-user
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\scan-user\route.ts
--------------------------------------------------------------------------------
Content:
// =============================================================================
// ğŸ“ src/app/api/ai/scan-user/route.ts
// =============================================================================
// ğŸ¯ Scan User - ×¡×¨×™×§×” ×™×“× ×™×ª ×œ×™×•×–×¨ ×‘×•×“×“
// 
// ×’×¨×¡×”: 2.0 - ×¡×¨×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª
// 
// ×©×™×¤×•×¨×™×:
// 1. ×¡×¨×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª - ×¡×•×¨×§ ×¨×§ ××•×¢××“×•×ª ×—×“×©×•×ª/××¢×•×“×›× ×•×ª
// 2. ×¤×™×œ×˜×¨ ×”×™×¡×˜×•×¨×™×” - ×œ× ××¦×™×¢ ×–×•×’×•×ª ×¢× ×“×™×™×˜ ×›×•×©×œ
// 3. ×©××™×¨×” ×‘-ScannedPair - ×œ×›×œ ×–×•×’ ×©× ×¡×¨×§
// =============================================================================

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { AvailabilityStatus } from "@prisma/client";
import {
  findMatchesForUser,
  calculateAge,
  getCompatibleReligiousLevels,
} from "@/lib/services/matchingAlgorithmService";
import {
  getFemalesToScan,
  filterBlockedFemales,
  saveScannedPairsBatch,
  getActiveUsersWhereClause,
  type ScannedPairResult,
} from "@/lib/services/matchingAlgorithmService";

export const dynamic = 'force-dynamic';
export const maxDuration = 120; // 2 ×“×§×•×ª

// =============================================================================
// Constants
// =============================================================================

const MIN_SCORE_THRESHOLD = 70;

// =============================================================================
// POST - ×¡×¨×™×§×” ×™×“× ×™×ª ×œ×™×•×–×¨
// =============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  const startTime = Date.now();

  try {
    // ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { 
      userId,  // ×”×™×•×–×¨ ×©×¨×•×¦×™× ×œ×¡×¨×•×§ ×¢×‘×•×¨×•
      forceRefresh = false,  // ×× true - ××ª×¢×œ× ××¡×¨×™×§×•×ª ×§×•×“××•×ª
      method = 'algorithmic',
    } = body;

    if (!userId) {
      return NextResponse.json({ 
        error: "userId is required" 
      }, { status: 400 });
    }

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[ScanUser] ğŸ” Starting scan for user: ${userId}`);
    console.log(`[ScanUser] Force Refresh: ${forceRefresh}`);
    console.log(`${'='.repeat(60)}\n`);

    // ×©×œ×™×¤×ª ×¤×¨×˜×™ ×”×™×•×–×¨
    const targetUser = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        profile: {
          select: {
            gender: true,
            birthDate: true,
            religiousLevel: true,
            updatedAt: true,
            availabilityStatus: true,
          }
        }
      }
    });

    if (!targetUser || !targetUser.profile) {
      return NextResponse.json({ 
        error: "User not found or has no profile" 
      }, { status: 404 });
    }

    // ×‘×“×™×§×” ×©×–×” ×’×‘×¨ (×”×¡×¨×™×§×” ××›×™×•×•×Ÿ ×”×’×‘×¨×™×)
    if (targetUser.profile.gender !== 'MALE') {
      // ×× ×–×• ×‘×—×•×¨×” - ×¦×¨×™×š ×œ×¡×¨×•×§ ××ª ×›×œ ×”×’×‘×¨×™× ××•×œ×”
      // ×–×” ×™×•×ª×¨ ×™×§×¨ ××‘×œ ××¤×©×¨×™
      console.log(`[ScanUser] Target is female - scanning all males against her`);
      
      const result = await scanFemaleUser(
        targetUser,
        session.user.id,
        forceRefresh
      );

      const duration = Date.now() - startTime;
      return NextResponse.json({
        success: true,
        userId,
        matchesFound: result.matchesFound,
        newMatches: result.newMatches,
        pairsScanned: result.pairsScanned,
        skippedByHistory: result.skippedByHistory,
        skippedByNoChange: result.skippedByNoChange,
        duration: `${(duration / 1000).toFixed(1)}s`,
      });
    }

    // ×¡×¨×™×§×” ×¨×’×™×œ×” ×œ×’×‘×¨
    const result = await scanMaleUser(
      targetUser,
      session.user.id,
      forceRefresh
    );

    const duration = Date.now() - startTime;

    console.log(`\n${'='.repeat(60)}`);
    console.log(`[ScanUser] âœ… Scan completed for ${targetUser.firstName} ${targetUser.lastName}`);
    console.log(`[ScanUser] Duration: ${(duration / 1000).toFixed(1)}s`);
    console.log(`[ScanUser] Pairs scanned: ${result.pairsScanned}`);
    console.log(`[ScanUser] Matches found: ${result.matchesFound}`);
    console.log(`[ScanUser] New matches: ${result.newMatches}`);
    console.log(`${'='.repeat(60)}\n`);

    return NextResponse.json({
      success: true,
      userId,
      matchesFound: result.matchesFound,
      newMatches: result.newMatches,
      pairsScanned: result.pairsScanned,
      skippedByHistory: result.skippedByHistory,
      skippedByNoChange: result.skippedByNoChange,
      duration: `${(duration / 1000).toFixed(1)}s`,
    });

  } catch (error) {
    console.error('[ScanUser] Error:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Scan failed'
    }, { status: 500 });
  }
}

// =============================================================================
// ×¡×¨×™×§×ª ×’×‘×¨ - ××•×œ ×›×œ ×”×‘×—×•×¨×•×ª ×”×¨×œ×•×•× ×˜×™×•×ª
// =============================================================================

async function scanMaleUser(
  targetUser: {
    id: string;
    firstName: string;
    lastName: string;
    profile: {
      gender: string;
      birthDate: Date | null;
      religiousLevel: string | null;
      updatedAt: Date;
    } | null;
  },
  matchmakerId: string,
  forceRefresh: boolean
): Promise<{
  matchesFound: number;
  newMatches: number;
  pairsScanned: number;
  skippedByHistory: number;
  skippedByNoChange: number;
}> {
  if (!targetUser.profile?.birthDate) {
    throw new Error('Target user has no birth date');
  }

  const maleAge = calculateAge(targetUser.profile.birthDate);
  const maleReligiousLevel = targetUser.profile.religiousLevel;
  const maleProfileUpdatedAt = targetUser.profile.updatedAt;

  console.log(`[ScanUser] Male: ${targetUser.firstName} ${targetUser.lastName}`);
  console.log(`[ScanUser] Age: ${maleAge}, Religious: ${maleReligiousLevel}`);

  // ×©×œ×™×¤×ª ×›×œ ×”×‘×—×•×¨×•×ª ×”×¤×¢×™×œ×•×ª
  const allFemales = await prisma.user.findMany({
    where: {
      ...getActiveUsersWhereClause(),
      profile: {
        gender: 'FEMALE',
        availabilityStatus: AvailabilityStatus.AVAILABLE,
        isProfileVisible: true,
        OR: [
          { about: { not: null } },
          { manualEntryText: { not: null } },
        ]
      }
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      profile: {
        select: {
          birthDate: true,
          religiousLevel: true,
          updatedAt: true,
        }
      }
    }
  });

  console.log(`[ScanUser] Total females found: ${allFemales.length}`);

  // ×¡×™× ×•×Ÿ ×¨××©×•× ×™ ×œ×¤×™ ×’×™×œ ×•×¨××” ×“×ª×™×ª
  const compatibleReligious = getCompatibleReligiousLevels(maleReligiousLevel);
  
  const relevantFemales = allFemales.filter(female => {
    if (!female.profile) return false;
    
    // ×¡×™× ×•×Ÿ ×¨××” ×“×ª×™×ª (×¡×œ×—× ×™)
    if (female.profile.religiousLevel && 
        !compatibleReligious.includes(female.profile.religiousLevel)) {
      return false;
    }

    // ×¡×™× ×•×Ÿ ×’×™×œ (×¡×œ×—× ×™)
    if (female.profile.birthDate) {
      const femaleAge = calculateAge(female.profile.birthDate);
      const minAge = maleAge - 7;
      const maxAge = maleAge + 4;
      if (femaleAge < minAge || femaleAge > maxAge) {
        return false;
      }
    }

    return true;
  }).map(f => ({
    id: f.id,
    profileUpdatedAt: f.profile!.updatedAt,
  }));

  console.log(`[ScanUser] Relevant females after basic filter: ${relevantFemales.length}`);

  // ×¡×¨×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª
  let femalesToScan: string[];
  let skippedByHistory = 0;
  let skippedByNoChange = 0;

  if (forceRefresh) {
    // ×× force refresh - ×¡×•×¨×§ ××ª ×›×•×œ×Ÿ (××‘×œ ×¢×“×™×™×Ÿ ××¡× ×Ÿ ×”×™×¡×˜×•×¨×™×”)
    const { allowedIds, blockedPairs } = await filterBlockedFemales(
      targetUser.id, 
      relevantFemales.map(f => f.id)
    );
    femalesToScan = allowedIds;
    skippedByHistory = blockedPairs.size;
    skippedByNoChange = 0;
  } else {
    // ×¡×¨×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª ××œ××”
    const scanResult = await getFemalesToScan(
      targetUser.id,
      maleProfileUpdatedAt,
      relevantFemales
    );
    femalesToScan = scanResult.femalesToScan;
    skippedByHistory = scanResult.skippedByHistory;
    skippedByNoChange = scanResult.skippedByNoChange;
  }

  console.log(`[ScanUser] Females to scan: ${femalesToScan.length}`);
  console.log(`[ScanUser] Skipped by history: ${skippedByHistory}`);
  console.log(`[ScanUser] Skipped by no change: ${skippedByNoChange}`);

  if (femalesToScan.length === 0) {
    return {
      matchesFound: 0,
      newMatches: 0,
      pairsScanned: 0,
      skippedByHistory,
      skippedByNoChange,
    };
  }

  // ×”×¤×¢×œ×ª ×”××œ×’×•×¨×™×ª×
  const result = await findMatchesForUser(targetUser.id, matchmakerId, {
    forceRefresh: true,
    autoSave: false,
  });

  // ×¢×™×‘×•×“ ×”×ª×•×¦××•×ª
  let matchesFound = 0;
  let newMatches = 0;
  const scannedPairsToSave: ScannedPairResult[] = [];

  for (const match of result.matches) {
    const score = match.finalScore || 0;
    const passedThreshold = score >= MIN_SCORE_THRESHOLD;
    
    const femaleData = relevantFemales.find(f => f.id === match.userId);
    if (femaleData) {
      scannedPairsToSave.push({
        maleUserId: targetUser.id,
        femaleUserId: match.userId,
        aiScore: score,
        passedThreshold,
        rejectionReason: passedThreshold ? null : 'low_ai_score',
        maleProfileUpdatedAt,
        femaleProfileUpdatedAt: femaleData.profileUpdatedAt,
      });
    }

    if (passedThreshold) {
      matchesFound++;
      
      // ×©××™×¨×” ×‘-PotentialMatch
      const saved = await saveToPotentialMatch(targetUser.id, match.userId, match);
      if (saved === 'new') newMatches++;
    }
  }

  // ×©××™×¨×ª ScannedPairs
  await saveScannedPairsBatch(scannedPairsToSave);

  return {
    matchesFound,
    newMatches,
    pairsScanned: femalesToScan.length,
    skippedByHistory,
    skippedByNoChange,
  };
}

// =============================================================================
// ×¡×¨×™×§×ª ×‘×—×•×¨×” - ×›×œ ×”×’×‘×¨×™× ××•×œ×”
// =============================================================================

async function scanFemaleUser(
  targetUser: {
    id: string;
    firstName: string;
    lastName: string;
    profile: {
      gender: string;
      birthDate: Date | null;
      religiousLevel: string | null;
      updatedAt: Date;
    } | null;
  },
  matchmakerId: string,
  forceRefresh: boolean
): Promise<{
  matchesFound: number;
  newMatches: number;
  pairsScanned: number;
  skippedByHistory: number;
  skippedByNoChange: number;
}> {
  if (!targetUser.profile?.birthDate) {
    throw new Error('Target user has no birth date');
  }

  const femaleAge = calculateAge(targetUser.profile.birthDate);
  const femaleReligiousLevel = targetUser.profile.religiousLevel;
  const femaleProfileUpdatedAt = targetUser.profile.updatedAt;

  console.log(`[ScanUser] Female: ${targetUser.firstName} ${targetUser.lastName}`);
  console.log(`[ScanUser] Age: ${femaleAge}, Religious: ${femaleReligiousLevel}`);

  // ×©×œ×™×¤×ª ×›×œ ×”×’×‘×¨×™× ×”×¤×¢×™×œ×™×
  const allMales = await prisma.user.findMany({
    where: {
      ...getActiveUsersWhereClause(),
      profile: {
        gender: 'MALE',
        availabilityStatus: AvailabilityStatus.AVAILABLE,
        isProfileVisible: true,
        OR: [
          { about: { not: null } },
          { manualEntryText: { not: null } },
        ]
      }
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      profile: {
        select: {
          birthDate: true,
          religiousLevel: true,
          updatedAt: true,
        }
      }
    }
  });

  console.log(`[ScanUser] Total males found: ${allMales.length}`);

  // ×¡×™× ×•×Ÿ ×¨××©×•× ×™
  const compatibleReligious = getCompatibleReligiousLevels(femaleReligiousLevel);
  
  const relevantMales = allMales.filter(male => {
    if (!male.profile) return false;
    
    if (male.profile.religiousLevel && 
        !compatibleReligious.includes(male.profile.religiousLevel)) {
      return false;
    }

    if (male.profile.birthDate) {
      const maleAge = calculateAge(male.profile.birthDate);
      // ×œ×‘×—×•×¨×”: ×’×‘×¨ ×™×›×•×œ ×œ×”×™×•×ª ×¢×“ 7 ×©× ×™× ×™×•×ª×¨ ×’×“×•×œ, ××• ×¢×“ 4 ×©× ×™× ×™×•×ª×¨ ×¦×¢×™×¨
      const minAge = femaleAge - 4;
      const maxAge = femaleAge + 7;
      if (maleAge < minAge || maleAge > maxAge) {
        return false;
      }
    }

    return true;
  });

  console.log(`[ScanUser] Relevant males after basic filter: ${relevantMales.length}`);

  // ×¡×™× ×•×Ÿ ×”×™×¡×˜×•×¨×™×” - ×¦×¨×™×š ×œ×¡× ×Ÿ ×”×¤×•×š (×”×’×‘×¨×™× ××•×œ ×”×‘×—×•×¨×”)
  const maleIds = relevantMales.map(m => m.id);
  
  // ×©×œ×™×¤×ª ×–×•×’×•×ª ×—×¡×•××™×
  const blockedSuggestions = await prisma.matchSuggestion.findMany({
    where: {
      status: { in: ['ENDED_AFTER_FIRST_DATE', 'MATCH_DECLINED', 'FIRST_PARTY_DECLINED', 'SECOND_PARTY_DECLINED', 'CLOSED', 'CANCELLED', 'EXPIRED'] },
      OR: [
        { firstPartyId: targetUser.id, secondPartyId: { in: maleIds } },
        { firstPartyId: { in: maleIds }, secondPartyId: targetUser.id },
      ]
    },
    select: { firstPartyId: true, secondPartyId: true }
  });

  const dismissedMatches = await prisma.potentialMatch.findMany({
    where: {
      femaleUserId: targetUser.id,
      maleUserId: { in: maleIds },
      status: 'DISMISSED'
    },
    select: { maleUserId: true }
  });

  const blockedMaleIds = new Set<string>();
  for (const s of blockedSuggestions) {
    const maleId = s.firstPartyId === targetUser.id ? s.secondPartyId : s.firstPartyId;
    blockedMaleIds.add(maleId);
  }
  for (const m of dismissedMatches) {
    blockedMaleIds.add(m.maleUserId);
  }

  const skippedByHistory = blockedMaleIds.size;

  // ×¡×¨×™×§×” ×“×™×¤×¨× ×¦×™××œ×™×ª
  const existingPairs = forceRefresh ? [] : await prisma.scannedPair.findMany({
    where: {
      femaleUserId: targetUser.id,
      maleUserId: { in: maleIds.filter(id => !blockedMaleIds.has(id)) }
    },
    select: {
      maleUserId: true,
      maleProfileUpdatedAt: true,
      femaleProfileUpdatedAt: true,
    }
  });

  const existingPairsMap = new Map(existingPairs.map(p => [p.maleUserId, p]));
  
  const malesToScan: string[] = [];
  let skippedByNoChange = 0;

  for (const male of relevantMales) {
    if (blockedMaleIds.has(male.id)) continue;
    
    const existing = existingPairsMap.get(male.id);
    if (!existing) {
      malesToScan.push(male.id);
      continue;
    }

    // ×‘×“×™×§×” ×× ×¢×•×“×›×Ÿ
    const maleUpdated = existing.maleProfileUpdatedAt 
      ? male.profile!.updatedAt > existing.maleProfileUpdatedAt
      : true;
    const femaleUpdated = existing.femaleProfileUpdatedAt
      ? femaleProfileUpdatedAt > existing.femaleProfileUpdatedAt
      : true;

    if (maleUpdated || femaleUpdated) {
      malesToScan.push(male.id);
    } else {
      skippedByNoChange++;
    }
  }

  console.log(`[ScanUser] Males to scan: ${malesToScan.length}`);
  console.log(`[ScanUser] Skipped by history: ${skippedByHistory}`);
  console.log(`[ScanUser] Skipped by no change: ${skippedByNoChange}`);

  if (malesToScan.length === 0) {
    return {
      matchesFound: 0,
      newMatches: 0,
      pairsScanned: 0,
      skippedByHistory,
      skippedByNoChange,
    };
  }

  // ×”×¤×¢×œ×ª ×”××œ×’×•×¨×™×ª×
  const result = await findMatchesForUser(targetUser.id, matchmakerId, {
    forceRefresh: true,
    autoSave: false,
  });

  // ×¢×™×‘×•×“ ×”×ª×•×¦××•×ª
  let matchesFound = 0;
  let newMatches = 0;
  const scannedPairsToSave: ScannedPairResult[] = [];

  for (const match of result.matches) {
    const score = match.finalScore || 0;
    const passedThreshold = score >= MIN_SCORE_THRESHOLD;
    
    const maleData = relevantMales.find(m => m.id === match.userId);
    if (maleData) {
      scannedPairsToSave.push({
        maleUserId: match.userId,
        femaleUserId: targetUser.id,
        aiScore: score,
        passedThreshold,
        rejectionReason: passedThreshold ? null : 'low_ai_score',
        maleProfileUpdatedAt: maleData.profile!.updatedAt,
        femaleProfileUpdatedAt,
      });
    }

    if (passedThreshold) {
      matchesFound++;
      
      const saved = await saveToPotentialMatch(match.userId, targetUser.id, match);
      if (saved === 'new') newMatches++;
    }
  }

  await saveScannedPairsBatch(scannedPairsToSave);

  return {
    matchesFound,
    newMatches,
    pairsScanned: malesToScan.length,
    skippedByHistory,
    skippedByNoChange,
  };
}

// =============================================================================
// Helper: ×©××™×¨×” ×‘-PotentialMatch
// =============================================================================

async function saveToPotentialMatch(
  maleUserId: string,
  femaleUserId: string,
  match: any
): Promise<'new' | 'updated' | 'unchanged'> {
  const score = match.finalScore || match.score || 0;

  try {
    const existing = await prisma.potentialMatch.findUnique({
      where: {
        maleUserId_femaleUserId: { maleUserId, femaleUserId }
      }
    });

    if (existing) {
      if (Math.abs(existing.aiScore - score) > 2 || existing.status === 'EXPIRED') {
        await prisma.potentialMatch.update({
          where: { id: existing.id },
          data: {
            aiScore: score,
            firstPassScore: match.firstPassScore || null,
            scoreBreakdown: match.scoreBreakdown || null,
            shortReasoning: match.shortReasoning || match.reasoning || null,
            detailedReasoning: match.detailedReasoning || null,
            backgroundCompatibility: match.backgroundCompatibility || null,
            backgroundMultiplier: match.backgroundMultiplier || null,
            scannedAt: new Date(),
            status: existing.status === 'EXPIRED' ? 'PENDING' : existing.status,
          }
        });
        return 'updated';
      }
      return 'unchanged';
    }

    await prisma.potentialMatch.create({
      data: {
        maleUserId,
        femaleUserId,
        aiScore: score,
        firstPassScore: match.firstPassScore || null,
        scoreBreakdown: match.scoreBreakdown || null,
        shortReasoning: match.shortReasoning || match.reasoning || null,
        detailedReasoning: match.detailedReasoning || null,
        backgroundCompatibility: match.backgroundCompatibility || null,
        backgroundMultiplier: match.backgroundMultiplier || null,
        status: 'PENDING',
        scannedAt: new Date(),
      }
    });
    return 'new';

  } catch (error) {
    console.warn(`[ScanUser] Could not save PotentialMatch:`, error);
    return 'unchanged';
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/test-connection/route.ts

import { NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function GET() {
  console.log('--- [API TEST] Received request at /api/ai/test-connection ---');

  const apiKey = process.env.GOOGLE_API_KEY;

  if (!apiKey) {
    console.error('--- [API TEST] FATAL ERROR: GOOGLE_API_KEY is not set in .env or .env.local!');
    return NextResponse.json(
      { success: false, error: 'Server configuration error: GOOGLE_API_KEY is missing.' },
      { status: 500 }
    );
  }

  // --- ×§×˜×¢ ×”××™××•×ª ×©×”×•×¡×¤× ×• ---
  const keyIdentifier = `Starts with: ${apiKey.substring(0, 5)}... | Ends with: ...${apiKey.substring(apiKey.length - 4)} | Length: ${apiKey.length}`; // <-- ×”×•×¡×£
  console.log(`--- [API TEST] Verifying the loaded API Key: ${keyIdentifier} ---`); // <-- ×”×•×¡×£
  // -----------------------------

  console.log('--- [API TEST] GOOGLE_API_KEY found. Proceeding with API call.');

  try {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' }); 
    const prompt = 'Say "Connection Successful" in one sentence.';

    console.log('--- [API TEST] Sending a simple prompt to Google AI...');
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    console.log('--- [API TEST] SUCCESS! Google AI responded:', text);
    return NextResponse.json({ success: true, message: 'Connection to Google AI is working!', response: text });

  } catch (error) {
    console.error('--- [API TEST] FAILED! The API call to Google threw an error.', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to connect to Google AI. This is likely an API key, permissions, or billing issue.',
        details: JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×©××¨×™×¦×” ××ª ×ª×”×œ×™×š ×”×¢×“×›×•×Ÿ ×‘×¨×§×¢
 * ×•××“×¤×™×¡×” ×œ×•×’ ××¤×•×¨×˜ ×‘×¡×™×•××•.
 * @param userIds - ××¢×¨×š ××–×”×™ ×”××©×ª××©×™× ×œ×¢×“×›×•×Ÿ
 * @param adminId - ××–×”×” ×”××“××™×Ÿ ×©×”×¤×¢×™×œ ××ª ×”×ª×”×œ×™×š
 */
async function runBulkUpdateAndLog(userIds: string[]) {
  const totalUsers = userIds.length;
  // ×”×•×“×¢×ª ×”×ª×—×œ×” ×‘×¨×•×¨×” ×œ×ª×”×œ×™×š ×”×¨×§×¢
 
  try {
    // × ×©×ª××© ×‘-Promise.allSettled ×›×“×™ ×œ×”××ª×™×Ÿ ×œ×¡×™×•× ×›×œ ×”×¢×“×›×•× ×™×, ×’× ×× ×—×œ×§× × ×›×©×œ×™×
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // ××™×¡×•×£ ××–×”×™ ×”××©×ª××©×™× ×©× ×›×©×œ×• (×× ×™×© ×›××œ×”)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // ×”×“×¤×¡×ª ×¡×™×›×•× ××¤×•×¨×˜
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // ×‘××§×¨×” ×©×œ ×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ×”×¨×§×¢ ×¢×¦××•
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // ×›××Ÿ ×”×œ×•×’ ×”××§×•×¨×™ × ×©××¨, ×›×“×™ ×©×ª×¨××” ×©×”-API ×”×•×¤×¢×œ
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\virtual-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\virtual-profile\route.ts
--------------------------------------------------------------------------------
Content:
// ===========================================
// ×§×•×‘×¥ ×—×“×©: src/app/api/ai/virtual-profile/route.ts
// ===========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole, Gender } from "@prisma/client";
import prisma from "@/lib/prisma";
import aiService from "@/lib/services/aiService";

export const dynamic = 'force-dynamic';

// ============================================================================
// POST - ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ ×•×™×¨×˜×•××œ×™ ×—×“×©
// ============================================================================

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™×
    const body = await req.json();
    const { sourceText, gender, religiousLevel, name } = body;

    // 3. ×•×œ×™×“×¦×™×”
    if (!sourceText || typeof sourceText !== 'string' || sourceText.trim().length < 20) {
      return NextResponse.json({ 
        success: false, 
        message: 'sourceText is required and must be at least 20 characters.' 
      }, { status: 400 });
    }

    if (!gender || !['MALE', 'FEMALE'].includes(gender)) {
      return NextResponse.json({ 
        success: false, 
        message: 'gender is required and must be MALE or FEMALE.' 
      }, { status: 400 });
    }

    if (!religiousLevel || typeof religiousLevel !== 'string') {
      return NextResponse.json({ 
        success: false, 
        message: 'religiousLevel is required.' 
      }, { status: 400 });
    }

    console.log(`[Virtual Profile API] Creating profile for matchmaker: ${session.user.email}`);
    console.log(`[Virtual Profile API] Gender: ${gender}, Religious: ${religiousLevel}`);

    // 4. ×™×¦×™×¨×ª ×”×¤×¨×•×¤×™×œ ×‘×××¦×¢×•×ª AI
    const generatedProfile = await aiService.generateVirtualProfile(
      sourceText.trim(),
      gender as 'MALE' | 'FEMALE',
      religiousLevel
    );

    if (!generatedProfile) {
      return NextResponse.json({ 
        success: false, 
        message: 'Failed to generate virtual profile. Please try again.' 
      }, { status: 500 });
    }

    // 5. ×™×¦×™×¨×ª ×•×§×˜×•×¨ ××”×¡×™×›×•× (×œ×—×™×¤×•×© ×•×§×˜×•×¨×™)
    const textForEmbedding = `
      ${generatedProfile.personalitySummary}
      ${generatedProfile.lookingForSummary}
      ×ª×›×•× ×•×ª: ${generatedProfile.keyTraits?.join(', ') || ''}
      ××—×¤×©: ${generatedProfile.idealPartnerTraits?.join(', ') || ''}
    `;
    
    const vector = await aiService.generateTextEmbedding(textForEmbedding);

    // 6. ×©××™×¨×” ×‘-DB
    const virtualProfile = await prisma.virtualProfile.create({
      data: {
        matchmakerId,
        name: name?.trim() || null,
        sourceText: sourceText.trim(),
        gender: gender as Gender,
        religiousLevel,
        generatedProfile: generatedProfile as any,
        // ×”×•×§×˜×•×¨ ×™×™×©××¨ ×‘× ×¤×¨×“ ×× × ×“×¨×© (pgvector)
      },
    });

    // 6.1 ×©××™×¨×ª ×”×•×§×˜×•×¨ (×× × ×•×¦×¨ ×‘×”×¦×œ×—×”)
    if (vector && vector.length === 768) {
      try {
        const vectorSqlString = `[${vector.join(',')}]`;
        await prisma.$executeRaw`
          UPDATE "VirtualProfile"
          SET vector = ${vectorSqlString}::vector
          WHERE id = ${virtualProfile.id}
        `;
        console.log(`[Virtual Profile API] Vector saved successfully`);
      } catch (vectorError) {
        console.error(`[Virtual Profile API] Failed to save vector:`, vectorError);
        // ×œ× × ×›×©×™×œ ××ª ×›×œ ×”×‘×§×©×” ×‘×’×œ×œ ×”×•×§×˜×•×¨
      }
    }

    console.log(`[Virtual Profile API] âœ… Created profile: ${virtualProfile.id}`);

    // 7. ×”×—×–×¨×ª ×”×ª×•×¦××”
    return NextResponse.json({
      success: true,
      virtualProfile: {
        id: virtualProfile.id,
        name: virtualProfile.name,
        gender: virtualProfile.gender,
        religiousLevel: virtualProfile.religiousLevel,
        generatedProfile,
        createdAt: virtualProfile.createdAt,
      }
    });

  } catch (error) {
    console.error('[Virtual Profile API] POST Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error',
      details: errorMessage 
    }, { status: 500 });
  }
}

// ============================================================================
// GET - ×©×œ×™×¤×ª ×¤×¨×•×¤×™×œ×™× ×•×™×¨×˜×•××œ×™×™× ×©××•×¨×™×
// ============================================================================

export async function GET(req: NextRequest) {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;
    const { searchParams } = new URL(req.url);
    
    // ×¤×¨××˜×¨×™× ××•×¤×¦×™×•× ×œ×™×™×
    const starred = searchParams.get('starred') === 'true';
    const profileId = searchParams.get('id');

    // 2. ×©×œ×™×¤×ª ×¤×¨×•×¤×™×œ ×‘×•×“×“
    if (profileId) {
      const profile = await prisma.virtualProfile.findFirst({
        where: {
          id: profileId,
          matchmakerId, // ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×©×™×™×š ×œ×©×“×›×Ÿ ×”×–×”
        },
      });

      if (!profile) {
        return NextResponse.json({ 
          success: false, 
          message: 'Profile not found' 
        }, { status: 404 });
      }

      return NextResponse.json({
        success: true,
        virtualProfile: profile,
      });
    }

    // 3. ×©×œ×™×¤×ª ×¨×©×™××ª ×¤×¨×•×¤×™×œ×™×
    const whereClause: any = { matchmakerId };
    if (starred) {
      whereClause.isStarred = true;
    }

    const profiles = await prisma.virtualProfile.findMany({
      where: whereClause,
      orderBy: [
        { isStarred: 'desc' },
        { lastUsedAt: 'desc' },
        { createdAt: 'desc' },
      ],
      select: {
        id: true,
        name: true,
        gender: true,
        religiousLevel: true,
        generatedProfile: true,
        editedSummary: true,
        wasEdited: true,
        isStarred: true,
        lastUsedAt: true,
        usageCount: true,
        createdAt: true,
      },
      take: 50, // ××§×¡×™××•× 50 ×¤×¨×•×¤×™×œ×™×
    });

    return NextResponse.json({
      success: true,
      profiles,
      count: profiles.length,
    });

  } catch (error) {
    console.error('[Virtual Profile API] GET Error:', error);
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error' 
    }, { status: 500 });
  }
}

// ============================================================================
// PATCH - ×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ (×©×, ×›×•×›×‘, ×¡×™×›×•× ×¢×¨×•×š)
// ============================================================================

export async function PATCH(req: NextRequest) {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™×
    const body = await req.json();
    const { id, name, isStarred, editedSummary, markAsUsed } = body;

    if (!id || typeof id !== 'string') {
      return NextResponse.json({ 
        success: false, 
        message: 'id is required' 
      }, { status: 400 });
    }

    // 3. ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×©×™×™×š ×œ×©×“×›×Ÿ
    const existingProfile = await prisma.virtualProfile.findFirst({
      where: { id, matchmakerId },
    });

    if (!existingProfile) {
      return NextResponse.json({ 
        success: false, 
        message: 'Profile not found or access denied' 
      }, { status: 404 });
    }

    // 4. ×‘× ×™×™×ª ××•×‘×™×™×§×˜ ×”×¢×“×›×•×Ÿ
    const updateData: any = {};

    if (name !== undefined) {
      updateData.name = name?.trim() || null;
    }

    if (isStarred !== undefined) {
      updateData.isStarred = Boolean(isStarred);
    }

    if (editedSummary !== undefined) {
      updateData.editedSummary = editedSummary?.trim() || null;
      updateData.wasEdited = Boolean(editedSummary?.trim());
      
      // ×× ×”×¡×™×›×•× ×¢×•×“×›×Ÿ, × ×™×¦×•×¨ ×•×§×˜×•×¨ ×—×“×©
      if (editedSummary?.trim()) {
        const newVector = await aiService.generateTextEmbedding(editedSummary.trim());
        if (newVector && newVector.length === 768) {
          try {
            const vectorSqlString = `[${newVector.join(',')}]`;
            await prisma.$executeRaw`
              UPDATE "VirtualProfile"
              SET vector = ${vectorSqlString}::vector
              WHERE id = ${id}
            `;
          } catch (vectorError) {
            console.error(`[Virtual Profile API] Failed to update vector:`, vectorError);
          }
        }
      }
    }

    if (markAsUsed) {
      updateData.lastUsedAt = new Date();
      updateData.usageCount = { increment: 1 };
    }

    // 5. ×‘×™×¦×•×¢ ×”×¢×“×›×•×Ÿ
    const updatedProfile = await prisma.virtualProfile.update({
      where: { id },
      data: updateData,
    });

    console.log(`[Virtual Profile API] âœ… Updated profile: ${id}`);

    return NextResponse.json({
      success: true,
      virtualProfile: updatedProfile,
    });

  } catch (error) {
    console.error('[Virtual Profile API] PATCH Error:', error);
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error' 
    }, { status: 500 });
  }
}

// ============================================================================
// DELETE - ××—×™×§×ª ×¤×¨×•×¤×™×œ
// ============================================================================

export async function DELETE(req: NextRequest) {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || 
        (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ 
        success: false, 
        message: 'Unauthorized' 
      }, { status: 401 });
    }

    const matchmakerId = session.user.id;
    const { searchParams } = new URL(req.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json({ 
        success: false, 
        message: 'id is required' 
      }, { status: 400 });
    }

    // 2. ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×©×™×™×š ×œ×©×“×›×Ÿ ×•××—×™×§×”
    const deletedProfile = await prisma.virtualProfile.deleteMany({
      where: { 
        id, 
        matchmakerId 
      },
    });

    if (deletedProfile.count === 0) {
      return NextResponse.json({ 
        success: false, 
        message: 'Profile not found or access denied' 
      }, { status: 404 });
    }

    console.log(`[Virtual Profile API] âœ… Deleted profile: ${id}`);

    return NextResponse.json({
      success: true,
      message: 'Profile deleted successfully',
    });

  } catch (error) {
    console.error('[Virtual Profile API] DELETE Error:', error);
    return NextResponse.json({ 
      success: false, 
      message: 'Internal server error' 
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

