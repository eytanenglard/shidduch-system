################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile
# Generated on: 2026-02-13 14:20:07
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\mobile_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\google
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\google\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/google/route.ts
// התחברות עם Google למובייל
// נתיב: POST /api/mobile/google

import { NextRequest } from "next/server";
import { OAuth2Client } from "google-auth-library";
import prisma from "@/lib/prisma";
import { 
  createMobileToken, 
  formatUserForMobile,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

const googleClient = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function POST(req: NextRequest) {
  try {
    const { idToken } = await req.json();

    if (!idToken) {
      return corsError(req, "ID token is required", 400);
    }

    let payload;
    try {
      const ticket = await googleClient.verifyIdToken({
        idToken,
        audience: [
          process.env.GOOGLE_CLIENT_ID!,
          process.env.GOOGLE_IOS_CLIENT_ID,
          process.env.GOOGLE_ANDROID_CLIENT_ID,
          process.env.EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID,
          process.env.EXPO_PUBLIC_GOOGLE_ANDROID_CLIENT_ID,
          // Fallback - הוספת ה-Client IDs הספציפיים במקרה שהמשתנים לא הוגדרו
          "1034451392663-hquqkr5l6fse3onvj31fi2lbfkitvv6a.apps.googleusercontent.com", // iOS
          "1034451392663-s07vnc13rnssjqhjrk6knnqrnkmqi43i.apps.googleusercontent.com", // Android
        ].filter(Boolean) as string[],
      });
      payload = ticket.getPayload();
    } catch (error) {
      console.error("[mobile/google] Google token verification failed:", error);
      console.error("[mobile/google] Attempted audiences:", [
        process.env.GOOGLE_CLIENT_ID,
        process.env.GOOGLE_IOS_CLIENT_ID,
        process.env.GOOGLE_ANDROID_CLIENT_ID,
        process.env.EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID,
        process.env.EXPO_PUBLIC_GOOGLE_ANDROID_CLIENT_ID,
      ].filter(Boolean));
      return corsError(req, "Invalid Google token", 401);
    }

    if (!payload || !payload.email) {
      return corsError(req, "Could not get email from Google", 401);
    }

    // בדיקה אם המשתמש קיים במערכת
    const user = await prisma.user.findUnique({
      where: { email: payload.email.toLowerCase() },
    });

    if (!user) {
      // אפשרות 1: החזר שגיאה שהמשתמש צריך להירשם באתר קודם
      return corsJson(req, { 
        success: false, 
        error: "Account not found. Please register at neshamatech.com first.",
        errorCode: "USER_NOT_FOUND"
      }, { status: 404 });

      // אפשרות 2: צור משתמש חדש אוטומטית (אם תרצה לאפשר רישום דרך האפליקציה)
      // הערה: קטע זה מוכן אך מנוטרל. הסר את הערות ה-comment כדי להפעיל
      /*
      const firstName = payload.given_name || "";
      const lastName = payload.family_name || "";
      
      user = await prisma.user.create({
        data: {
          email: payload.email.toLowerCase(),
          firstName,
          lastName,
          name: payload.name || `${firstName} ${lastName}`.trim(),
          isVerified: payload.email_verified || false,
          role: "CANDIDATE",
          status: "PENDING_PHONE_VERIFICATION",
          isProfileComplete: false,
          isPhoneVerified: false,
          source: "REGISTRATION",
          language: "he",
        },
      });
      
      console.log(`[mobile/google] Created new user ${user.email} via Google mobile auth`);
      */
    }

    // בדיקת סטטוס המשתמש
    if (user.status === "BLOCKED") {
      return corsError(req, "Account is blocked", 403);
    }

    if (user.status === "INACTIVE") {
      return corsError(req, "Account is inactive", 403);
    }

    // עדכון זמן התחברות אחרונה
    await prisma.user.update({
      where: { id: user.id },
      data: { 
        lastLogin: new Date(),
        // אם האימייל מאומת בגוגל אך לא במערכת, עדכן
        ...(payload.email_verified && !user.isVerified && {
          isVerified: true
        })
      },
    }).catch(err => console.error("[mobile/google] Failed to update user:", err));

    // יצירת טוקן למובייל
    const { token, expiresAt } = createMobileToken(user);

    console.log(`[mobile/google] User ${user.email} logged in via Google from mobile`);
    console.log(`[mobile/google] Token will expire at: ${new Date(expiresAt).toISOString()}`);

    // החזרת תגובה מוצלחת
    return corsJson(req, {
      success: true,
      user: formatUserForMobile(user),
      tokens: {
        accessToken: token,
        expiresAt,
      },
    });

  } catch (error) {
    console.error("[mobile/google] Unexpected error:", error);
    return corsError(req, "Authentication failed", 500);
  }
}

export async function GET(req: NextRequest) {
  return corsJson(req, {
    success: true,
    message: "Mobile Google login endpoint is working. Use POST with idToken.",
    method: "POST",
    body: {
      idToken: "string (required) - The Google ID token from the client"
    },
    environment: {
      hasWebClientId: !!process.env.GOOGLE_CLIENT_ID,
      hasIosClientId: !!process.env.GOOGLE_IOS_CLIENT_ID || !!process.env.EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID,
      hasAndroidClientId: !!process.env.GOOGLE_ANDROID_CLIENT_ID || !!process.env.EXPO_PUBLIC_GOOGLE_ANDROID_CLIENT_ID,
    }
  });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/images/route.ts
// ==========================================
// NeshamaTech Mobile API - User Images
// GET: List images | POST: Upload | DELETE: Bulk delete
// ==========================================

import { NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
import {
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions,
} from '@/lib/mobile-auth';

export const dynamic = 'force-dynamic';

// ---- Cloudinary config ----
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: 'profile-images', resource_type: 'image' },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({ secure_url: result.secure_url, public_id: result.public_id });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// ---- OPTIONS ----
export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

// ---- GET: List user's images ----
export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const images = await prisma.userImage.findMany({
      where: { userId: auth.userId },
      orderBy: { createdAt: 'desc' },
    });

    return corsJson(req, { success: true, images });
  } catch (error) {
    console.error('[Mobile Images GET] Error:', error);
    return corsError(req, 'Failed to fetch images', 500);
  }
}

// ---- POST: Upload image (FormData with "file" field) ----
export async function POST(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const user = await prisma.user.findUnique({
      where: { id: auth.userId },
      select: { id: true, _count: { select: { images: true } } },
    });

    if (!user) {
      return corsError(req, 'User not found', 404);
    }

    // Max 5 images
    if (user._count.images >= 5) {
      return corsError(req, 'Maximum number of images reached (5)', 400);
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return corsError(req, 'No file provided', 400);
    }

    // Validate type
    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      return corsError(req, 'Invalid file type. Only JPG, PNG and WEBP allowed', 400);
    }

    // Validate size (10MB)
    const MAX_FILE_SIZE = 10 * 1024 * 1024;
    if (file.size > MAX_FILE_SIZE) {
      return corsError(req, 'File size must be less than 10MB', 400);
    }

    // Upload to Cloudinary
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    const cloudinaryResult = await uploadToCloudinary(buffer);

    // First image => set as main
    const isFirstImage = user._count.images === 0;

    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });

    // Update timestamps
    await prisma.user.update({
      where: { id: user.id },
      data: { updatedAt: new Date() },
    });
    await prisma.profile.update({
      where: { userId: user.id },
      data: { contentUpdatedAt: new Date() },
    });

    return corsJson(req, { success: true, image });
  } catch (error) {
    console.error('[Mobile Images POST] Error:', error);
    return corsError(req, 'Failed to upload image', 500);
  }
}

// ---- DELETE: Bulk delete images ----
export async function DELETE(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    let body: { imageIds?: string[] };
    try {
      body = await req.json();
    } catch {
      return corsError(req, 'Invalid JSON body', 400);
    }

    const { imageIds } = body;
    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return corsError(req, 'imageIds must be a non-empty array', 400);
    }

    // Find images owned by this user
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: auth.userId,
      },
      select: { id: true, cloudinaryPublicId: true, isMain: true },
    });

    if (imagesToDelete.length === 0) {
      return corsError(req, 'No matching images found', 404);
    }

    const wasMainDeleted = imagesToDelete.some((img) => img.isMain);

    // Delete from Cloudinary
    const publicIds = imagesToDelete
      .map((img) => img.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (publicIds.length > 0) {
      await Promise.all(
        publicIds.map((id) =>
          cloudinary.uploader.destroy(id).catch((err) => {
            console.error(`[Mobile Images DELETE] Cloudinary error for ${id}:`, err);
          })
        )
      );
    }

    // Delete from DB
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) },
        userId: auth.userId,
      },
    });

    await prisma.profile.update({
      where: { userId: auth.userId },
      data: { contentUpdatedAt: new Date() },
    });

    // If main was deleted, set newest remaining as main
    if (wasMainDeleted) {
      const newMain = await prisma.userImage.findFirst({
        where: { userId: auth.userId },
        orderBy: { createdAt: 'desc' },
      });
      if (newMain) {
        await prisma.userImage.update({
          where: { id: newMain.id },
          data: { isMain: true },
        });
      }
    }

    // Return updated list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: auth.userId },
      orderBy: { createdAt: 'desc' },
    });

    return corsJson(req, { success: true, images: updatedImages });
  } catch (error) {
    console.error('[Mobile Images DELETE] Error:', error);
    return corsError(req, 'Failed to delete images', 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/images/[imageId]/route.ts
// ==========================================
// NeshamaTech Mobile API - Single Image Actions
// PUT: Set as main | DELETE: Delete single image
// ==========================================

import { NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
import {
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions,
} from '@/lib/mobile-auth';

export const dynamic = 'force-dynamic';

// Cloudinary config
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// ---- OPTIONS ----
export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

// ---- PUT: Set image as main ----
export async function PUT(
  req: NextRequest,
  props: { params: Promise<{ imageId: string }> }
) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const { imageId } = await props.params;

    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
    });

    if (!image) {
      return corsError(req, 'Image not found', 404);
    }

    if (image.userId !== auth.userId) {
      return corsError(req, 'Unauthorized', 403);
    }

    // Unset all as main, then set this one
    await prisma.userImage.updateMany({
      where: { userId: auth.userId },
      data: { isMain: false },
    });

    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    const updatedImages = await prisma.userImage.findMany({
      where: { userId: auth.userId },
      orderBy: { createdAt: 'desc' },
    });

    return corsJson(req, { success: true, images: updatedImages });
  } catch (error) {
    console.error('[Mobile Images PUT] Error:', error);
    return corsError(req, 'Failed to set main image', 500);
  }
}

// ---- DELETE: Delete single image ----
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ imageId: string }> }
) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const { imageId } = await props.params;

    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
    });

    if (!image) {
      return corsError(req, 'Image not found', 404);
    }

    if (image.userId !== auth.userId) {
      return corsError(req, 'Unauthorized', 403);
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (err) {
        console.error('[Mobile Images DELETE] Cloudinary error:', err);
      }
    }

    // Delete from DB
    await prisma.userImage.delete({ where: { id: imageId } });

    await prisma.profile.update({
      where: { userId: auth.userId },
      data: { contentUpdatedAt: new Date() },
    });

    // If main was deleted, set newest remaining
    if (image.isMain) {
      const newMain = await prisma.userImage.findFirst({
        where: { userId: auth.userId },
        orderBy: { createdAt: 'desc' },
      });
      if (newMain) {
        await prisma.userImage.update({
          where: { id: newMain.id },
          data: { isMain: true },
        });
      }
    }

    return corsJson(req, { success: true });
  } catch (error) {
    console.error('[Mobile Images DELETE] Error:', error);
    return corsError(req, 'Failed to delete image', 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\login
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\login\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/login/route.ts
// התחברות עם Email/Password למובייל
// נתיב: POST /api/mobile/login

import { NextRequest } from "next/server";
import { z } from "zod";
import { compare } from "bcryptjs";
import prisma from "@/lib/prisma";
import { 
  createMobileToken, 
  formatUserForMobile,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

const loginSchema = z.object({
  email: z.string().email("Invalid email format"),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const validation = loginSchema.safeParse(body);

    if (!validation.success) {
      return corsJson(req, { 
        success: false, 
        error: "Invalid input", 
        details: validation.error.errors 
      }, { status: 400 });
    }

    const { email, password } = validation.data;

    const user = await prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    });

    if (!user) {
      return corsError(req, "Invalid credentials", 401);
    }

    if (!user.password) {
      return corsError(req, "Please use Google Sign-In for this account", 401);
    }

    const isValidPassword = await compare(password, user.password);
    if (!isValidPassword) {
      return corsError(req, "Invalid credentials", 401);
    }

    if (user.status === "BLOCKED") {
      return corsError(req, "Account is blocked", 403);
    }

    if (user.status === "INACTIVE") {
      return corsError(req, "Account is inactive", 403);
    }

    await prisma.user.update({
      where: { id: user.id },
      data: { lastLogin: new Date() },
    }).catch(err => console.error("[mobile/login] Failed to update lastLogin:", err));

    const { token, expiresAt } = createMobileToken(user);

    console.log(`[mobile/login] User ${user.email} logged in successfully from mobile`);

    return corsJson(req, {
      success: true,
      user: formatUserForMobile(user),
      tokens: {
        accessToken: token,
        expiresAt,
      },
    });

  } catch (error) {
    console.error("[mobile/login] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}

export async function GET(req: NextRequest) {
  return corsJson(req, {
    success: true,
    message: "Mobile login endpoint is working. Use POST to login.",
    method: "POST",
    body: {
      email: "string (required)",
      password: "string (required, min 6 chars)"
    }
  });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\me
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\me\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/me/route.ts
// קבלת פרטי המשתמש הנוכחי
// נתיב: GET /api/mobile/me

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken, 
  formatUserForMobile,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const user = await prisma.user.findUnique({
      where: { id: auth.userId },
    });

    if (!user) {
      return corsError(req, "User not found", 404);
    }

    return corsJson(req, {
      success: true,
      user: formatUserForMobile(user),
    });

  } catch (error) {
    console.error("[mobile/me] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\notifications
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\notifications\register-device
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\notifications\register-device\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/notifications/register-device/route.ts
// רישום מכשיר להתראות Push
// נתיב: POST /api/mobile/notifications/register-device

import { NextRequest } from "next/server";
import { z } from "zod";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

const registerSchema = z.object({
  token: z.string().min(1, "Push token is required"),
  platform: z.enum(["ios", "android"]),
});

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function POST(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const body = await req.json();
    const validation = registerSchema.safeParse(body);

    if (!validation.success) {
      return corsJson(req, { 
        success: false, 
        error: "Invalid input", 
        details: validation.error.errors 
      }, { status: 400 });
    }

    const { token: pushToken, platform } = validation.data;

    await prisma.deviceToken.upsert({
      where: { token: pushToken },
      update: {
        userId: auth.userId,
        platform,
        updatedAt: new Date(),
      },
      create: {
        userId: auth.userId,
        token: pushToken,
        platform,
      },
    });

    console.log(`[mobile/notifications] Device registered for user ${auth.userId}, platform: ${platform}`);

    return corsJson(req, { success: true });

  } catch (error) {
    console.error("[mobile/notifications/register-device] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\notifications\unregister-device
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\notifications\unregister-device\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/notifications/unregister-device/route.ts
// הסרת מכשיר מהתראות
// נתיב: POST /api/mobile/notifications/unregister-device

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function POST(req: NextRequest) {
  try {
    const { token } = await req.json();

    if (!token) {
      return corsError(req, "Token is required", 400);
    }

    await prisma.deviceToken.deleteMany({
      where: { token },
    });

    console.log(`[mobile/notifications] Device token removed`);

    return corsJson(req, { success: true });

  } catch (error) {
    console.error("[mobile/notifications/unregister-device] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/profile/route.ts
// ==========================================
// NeshamaTech Mobile - Profile API
// GET: Fetch authenticated user's full profile
// PUT: Update authenticated user's profile
// ==========================================

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  ReligiousJourney,
  Profile,
} from "@prisma/client";
import {
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions,
} from "@/lib/mobile-auth";

// --- Helpers (same as web route) ---

const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};

// ==========================================
// OPTIONS (CORS)
// ==========================================
export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

// ==========================================
// GET /api/mobile/profile
// Returns the authenticated user's full profile
// ==========================================
export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const userWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        images: {
          orderBy: { isMain: "desc" },
          select: {
            id: true,
            url: true,
            isMain: true,
          },
        },
      },
    });

    if (!userWithProfile) {
      return corsError(req, "User not found", 404);
    }

    if (!userWithProfile.profile) {
      return corsError(req, "Profile not found. Please complete your profile on the website first.", 404);
    }

    const p = userWithProfile.profile;

    const profile = {
      // IDs
      id: p.id,
      userId: p.userId,

      // Basic Info
      gender: p.gender,
      birthDate: p.birthDate,
      birthDateIsApproximate: p.birthDateIsApproximate ?? false,
      height: p.height,
      maritalStatus: p.maritalStatus,
      hasChildrenFromPrevious: p.hasChildrenFromPrevious,
      occupation: p.occupation,
      education: p.education,
      educationLevel: p.educationLevel,
      city: p.city,
      origin: p.origin,
      aliyaCountry: p.aliyaCountry,
      aliyaYear: p.aliyaYear,
      nativeLanguage: p.nativeLanguage,
      additionalLanguages: p.additionalLanguages || [],

      // Family
      parentStatus: p.parentStatus,
      fatherOccupation: p.fatherOccupation,
      motherOccupation: p.motherOccupation,
      siblings: p.siblings,
      position: p.position,

      // Religion
      religiousLevel: p.religiousLevel,
      religiousJourney: p.religiousJourney,
      shomerNegiah: p.shomerNegiah,
      serviceType: p.serviceType,
      serviceDetails: p.serviceDetails,
      headCovering: p.headCovering,
      kippahType: p.kippahType,

      // Character & About
      profileHeadline: p.profileHeadline,
      about: p.about,
      isAboutVisible: p.isAboutVisible ?? true,
      profileCharacterTraits: p.profileCharacterTraits || [],
      profileHobbies: p.profileHobbies || [],

      // Preferences - Ranges
      preferredAgeMin: p.preferredAgeMin,
      preferredAgeMax: p.preferredAgeMax,
      preferredHeightMin: p.preferredHeightMin,
      preferredHeightMax: p.preferredHeightMax,

      // Preferences - Single Select
      preferredShomerNegiah: p.preferredShomerNegiah,
      preferredPartnerHasChildren: p.preferredPartnerHasChildren,
      preferredAliyaStatus: p.preferredAliyaStatus,

      // Preferences - Multi Select
      preferredLocations: p.preferredLocations || [],
      preferredReligiousLevels: p.preferredReligiousLevels || [],
      preferredReligiousJourneys: p.preferredReligiousJourneys || [],
      preferredEducation: p.preferredEducation || [],
      preferredOccupations: p.preferredOccupations || [],
      preferredMaritalStatuses: p.preferredMaritalStatuses || [],
      preferredOrigins: p.preferredOrigins || [],
      preferredServiceTypes: p.preferredServiceTypes || [],
      preferredHeadCoverings: p.preferredHeadCoverings || [],
      preferredKippahTypes: p.preferredKippahTypes || [],
      preferredCharacterTraits: p.preferredCharacterTraits || [],
      preferredHobbies: p.preferredHobbies || [],

      // Notes
      matchingNotes: p.matchingNotes,

      // System
      availabilityStatus: p.availabilityStatus,

      createdAt: p.createdAt,
      updatedAt: p.updatedAt,
    };

    console.log(`[mobile/profile] GET profile for user ${userId}`);

    return corsJson(req, {
      success: true,
      data: {
        profile,
        user: {
          id: userWithProfile.id,
          firstName: userWithProfile.firstName,
          lastName: userWithProfile.lastName,
          email: userWithProfile.email,
          phone: userWithProfile.phone,
        },
        images: userWithProfile.images,
      },
    });
  } catch (error) {
    console.error("[mobile/profile] GET Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}

// ==========================================
// PUT /api/mobile/profile
// Updates the authenticated user's profile
// Accepts partial data - only updates provided fields
// ==========================================
export async function PUT(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    let body: Record<string, any>;
    try {
      body = await req.json();
    } catch {
      return corsError(req, "Invalid JSON body", 400);
    }

    console.log(`[mobile/profile] PUT update for user ${userId}, keys: ${Object.keys(body).join(", ")}`);

    // Build the Prisma update object - only include fields that were sent
    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // ---- Personal & Demographic ----
    if (body.height !== undefined) dataToUpdate.height = toNumberOrNull(body.height);
    if (body.city !== undefined) dataToUpdate.city = emptyStringToNull(body.city);
    if (body.origin !== undefined) dataToUpdate.origin = emptyStringToNull(body.origin);
    if (body.occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(body.occupation);
    if (body.education !== undefined) dataToUpdate.education = emptyStringToNull(body.education);
    if (body.nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(body.nativeLanguage);
    if (body.additionalLanguages !== undefined) dataToUpdate.additionalLanguages = body.additionalLanguages || [];
    if (body.aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(body.aliyaCountry);
    if (body.aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(body.aliyaYear);

    // ---- Family ----
    if (body.parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(body.parentStatus);
    if (body.fatherOccupation !== undefined) dataToUpdate.fatherOccupation = emptyStringToNull(body.fatherOccupation);
    if (body.motherOccupation !== undefined) dataToUpdate.motherOccupation = emptyStringToNull(body.motherOccupation);
    if (body.siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(body.siblings);
    if (body.position !== undefined) dataToUpdate.position = toNumberOrNull(body.position);

    // ---- Religion (limited editable fields from mobile) ----
    // Note: gender, birthDate, maritalStatus, religiousLevel, religiousJourney, 
    // educationLevel, serviceType are NOT editable from mobile - must use web app
    if (body.shomerNegiah !== undefined) dataToUpdate.shomerNegiah = body.shomerNegiah;
    if (body.serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(body.serviceDetails);

    // ---- Traits & Character ----
    if (body.profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = body.profileCharacterTraits || [];
    if (body.profileHobbies !== undefined) dataToUpdate.profileHobbies = body.profileHobbies || [];

    // ---- About ----
    if (body.profileHeadline !== undefined) dataToUpdate.profileHeadline = emptyStringToNull(body.profileHeadline);
    if (body.about !== undefined) dataToUpdate.about = emptyStringToNull(body.about);
    if (body.isAboutVisible !== undefined) dataToUpdate.isAboutVisible = body.isAboutVisible;

    // ---- Notes ----
    if (body.matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(body.matchingNotes);

    // ---- Preferences - Ranges ----
    if (body.preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(body.preferredAgeMin);
    if (body.preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(body.preferredAgeMax);
    if (body.preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(body.preferredHeightMin);
    if (body.preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(body.preferredHeightMax);

    // ---- Preferences - Single Select ----
    if (body.preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(body.preferredShomerNegiah);
    if (body.preferredPartnerHasChildren !== undefined) dataToUpdate.preferredPartnerHasChildren = emptyStringToNull(body.preferredPartnerHasChildren);
    if (body.preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(body.preferredAliyaStatus);

    // ---- Preferences - Multi Select (Arrays) ----
    if (body.preferredLocations !== undefined) dataToUpdate.preferredLocations = body.preferredLocations || [];
    if (body.preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = body.preferredReligiousLevels || [];

    if (body.preferredReligiousJourneys !== undefined) {
      const validJourneys = (body.preferredReligiousJourneys || []).filter(
        (j: string) => Object.values(ReligiousJourney).includes(j as ReligiousJourney)
      ) as ReligiousJourney[];
      dataToUpdate.preferredReligiousJourneys = validJourneys;
    }

    if (body.preferredEducation !== undefined) dataToUpdate.preferredEducation = body.preferredEducation || [];
    if (body.preferredOccupations !== undefined) dataToUpdate.preferredOccupations = body.preferredOccupations || [];
    if (body.preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = body.preferredMaritalStatuses || [];
    if (body.preferredOrigins !== undefined) dataToUpdate.preferredOrigins = body.preferredOrigins || [];
    if (body.preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = body.preferredServiceTypes || [];
    if (body.preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = body.preferredHeadCoverings || [];
    if (body.preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = body.preferredKippahTypes || [];
    if (body.preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = body.preferredCharacterTraits || [];
    if (body.preferredHobbies !== undefined) dataToUpdate.preferredHobbies = body.preferredHobbies || [];

    // ---- System Fields (always update on save) ----
    dataToUpdate.lastActive = new Date();
    dataToUpdate.contentUpdatedAt = new Date();
    dataToUpdate.needsAiProfileUpdate = true;

    // ---- Perform Update ----
    if (Object.keys(dataToUpdate).length <= 3) {
      // Only system fields (lastActive, contentUpdatedAt, needsAiProfileUpdate) - nothing meaningful to update
      console.log(`[mobile/profile] No meaningful data to update for user ${userId}`);
      return corsError(req, "No data provided to update", 400);
    }

    let updatedProfile: Profile;
    try {
      updatedProfile = await prisma.profile.update({
        where: { userId },
        data: dataToUpdate,
      });
    } catch (dbError) {
      console.error("[mobile/profile] Prisma update error:", dbError);
      if (dbError instanceof Prisma.PrismaClientKnownRequestError) {
        if (dbError.code === "P2025") {
          return corsError(req, "Profile not found", 404);
        }
      }
      throw dbError;
    }

    console.log(`[mobile/profile] PUT success for user ${userId}`);

    // Return the updated profile in the same shape as GET
    const p = updatedProfile;
    const responseProfile = {
      id: p.id,
      userId: p.userId,
      gender: p.gender,
      birthDate: p.birthDate,
      birthDateIsApproximate: p.birthDateIsApproximate ?? false,
      height: p.height,
      maritalStatus: p.maritalStatus,
      hasChildrenFromPrevious: p.hasChildrenFromPrevious,
      occupation: p.occupation,
      education: p.education,
      educationLevel: p.educationLevel,
      city: p.city,
      origin: p.origin,
      aliyaCountry: p.aliyaCountry,
      aliyaYear: p.aliyaYear,
      nativeLanguage: p.nativeLanguage,
      additionalLanguages: p.additionalLanguages || [],
      parentStatus: p.parentStatus,
      fatherOccupation: p.fatherOccupation,
      motherOccupation: p.motherOccupation,
      siblings: p.siblings,
      position: p.position,
      religiousLevel: p.religiousLevel,
      religiousJourney: p.religiousJourney,
      shomerNegiah: p.shomerNegiah,
      serviceType: p.serviceType,
      serviceDetails: p.serviceDetails,
      headCovering: p.headCovering,
      kippahType: p.kippahType,
      profileHeadline: p.profileHeadline,
      about: p.about,
      isAboutVisible: p.isAboutVisible ?? true,
      profileCharacterTraits: p.profileCharacterTraits || [],
      profileHobbies: p.profileHobbies || [],
      preferredAgeMin: p.preferredAgeMin,
      preferredAgeMax: p.preferredAgeMax,
      preferredHeightMin: p.preferredHeightMin,
      preferredHeightMax: p.preferredHeightMax,
      preferredShomerNegiah: p.preferredShomerNegiah,
      preferredPartnerHasChildren: p.preferredPartnerHasChildren,
      preferredAliyaStatus: p.preferredAliyaStatus,
      preferredLocations: p.preferredLocations || [],
      preferredReligiousLevels: p.preferredReligiousLevels || [],
      preferredReligiousJourneys: p.preferredReligiousJourneys || [],
      preferredEducation: p.preferredEducation || [],
      preferredOccupations: p.preferredOccupations || [],
      preferredMaritalStatuses: p.preferredMaritalStatuses || [],
      preferredOrigins: p.preferredOrigins || [],
      preferredServiceTypes: p.preferredServiceTypes || [],
      preferredHeadCoverings: p.preferredHeadCoverings || [],
      preferredKippahTypes: p.preferredKippahTypes || [],
      preferredCharacterTraits: p.preferredCharacterTraits || [],
      preferredHobbies: p.preferredHobbies || [],
      matchingNotes: p.matchingNotes,
      availabilityStatus: p.availabilityStatus,
      createdAt: p.createdAt,
      updatedAt: p.updatedAt,
    };

    return corsJson(req, {
      success: true,
      data: {
        profile: responseProfile,
      },
    });
  } catch (error) {
    console.error("[mobile/profile] PUT Error:", error);

    if (error instanceof Prisma.PrismaClientValidationError) {
      return corsError(req, "Data validation failed", 400);
    }

    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/questionnaire/route.ts
// ==========================================
// NeshamaTech Mobile API - Questionnaire Responses
// GET: Get formatted questionnaire | PATCH: Update visibility/delete answer
// ==========================================

import { NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { Locale } from '../../../../../i18n-config';
import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { WorldId, UpdateValue } from '@/types/next-auth';
import { formatQuestionnaireForDisplay } from '@/lib/services/questionnaireService';
import {
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions,
} from '@/lib/mobile-auth';

export const dynamic = 'force-dynamic';

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

// ---- OPTIONS ----
export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

// ---- GET: Formatted questionnaire responses ----
export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const url = new URL(req.url);
    const locale = (url.searchParams.get('locale') as Locale) || 'he';

    const rawQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: auth.userId },
      orderBy: { createdAt: 'desc' },
    });

    if (!rawQuestionnaire) {
      return corsJson(req, {
        success: true,
        questionnaireResponse: null,
      });
    }

    // Format for display using the shared service
    const formattedQuestionnaire = await formatQuestionnaireForDisplay(
      rawQuestionnaire,
      locale,
      true // own profile → can view all answers
    );

    return corsJson(req, {
      success: true,
      questionnaireResponse: formattedQuestionnaire,
    });
  } catch (error) {
    console.error('[Mobile Questionnaire GET] Error:', error);
    return corsError(req, 'Failed to fetch questionnaire', 500);
  }
}

// ---- PATCH: Update answer visibility or delete answer ----
export async function PATCH(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    let body: { worldKey: string; questionId: string; value: UpdateValue };
    try {
      body = await req.json();
    } catch {
      return corsError(req, 'Invalid JSON body', 400);
    }

    const { worldKey: rawWorldKey, questionId, value } = body;

    // Normalize to UPPERCASE
    const worldKey = rawWorldKey?.toUpperCase() as WorldId;

    if (!worldKey || !questionId || !value || !value.type || !KEY_MAPPING[worldKey]) {
      return corsError(req, 'Invalid request body', 400);
    }

    const dbKey = KEY_MAPPING[worldKey];

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: auth.userId },
      orderBy: { createdAt: 'desc' },
    });

    if (!questionnaire) {
      return corsError(req, 'Questionnaire not found', 404);
    }

    const currentAnswersJson = questionnaire[dbKey];
    const currentAnswers = Array.isArray(currentAnswersJson)
      ? (currentAnswersJson as unknown as JsonAnswerData[])
      : [];

    let updatedAnswers: JsonAnswerData[];

    if (value.type === 'delete') {
      updatedAnswers = currentAnswers.filter((a) => a.questionId !== questionId);
    } else if (value.type === 'visibility') {
      const existingIdx = currentAnswers.findIndex((a) => a.questionId === questionId);
      if (existingIdx === -1) {
        return corsError(req, 'Answer not found', 404);
      }
      if (typeof value.isVisible !== 'boolean') {
        return corsError(req, 'Invalid visibility value', 400);
      }
      updatedAnswers = [...currentAnswers];
      updatedAnswers[existingIdx] = {
        ...currentAnswers[existingIdx],
        isVisible: value.isVisible,
        answeredAt: new Date().toISOString(),
      };
    } else if (value.type === 'answer') {
      if (value.value === undefined) {
        return corsError(req, 'Missing answer value', 400);
      }
      const existingIdx = currentAnswers.findIndex((a) => a.questionId === questionId);
      const updatedAnswer: JsonAnswerData = {
        questionId,
        value: value.value as Prisma.JsonValue,
        isVisible: existingIdx !== -1 ? currentAnswers[existingIdx].isVisible : true,
        answeredAt: new Date().toISOString(),
      };
      updatedAnswers = [...currentAnswers];
      if (existingIdx !== -1) {
        updatedAnswers[existingIdx] = updatedAnswer;
      } else {
        updatedAnswers.push(updatedAnswer);
      }
    } else {
      return corsError(req, 'Invalid update type', 400);
    }

    const updated = await prisma.questionnaireResponse.update({
      where: { id: questionnaire.id },
      data: {
        [dbKey]: updatedAnswers as Prisma.JsonValue,
        lastSaved: new Date(),
      },
    });

    await prisma.profile.update({
      where: { userId: auth.userId },
      data: { needsAiProfileUpdate: true, contentUpdatedAt: new Date() },
    });

    await prisma.user.update({
      where: { id: auth.userId },
      data: { updatedAt: new Date() },
    });

    // Build formatted response
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach((key) => {
      const currentDbKey = KEY_MAPPING[key];
      formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
    });

    return corsJson(req, {
      success: true,
      data: {
        ...updated,
        formattedAnswers,
      },
    });
  } catch (error) {
    console.error('[Mobile Questionnaire PATCH] Error:', error);
    return corsError(req, 'Failed to update questionnaire', 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions
# Generated on: 2026-02-04 14:50:37
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/[id]/route.ts
// פרטי הצעת שידוך בודדת - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true,
            phone: true,
            email: true,
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true,
            email: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                education: true,
                educationLevel: true,
                height: true,
                about: true,
                religiousLevel: true,
                origin: true,
                maritalStatus: true,
                profileCharacterTraits: true,
                profileHobbies: true,
              }
            },
            images: {
              orderBy: { isMain: 'desc' },
              select: { 
                url: true,
                isMain: true,
              }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true,
            email: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                education: true,
                educationLevel: true,
                height: true,
                about: true,
                religiousLevel: true,
                origin: true,
                maritalStatus: true,
                profileCharacterTraits: true,
                profileHobbies: true,
              }
            },
            images: {
              orderBy: { isMain: 'desc' },
              select: { 
                url: true,
                isMain: true,
              }
            }
          }
        },
        statusHistory: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          select: {
            id: true,
            status: true,
            notes: true,
            createdAt: true,
          }
        },
      },
    });

    if (!suggestion) {
      return corsError(req, "Suggestion not found", 404);
    }

    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;

    if (!isFirstParty && !isSecondParty) {
      return corsError(req, "Access denied", 403);
    }

    const otherPartyRaw = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
    const notes = isFirstParty ? suggestion.firstPartyNotes : suggestion.secondPartyNotes;

    const otherParty: any = {
      id: otherPartyRaw.id,
      firstName: otherPartyRaw.firstName,
      lastName: otherPartyRaw.lastName,
      age: calculateAge(otherPartyRaw.profile?.birthDate),
      city: otherPartyRaw.profile?.city || null,
      occupation: otherPartyRaw.profile?.occupation || null,
      education: otherPartyRaw.profile?.education || null,
      educationLevel: otherPartyRaw.profile?.educationLevel || null,
      height: otherPartyRaw.profile?.height || null,
      about: otherPartyRaw.profile?.about || null,
      religiousLevel: otherPartyRaw.profile?.religiousLevel || null,
      origin: otherPartyRaw.profile?.origin || null,
      maritalStatus: otherPartyRaw.profile?.maritalStatus || null,
      characterTraits: otherPartyRaw.profile?.profileCharacterTraits || [],
      hobbies: otherPartyRaw.profile?.profileHobbies || [],
      images: otherPartyRaw.images?.map(img => img.url) || [],
      mainImage: otherPartyRaw.images?.find(img => img.isMain)?.url || otherPartyRaw.images?.[0]?.url || null,
    };

    const showContactDetails = suggestion.status === 'CONTACT_DETAILS_SHARED';

    if (showContactDetails) {
      otherParty.phone = otherPartyRaw.phone;
      otherParty.email = otherPartyRaw.email;
    }

    const canRespond = 
      (isFirstParty && suggestion.status === 'PENDING_FIRST_PARTY') ||
      (isSecondParty && suggestion.status === 'PENDING_SECOND_PARTY');

    const responseData = {
      id: suggestion.id,
      status: suggestion.status,
      priority: suggestion.priority,
      matchingReason: suggestion.matchingReason,
      notes: notes,
      createdAt: suggestion.createdAt,
      updatedAt: suggestion.updatedAt,
      decisionDeadline: suggestion.decisionDeadline,
      lastStatusChange: suggestion.lastStatusChange,
      isFirstParty,
      canRespond,
      showContactDetails,
      matchmaker: {
        firstName: suggestion.matchmaker.firstName,
        lastName: suggestion.matchmaker.lastName,
        ...(showContactDetails && {
          phone: suggestion.matchmaker.phone,
          email: suggestion.matchmaker.email,
        }),
      },
      otherParty,
      statusHistory: suggestion.statusHistory,
    };

    console.log(`[mobile/suggestions/${suggestionId}] Fetched for user ${userId}, isFirstParty: ${isFirstParty}`);

    return corsJson(req, {
      success: true,
      data: responseData,
    });

  } catch (error) {
    console.error("[mobile/suggestions/[id]] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/[id]/respond/route.ts
// תגובה להצעת שידוך - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";
import type { MatchSuggestionStatus } from "@prisma/client";

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const body = await req.json();
    const { response, reason, notes } = body as {
      response: 'approve' | 'decline';
      reason?: string;
      notes?: string;
    };

    if (!response || !['approve', 'decline'].includes(response)) {
      return corsError(req, "Invalid response. Must be 'approve' or 'decline'", 400);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      select: {
        id: true,
        status: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      },
    });

    if (!suggestion) {
      return corsError(req, "Suggestion not found", 404);
    }

    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;

    if (!isFirstParty && !isSecondParty) {
      return corsError(req, "Access denied", 403);
    }

    const canRespond = 
      (isFirstParty && suggestion.status === 'PENDING_FIRST_PARTY') ||
      (isSecondParty && suggestion.status === 'PENDING_SECOND_PARTY');

    if (!canRespond) {
      return corsError(req, "Cannot respond at this stage", 400);
    }

    let newStatus: MatchSuggestionStatus;
    
    if (response === 'approve') {
      if (isFirstParty) {
        newStatus = 'FIRST_PARTY_APPROVED';
      } else {
        newStatus = 'SECOND_PARTY_APPROVED';
      }
    } else {
      if (isFirstParty) {
        newStatus = 'FIRST_PARTY_DECLINED';
      } else {
        newStatus = 'SECOND_PARTY_DECLINED';
      }
    }

    const updateData: any = {
      status: newStatus,
      lastStatusChange: new Date(),
      lastActivity: new Date(),
    };

    if (isFirstParty) {
      updateData.firstPartyResponded = new Date();
      if (notes) {
        updateData.firstPartyNotes = notes;
      }
    } else {
      updateData.secondPartyResponded = new Date();
      if (notes) {
        updateData.secondPartyNotes = notes;
      }
    }

    if (response === 'decline' && reason) {
      updateData.internalNotes = `[${new Date().toISOString()}] ${isFirstParty ? 'צד א' : 'צד ב'} דחה: ${reason}`.trim();
    }

    const updatedSuggestion = await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: updateData,
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
      },
    });

    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId: suggestionId,
        status: newStatus,
        notes: response === 'approve' 
          ? (notes || (isFirstParty ? 'צד א אישר' : 'צד ב אישר'))
          : (reason || (isFirstParty ? 'צד א דחה' : 'צד ב דחה')),
      },
    });

    if (newStatus === 'SECOND_PARTY_APPROVED') {
      const firstPartyApproved = await prisma.suggestionStatusHistory.findFirst({
        where: {
          suggestionId: suggestionId,
          status: 'FIRST_PARTY_APPROVED',
        },
      });

      if (firstPartyApproved) {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            status: 'CONTACT_DETAILS_SHARED',
            lastStatusChange: new Date(),
          },
        });

        await prisma.suggestionStatusHistory.create({
          data: {
            suggestionId: suggestionId,
            status: 'CONTACT_DETAILS_SHARED',
            notes: 'שני הצדדים אישרו - פרטי קשר שותפו',
          },
        });
      }
    }

    console.log(`[mobile/suggestions/${suggestionId}/respond] User ${userId} responded: ${response}, new status: ${newStatus}`);

    return corsJson(req, {
      success: true,
      message: response === 'approve' ? 'ההצעה אושרה בהצלחה' : 'ההצעה נדחתה',
      data: {
        id: updatedSuggestion.id,
        status: updatedSuggestion.status,
        lastStatusChange: updatedSuggestion.lastStatusChange,
      },
    });

  } catch (error) {
    console.error("[mobile/suggestions/[id]/respond] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/active/route.ts
// הצעות שידוך פעילות - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { 
            firstPartyId: userId, 
            status: { 
              in: ["PENDING_FIRST_PARTY", "FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] 
            } 
          },
          { 
            secondPartyId: userId, 
            status: { 
              in: ["PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] 
            } 
          },
        ],
      },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true 
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                height: true,
                about: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                height: true,
                about: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
      },
      orderBy: { createdAt: "desc" },
    });

    const suggestions = activeSuggestions.map(suggestion => {
      const isFirstParty = suggestion.firstPartyId === userId;
      const otherParty = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
      const notes = isFirstParty ? suggestion.firstPartyNotes : suggestion.secondPartyNotes;
      
      return {
        id: suggestion.id,
        status: suggestion.status,
        priority: suggestion.priority,
        matchingReason: suggestion.matchingReason,
        notes: notes,
        matchmaker: suggestion.matchmaker,
        createdAt: suggestion.createdAt,
        decisionDeadline: suggestion.decisionDeadline,
        isFirstParty,
        otherParty: {
          id: otherParty.id,
          firstName: otherParty.firstName,
          lastName: otherParty.lastName,
          age: calculateAge(otherParty.profile?.birthDate),
          city: otherParty.profile?.city,
          occupation: otherParty.profile?.occupation,
          height: otherParty.profile?.height,
          about: otherParty.profile?.about,
          image: otherParty.images?.[0]?.url || null,
        }
      };
    });

    console.log(`[mobile/suggestions/active] Found ${suggestions.length} active suggestions for user ${userId}`);

    return corsJson(req, {
      success: true,
      suggestions,
    });

  } catch (error) {
    console.error("[mobile/suggestions/active] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/history/route.ts
// היסטוריית הצעות שידוך - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { 
            firstPartyId: userId, 
            status: { 
              in: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] 
            } 
          },
          { 
            secondPartyId: userId, 
            status: { 
              in: ["SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] 
            } 
          },
        ],
      },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true 
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
      },
      orderBy: { updatedAt: "desc" },
    });

    const suggestions = historySuggestions.map(suggestion => {
      const isFirstParty = suggestion.firstPartyId === userId;
      const otherParty = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
      
      return {
        id: suggestion.id,
        status: suggestion.status,
        matchmaker: suggestion.matchmaker,
        createdAt: suggestion.createdAt,
        updatedAt: suggestion.updatedAt,
        closedAt: suggestion.closedAt,
        isFirstParty,
        otherParty: {
          id: otherParty.id,
          firstName: otherParty.firstName,
          lastName: otherParty.lastName,
          age: calculateAge(otherParty.profile?.birthDate),
          city: otherParty.profile?.city,
          occupation: otherParty.profile?.occupation,
          image: otherParty.images?.[0]?.url || null,
        }
      };
    });

    console.log(`[mobile/suggestions/history] Found ${suggestions.length} history suggestions for user ${userId}`);

    return corsJson(req, {
      success: true,
      suggestions,
    });

  } catch (error) {
    console.error("[mobile/suggestions/history] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

--- End of Content for suggestions_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/[id]/route.ts
// פרטי הצעת שידוך בודדת - למובייל
// UPDATED: Added questionnaire responses

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";
import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { WorldId } from "@/types/next-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true,
            phone: true,
            email: true,
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true,
            email: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                education: true,
                educationLevel: true,
                height: true,
                about: true,
                religiousLevel: true,
                origin: true,
                maritalStatus: true,
                profileCharacterTraits: true,
                profileHobbies: true,
              }
            },
            images: {
              orderBy: { isMain: 'desc' },
              select: { 
                url: true,
                isMain: true,
              }
            },
            // NEW: Include questionnaire responses
            questionnaireResponses: {
              orderBy: { createdAt: 'desc' },
              take: 1,
              select: {
                id: true,
                valuesAnswers: true,
                personalityAnswers: true,
                relationshipAnswers: true,
                partnerAnswers: true,
                religionAnswers: true,
              }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true,
            email: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                education: true,
                educationLevel: true,
                height: true,
                about: true,
                religiousLevel: true,
                origin: true,
                maritalStatus: true,
                profileCharacterTraits: true,
                profileHobbies: true,
              }
            },
            images: {
              orderBy: { isMain: 'desc' },
              select: { 
                url: true,
                isMain: true,
              }
            },
            // NEW: Include questionnaire responses
            questionnaireResponses: {
              orderBy: { createdAt: 'desc' },
              take: 1,
              select: {
                id: true,
                valuesAnswers: true,
                personalityAnswers: true,
                relationshipAnswers: true,
                partnerAnswers: true,
                religionAnswers: true,
              }
            }
          }
        },
        statusHistory: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          select: {
            id: true,
            status: true,
            notes: true,
            createdAt: true,
          }
        },
      },
    });

    if (!suggestion) {
      return corsError(req, "Suggestion not found", 404);
    }

    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;

    if (!isFirstParty && !isSecondParty) {
      return corsError(req, "Access denied", 403);
    }

    const otherPartyRaw = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
    const notes = isFirstParty ? suggestion.firstPartyNotes : suggestion.secondPartyNotes;

    // Process questionnaire responses
    let questionnaireAnswers: Record<string, any[]> | null = null;
    
    if (otherPartyRaw.questionnaireResponses && otherPartyRaw.questionnaireResponses.length > 0) {
      const qr = otherPartyRaw.questionnaireResponses[0];
      questionnaireAnswers = {};
      
      // Format answers for each world
      (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
        const dbKey = KEY_MAPPING[worldKey];
        const answersJson = qr[dbKey as keyof typeof qr];
        if (answersJson) {
          const formatted = formatAnswers(answersJson);
          // Only include visible answers
          questionnaireAnswers![worldKey] = formatted.filter(a => a.isVisible !== false);
        }
      });
    }

    const otherParty: any = {
      id: otherPartyRaw.id,
      firstName: otherPartyRaw.firstName,
      lastName: otherPartyRaw.lastName,
      age: calculateAge(otherPartyRaw.profile?.birthDate),
      city: otherPartyRaw.profile?.city || null,
      occupation: otherPartyRaw.profile?.occupation || null,
      education: otherPartyRaw.profile?.education || null,
      educationLevel: otherPartyRaw.profile?.educationLevel || null,
      height: otherPartyRaw.profile?.height || null,
      about: otherPartyRaw.profile?.about || null,
      religiousLevel: otherPartyRaw.profile?.religiousLevel || null,
      origin: otherPartyRaw.profile?.origin || null,
      maritalStatus: otherPartyRaw.profile?.maritalStatus || null,
      characterTraits: otherPartyRaw.profile?.profileCharacterTraits || [],
      hobbies: otherPartyRaw.profile?.profileHobbies || [],
      images: otherPartyRaw.images?.map(img => img.url) || [],
      mainImage: otherPartyRaw.images?.find(img => img.isMain)?.url || otherPartyRaw.images?.[0]?.url || null,
      // NEW: Add questionnaire answers
      questionnaireAnswers,
    };

    const showContactDetails = suggestion.status === 'CONTACT_DETAILS_SHARED';

    if (showContactDetails) {
      otherParty.phone = otherPartyRaw.phone;
      otherParty.email = otherPartyRaw.email;
    }

    const canRespond = 
      (isFirstParty && suggestion.status === 'PENDING_FIRST_PARTY') ||
      (isSecondParty && suggestion.status === 'PENDING_SECOND_PARTY');

    const responseData = {
      id: suggestion.id,
      status: suggestion.status,
      priority: suggestion.priority,
      matchingReason: suggestion.matchingReason,
      notes: notes,
      createdAt: suggestion.createdAt,
      updatedAt: suggestion.updatedAt,
      decisionDeadline: suggestion.decisionDeadline,
      lastStatusChange: suggestion.lastStatusChange,
      isFirstParty,
      canRespond,
      showContactDetails,
      matchmaker: {
        firstName: suggestion.matchmaker.firstName,
        lastName: suggestion.matchmaker.lastName,
        ...(showContactDetails && {
          phone: suggestion.matchmaker.phone,
          email: suggestion.matchmaker.email,
        }),
      },
      otherParty,
      statusHistory: suggestion.statusHistory,
    };

    console.log(`[mobile/suggestions/${suggestionId}] Fetched for user ${userId}, isFirstParty: ${isFirstParty}, hasQuestionnaire: ${!!questionnaireAnswers}`);

    return corsJson(req, {
      success: true,
      data: responseData,
    });

  } catch (error) {
    console.error("[mobile/suggestions/[id]] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/[id]/respond/route.ts
// תגובה להצעת שידוך - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";
import type { MatchSuggestionStatus } from "@prisma/client";

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const body = await req.json();
    const { response, reason, notes } = body as {
      response: 'approve' | 'decline';
      reason?: string;
      notes?: string;
    };

    if (!response || !['approve', 'decline'].includes(response)) {
      return corsError(req, "Invalid response. Must be 'approve' or 'decline'", 400);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      select: {
        id: true,
        status: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      },
    });

    if (!suggestion) {
      return corsError(req, "Suggestion not found", 404);
    }

    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;

    if (!isFirstParty && !isSecondParty) {
      return corsError(req, "Access denied", 403);
    }

    const canRespond = 
      (isFirstParty && suggestion.status === 'PENDING_FIRST_PARTY') ||
      (isSecondParty && suggestion.status === 'PENDING_SECOND_PARTY');

    if (!canRespond) {
      return corsError(req, "Cannot respond at this stage", 400);
    }

    let newStatus: MatchSuggestionStatus;
    
    if (response === 'approve') {
      if (isFirstParty) {
        newStatus = 'FIRST_PARTY_APPROVED';
      } else {
        newStatus = 'SECOND_PARTY_APPROVED';
      }
    } else {
      if (isFirstParty) {
        newStatus = 'FIRST_PARTY_DECLINED';
      } else {
        newStatus = 'SECOND_PARTY_DECLINED';
      }
    }

    const updateData: any = {
      status: newStatus,
      lastStatusChange: new Date(),
      lastActivity: new Date(),
    };

    if (isFirstParty) {
      updateData.firstPartyResponded = new Date();
      if (notes) {
        updateData.firstPartyNotes = notes;
      }
    } else {
      updateData.secondPartyResponded = new Date();
      if (notes) {
        updateData.secondPartyNotes = notes;
      }
    }

    if (response === 'decline' && reason) {
      updateData.internalNotes = `[${new Date().toISOString()}] ${isFirstParty ? 'צד א' : 'צד ב'} דחה: ${reason}`.trim();
    }

    const updatedSuggestion = await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: updateData,
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
      },
    });

    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId: suggestionId,
        status: newStatus,
        notes: response === 'approve' 
          ? (notes || (isFirstParty ? 'צד א אישר' : 'צד ב אישר'))
          : (reason || (isFirstParty ? 'צד א דחה' : 'צד ב דחה')),
      },
    });

    if (newStatus === 'SECOND_PARTY_APPROVED') {
      const firstPartyApproved = await prisma.suggestionStatusHistory.findFirst({
        where: {
          suggestionId: suggestionId,
          status: 'FIRST_PARTY_APPROVED',
        },
      });

      if (firstPartyApproved) {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            status: 'CONTACT_DETAILS_SHARED',
            lastStatusChange: new Date(),
          },
        });

        await prisma.suggestionStatusHistory.create({
          data: {
            suggestionId: suggestionId,
            status: 'CONTACT_DETAILS_SHARED',
            notes: 'שני הצדדים אישרו - פרטי קשר שותפו',
          },
        });
      }
    }

    console.log(`[mobile/suggestions/${suggestionId}/respond] User ${userId} responded: ${response}, new status: ${newStatus}`);

    return corsJson(req, {
      success: true,
      message: response === 'approve' ? 'ההצעה אושרה בהצלחה' : 'ההצעה נדחתה',
      data: {
        id: updatedSuggestion.id,
        status: updatedSuggestion.status,
        lastStatusChange: updatedSuggestion.lastStatusChange,
      },
    });

  } catch (error) {
    console.error("[mobile/suggestions/[id]/respond] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/active/route.ts
// הצעות שידוך פעילות - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { 
            firstPartyId: userId, 
            status: { 
              in: ["PENDING_FIRST_PARTY", "FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] 
            } 
          },
          { 
            secondPartyId: userId, 
            status: { 
              in: ["PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] 
            } 
          },
        ],
      },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true 
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                height: true,
                about: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                height: true,
                about: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
      },
      orderBy: { createdAt: "desc" },
    });

    const suggestions = activeSuggestions.map(suggestion => {
      const isFirstParty = suggestion.firstPartyId === userId;
      const otherParty = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
      const notes = isFirstParty ? suggestion.firstPartyNotes : suggestion.secondPartyNotes;
      
      return {
        id: suggestion.id,
        status: suggestion.status,
        priority: suggestion.priority,
        matchingReason: suggestion.matchingReason,
        notes: notes,
        matchmaker: suggestion.matchmaker,
        createdAt: suggestion.createdAt,
        decisionDeadline: suggestion.decisionDeadline,
        isFirstParty,
        otherParty: {
          id: otherParty.id,
          firstName: otherParty.firstName,
          lastName: otherParty.lastName,
          age: calculateAge(otherParty.profile?.birthDate),
          city: otherParty.profile?.city,
          occupation: otherParty.profile?.occupation,
          height: otherParty.profile?.height,
          about: otherParty.profile?.about,
          image: otherParty.images?.[0]?.url || null,
        }
      };
    });

    console.log(`[mobile/suggestions/active] Found ${suggestions.length} active suggestions for user ${userId}`);

    return corsJson(req, {
      success: true,
      suggestions,
    });

  } catch (error) {
    console.error("[mobile/suggestions/active] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/history/route.ts
// היסטוריית הצעות שידוך - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { 
            firstPartyId: userId, 
            status: { 
              in: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] 
            } 
          },
          { 
            secondPartyId: userId, 
            status: { 
              in: ["SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] 
            } 
          },
        ],
      },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true 
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
      },
      orderBy: { updatedAt: "desc" },
    });

    const suggestions = historySuggestions.map(suggestion => {
      const isFirstParty = suggestion.firstPartyId === userId;
      const otherParty = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
      
      return {
        id: suggestion.id,
        status: suggestion.status,
        matchmaker: suggestion.matchmaker,
        createdAt: suggestion.createdAt,
        updatedAt: suggestion.updatedAt,
        closedAt: suggestion.closedAt,
        isFirstParty,
        otherParty: {
          id: otherParty.id,
          firstName: otherParty.firstName,
          lastName: otherParty.lastName,
          age: calculateAge(otherParty.profile?.birthDate),
          city: otherParty.profile?.city,
          occupation: otherParty.profile?.occupation,
          image: otherParty.images?.[0]?.url || null,
        }
      };
    });

    console.log(`[mobile/suggestions/history] Found ${suggestions.length} history suggestions for user ${userId}`);

    return corsJson(req, {
      success: true,
      suggestions,
    });

  } catch (error) {
    console.error("[mobile/suggestions/history] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

