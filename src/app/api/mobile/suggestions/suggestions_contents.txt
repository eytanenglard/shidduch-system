################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions
# Generated on: 2026-03-01 14:40:51
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/[id]/route.ts
// פרטי הצעת שידוך בודדת - למובייל
// UPDATED: Added questionnaire responses

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";
import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { WorldId } from "@/types/next-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true,
            phone: true,
            email: true,
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true,
            email: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                education: true,
                educationLevel: true,
                height: true,
                about: true,
                religiousLevel: true,
                origin: true,
                maritalStatus: true,
                profileCharacterTraits: true,
                profileHobbies: true,
              }
            },
            images: {
              orderBy: { isMain: 'desc' },
              select: { 
                url: true,
                isMain: true,
              }
            },
            // NEW: Include questionnaire responses
            questionnaireResponses: {
              orderBy: { createdAt: 'desc' },
              take: 1,
              select: {
                id: true,
                valuesAnswers: true,
                personalityAnswers: true,
                relationshipAnswers: true,
                partnerAnswers: true,
                religionAnswers: true,
              }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true,
            email: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                education: true,
                educationLevel: true,
                height: true,
                about: true,
                religiousLevel: true,
                origin: true,
                maritalStatus: true,
                profileCharacterTraits: true,
                profileHobbies: true,
              }
            },
            images: {
              orderBy: { isMain: 'desc' },
              select: { 
                url: true,
                isMain: true,
              }
            },
            // NEW: Include questionnaire responses
            questionnaireResponses: {
              orderBy: { createdAt: 'desc' },
              take: 1,
              select: {
                id: true,
                valuesAnswers: true,
                personalityAnswers: true,
                relationshipAnswers: true,
                partnerAnswers: true,
                religionAnswers: true,
              }
            }
          }
        },
        statusHistory: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          select: {
            id: true,
            status: true,
            notes: true,
            createdAt: true,
          }
        },
      },
    });

    if (!suggestion) {
      return corsError(req, "Suggestion not found", 404);
    }

    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;

    if (!isFirstParty && !isSecondParty) {
      return corsError(req, "Access denied", 403);
    }

    const otherPartyRaw = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
    const notes = isFirstParty ? suggestion.firstPartyNotes : suggestion.secondPartyNotes;

    // Process questionnaire responses
    let questionnaireAnswers: Record<string, any[]> | null = null;
    
    if (otherPartyRaw.questionnaireResponses && otherPartyRaw.questionnaireResponses.length > 0) {
      const qr = otherPartyRaw.questionnaireResponses[0];
      questionnaireAnswers = {};
      
      // Format answers for each world
      (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
        const dbKey = KEY_MAPPING[worldKey];
        const answersJson = qr[dbKey as keyof typeof qr];
        if (answersJson) {
          const formatted = formatAnswers(answersJson);
          // Only include visible answers
          questionnaireAnswers![worldKey] = formatted.filter(a => a.isVisible !== false);
        }
      });
    }

    const otherParty: any = {
      id: otherPartyRaw.id,
      firstName: otherPartyRaw.firstName,
      lastName: otherPartyRaw.lastName,
      age: calculateAge(otherPartyRaw.profile?.birthDate),
      city: otherPartyRaw.profile?.city || null,
      occupation: otherPartyRaw.profile?.occupation || null,
      education: otherPartyRaw.profile?.education || null,
      educationLevel: otherPartyRaw.profile?.educationLevel || null,
      height: otherPartyRaw.profile?.height || null,
      about: otherPartyRaw.profile?.about || null,
      religiousLevel: otherPartyRaw.profile?.religiousLevel || null,
      origin: otherPartyRaw.profile?.origin || null,
      maritalStatus: otherPartyRaw.profile?.maritalStatus || null,
      characterTraits: otherPartyRaw.profile?.profileCharacterTraits || [],
      hobbies: otherPartyRaw.profile?.profileHobbies || [],
      images: otherPartyRaw.images?.map(img => img.url) || [],
      mainImage: otherPartyRaw.images?.find(img => img.isMain)?.url || otherPartyRaw.images?.[0]?.url || null,
      // NEW: Add questionnaire answers
      questionnaireAnswers,
    };

    const showContactDetails = suggestion.status === 'CONTACT_DETAILS_SHARED';

    if (showContactDetails) {
      otherParty.phone = otherPartyRaw.phone;
      otherParty.email = otherPartyRaw.email;
    }

    const canRespond = 
      (isFirstParty && suggestion.status === 'PENDING_FIRST_PARTY') ||
      (isSecondParty && suggestion.status === 'PENDING_SECOND_PARTY');

    const responseData = {
      id: suggestion.id,
      status: suggestion.status,
      priority: suggestion.priority,
      matchingReason: suggestion.matchingReason,
      notes: notes,
      createdAt: suggestion.createdAt,
      updatedAt: suggestion.updatedAt,
      decisionDeadline: suggestion.decisionDeadline,
      lastStatusChange: suggestion.lastStatusChange,
      isFirstParty,
      canRespond,
      showContactDetails,
      matchmaker: {
        firstName: suggestion.matchmaker.firstName,
        lastName: suggestion.matchmaker.lastName,
        ...(showContactDetails && {
          phone: suggestion.matchmaker.phone,
          email: suggestion.matchmaker.email,
        }),
      },
      otherParty,
      statusHistory: suggestion.statusHistory,
    };

    console.log(`[mobile/suggestions/${suggestionId}] Fetched for user ${userId}, isFirstParty: ${isFirstParty}, hasQuestionnaire: ${!!questionnaireAnswers}`);

    return corsJson(req, {
      success: true,
      data: responseData,
    });

  } catch (error) {
    console.error("[mobile/suggestions/[id]] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\chat
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\chat\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/[id]/chat/route.ts
// =============================================================================
// Mobile Chat API - Fixed Authentication (Token based instead of Session)
// =============================================================================

import { NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { notifyMatchmakerNewMessage } from '@/lib/pushNotifications';
import { 
  verifyMobileToken, 
  corsJson, 
  corsError, 
  corsOptions 
} from "@/lib/mobile-auth";

// Handle CORS Preflight
export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

// ==========================================
// GET — Fetch messages
// ==========================================
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;
    
    // 1. Verify Mobile Token instead of Server Session
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const userId = auth.userId;

    // Verify user is party to this suggestion
    const suggestion = await prisma.matchSuggestion.findFirst({
      where: {
        id: suggestionId,
        OR: [{ firstPartyId: userId }, { secondPartyId: userId }],
      },
      include: {
        matchmaker: {
          select: { id: true, firstName: true, lastName: true },
        },
      },
    });

    if (!suggestion) {
      return corsError(req, 'Suggestion not found', 404);
    }

    const isFirstParty = suggestion.firstPartyId === userId;

    // Fetch messages relevant to this user
    const messages = await prisma.suggestionMessage.findMany({
      where: {
        suggestionId,
        OR: [
          { senderId: userId, senderType: 'USER' },
          {
            senderType: 'MATCHMAKER',
            OR: [
              { targetUserId: userId },
              { targetUserId: null },
            ],
          },
          { senderType: 'SYSTEM' },
        ],
      },
      orderBy: { createdAt: 'asc' },
      select: {
        id: true,
        content: true,
        senderId: true,
        senderType: true,
        isRead: true,
        createdAt: true,
        targetUserId: true,
      },
    });

    const formattedMessages = messages.map((msg) => ({
      id: msg.id,
      content: msg.content,
      senderId: msg.senderId,
      senderType: msg.senderType,
      senderName:
        msg.senderType === 'MATCHMAKER'
          ? `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          : msg.senderType === 'SYSTEM'
            ? 'מערכת'
            : 'אני', // באפליקציה, הודעות שלי הן תמיד "אני"
      isRead: msg.isRead,
      createdAt: msg.createdAt.toISOString(),
      isMine: msg.senderId === userId,
    }));

    return corsJson(req, {
      success: true,
      messages: formattedMessages,
      matchmaker: {
        id: suggestion.matchmaker.id,
        name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`,
      },
      isFirstParty,
    });
  } catch (error) {
    console.error('[mobile/suggestion-chat] GET error:', error);
    return corsError(req, 'Internal server error', 500);
  }
}

// ==========================================
// POST — Send message
// ==========================================
export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    // 1. Verify Mobile Token
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const userId = auth.userId;
    const { content } = await req.json();

    if (!content?.trim()) {
      return corsError(req, 'Message content is required', 400);
    }

    const suggestion = await prisma.matchSuggestion.findFirst({
      where: {
        id: suggestionId,
        OR: [{ firstPartyId: userId }, { secondPartyId: userId }],
      },
      select: {
        id: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      },
    });

    if (!suggestion) {
      return corsError(req, 'Suggestion not found', 404);
    }

    // Get user details for notification (optional but good for push)
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { firstName: true, lastName: true }
    });

    const userName = user ? `${user.firstName} ${user.lastName}` : 'מועמד/ת';

    const message = await prisma.suggestionMessage.create({
      data: {
        suggestionId,
        content: content.trim(),
        senderId: userId,
        senderType: 'USER',
        targetUserId: suggestion.matchmakerId,
      },
    });

    // Push notification to matchmaker
    if (suggestion.matchmakerId) {
      notifyMatchmakerNewMessage({
        matchmakerUserId: suggestion.matchmakerId,
        senderName: userName,
        messagePreview: content.trim(),
        suggestionId,
      }).catch((err) =>
        console.error('[mobile/suggestion-chat] Push error:', err)
      );
    }

    return corsJson(req, {
      success: true,
      message: {
        id: message.id,
        content: message.content,
        senderId: message.senderId,
        senderType: message.senderType,
        senderName: 'אני',
        isRead: false,
        createdAt: message.createdAt.toISOString(),
        isMine: true,
      },
    });
  } catch (error) {
    console.error('[mobile/suggestion-chat] POST error:', error);
    return corsError(req, 'Internal server error', 500);
  }
}

// ==========================================
// PATCH — Mark messages as read
// ==========================================
export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    // 1. Verify Mobile Token
    const auth = await verifyMobileToken(req);
    if (!auth) {
      return corsError(req, 'Unauthorized', 401);
    }

    const userId = auth.userId;

    await prisma.suggestionMessage.updateMany({
      where: {
        suggestionId,
        isRead: false,
        NOT: { senderId: userId },
        OR: [
          { targetUserId: userId },
          { targetUserId: null },
          { senderType: 'SYSTEM' },
        ],
      },
      data: { isRead: true },
    });

    return corsJson(req, { success: true });
  } catch (error) {
    console.error('[mobile/suggestion-chat] PATCH error:', error);
    return corsError(req, 'Internal server error', 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\chat\read
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\chat\read\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/mobile/suggestions/[id]/chat/read/route.ts
// ==========================================
// NeshamaTech - Mark Chat Messages as Read
// POST: Mark all messages as read for the current user
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { verifyMobileToken } from "@/lib/mobile-auth";

export async function POST(
  req: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const user = await verifyMobileToken(req);
    if (!user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { id: suggestionId } = await context.params;

    // Verify user is part of this suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      select: { firstPartyId: true, secondPartyId: true },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    const isParty =
      suggestion.firstPartyId === user.userId ||
      suggestion.secondPartyId === user.userId;

    if (!isParty) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    // Mark all messages NOT sent by this user as read
    // (i.e., messages from matchmaker/system that this user hasn't read)
    const result = await prisma.suggestionMessage.updateMany({
      where: {
        suggestionId,
        senderId: { not: user.userId },
        isRead: false,
      },
      data: { isRead: true },
    });

    return NextResponse.json({
      success: true,
      markedCount: result.count,
    });
  } catch (error) {
    console.error("[Mobile Chat Read] Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to mark messages as read" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/[id]/respond/route.ts
// תגובה להצעת שידוך - למובייל
// UPDATED: Added 'interested' response type for "save for later"

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import {
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions,
} from "@/lib/mobile-auth";
import type { MatchSuggestionStatus } from "@prisma/client";

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const params = await props.params;
    const suggestionId = params.id;

    const auth = await verifyMobileToken(req);

    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const body = await req.json();
    const { response, reason, notes } = body as {
      response: "approve" | "decline" | "interested"; // ← NEW: 'interested'
      reason?: string;
      notes?: string;
    };

    if (
      !response ||
      !["approve", "decline", "interested"].includes(response)
    ) {
      return corsError(
        req,
        "Invalid response. Must be 'approve', 'decline', or 'interested'",
        400
      );
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      select: {
        id: true,
        status: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
        firstPartyRank: true,
      },
    });

    if (!suggestion) {
      return corsError(req, "Suggestion not found", 404);
    }

    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;

    if (!isFirstParty && !isSecondParty) {
      return corsError(req, "Access denied", 403);
    }

    // ======================================================================
    // Determine valid transitions
    // ======================================================================

    // For 'interested': only first party from PENDING_FIRST_PARTY
    if (response === "interested") {
      if (!isFirstParty) {
        return corsError(req, "Only first party can save for later", 400);
      }
      if (suggestion.status !== "PENDING_FIRST_PARTY") {
        return corsError(
          req,
          "Can only save for later when pending your response",
          400
        );
      }
    }

    // For 'approve' from FIRST_PARTY_INTERESTED (activating from waitlist)
    const isActivatingFromInterested =
      response === "approve" &&
      isFirstParty &&
      suggestion.status === "FIRST_PARTY_INTERESTED";

    // Standard canRespond check (for approve/decline from PENDING)
    const canRespondStandard =
      (isFirstParty && suggestion.status === "PENDING_FIRST_PARTY") ||
      (isSecondParty && suggestion.status === "PENDING_SECOND_PARTY");

    if (
      response !== "interested" &&
      !canRespondStandard &&
      !isActivatingFromInterested
    ) {
      return corsError(req, "Cannot respond at this stage", 400);
    }

    // For 'decline' from FIRST_PARTY_INTERESTED (removing from waitlist)
    const isRemovingFromInterested =
      response === "decline" &&
      isFirstParty &&
      suggestion.status === "FIRST_PARTY_INTERESTED";

    if (
      response === "decline" &&
      !canRespondStandard &&
      !isRemovingFromInterested
    ) {
      return corsError(req, "Cannot decline at this stage", 400);
    }

    // ======================================================================
    // Determine new status
    // ======================================================================

    let newStatus: MatchSuggestionStatus;

    if (response === "interested") {
      newStatus = "FIRST_PARTY_INTERESTED";
    } else if (response === "approve") {
      newStatus = isFirstParty
        ? "FIRST_PARTY_APPROVED"
        : "SECOND_PARTY_APPROVED";
    } else {
      // decline
      newStatus = isFirstParty
        ? "FIRST_PARTY_DECLINED"
        : "SECOND_PARTY_DECLINED";
    }

    // ======================================================================
    // Build update data
    // ======================================================================

    const updateData: any = {
      status: newStatus,
      lastStatusChange: new Date(),
      lastActivity: new Date(),
    };

    // Handle 'interested' - assign rank
    if (response === "interested") {
      // Find the highest existing rank for this user
      const highestRank = await prisma.matchSuggestion.findFirst({
        where: {
          firstPartyId: userId,
          status: "FIRST_PARTY_INTERESTED",
          id: { not: suggestionId },
        },
        orderBy: { firstPartyRank: "desc" },
        select: { firstPartyRank: true },
      });

      updateData.firstPartyRank = (highestRank?.firstPartyRank ?? 0) + 1;
      updateData.firstPartyInterestedAt = new Date();
    }

    // Handle activation from INTERESTED to APPROVED
    if (isActivatingFromInterested) {
      updateData.firstPartyRank = null;
      updateData.firstPartyResponded = new Date();
    }

    // Handle removal from INTERESTED (decline)
    if (isRemovingFromInterested) {
      updateData.firstPartyRank = null;
      updateData.firstPartyInterestedAt = null;
    }

    // Standard fields
    if (response !== "interested") {
      if (isFirstParty) {
        updateData.firstPartyResponded = new Date();
        if (notes) {
          updateData.firstPartyNotes = notes;
        }
      } else {
        updateData.secondPartyResponded = new Date();
        if (notes) {
          updateData.secondPartyNotes = notes;
        }
      }
    }

    if (response === "decline" && reason) {
      updateData.internalNotes =
        `[${new Date().toISOString()}] ${isFirstParty ? "צד א" : "צד ב"} דחה: ${reason}`.trim();
    }

    // ======================================================================
    // Execute update in transaction
    // ======================================================================

    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // 1. Update the suggestion
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: updateData,
        select: {
          id: true,
          status: true,
          lastStatusChange: true,
        },
      });

      // 2. Create status history entry
      let historyNotes = "";
      if (response === "interested") {
        historyNotes = "צד א שמר לגיבוי";
      } else if (isActivatingFromInterested) {
        historyNotes = "צד א אישר מרשימת ההמתנה";
      } else if (isRemovingFromInterested) {
        historyNotes = reason
          ? `צד א הסיר מרשימת ההמתנה: ${reason}`
          : "צד א הסיר מרשימת ההמתנה";
      } else if (response === "approve") {
        historyNotes = notes || (isFirstParty ? "צד א אישר" : "צד ב אישר");
      } else {
        historyNotes =
          reason || (isFirstParty ? "צד א דחה" : "צד ב דחה");
      }

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status: newStatus,
          notes: historyNotes,
        },
      });

      // 3. Re-rank remaining INTERESTED suggestions if removing/activating
      if (isActivatingFromInterested || isRemovingFromInterested) {
        const remaining = await tx.matchSuggestion.findMany({
          where: {
            firstPartyId: userId,
            status: "FIRST_PARTY_INTERESTED",
          },
          orderBy: { firstPartyRank: "asc" },
          select: { id: true },
        });

        for (let i = 0; i < remaining.length; i++) {
          await tx.matchSuggestion.update({
            where: { id: remaining[i].id },
            data: { firstPartyRank: i + 1 },
          });
        }
      }

      // 4. Handle SECOND_PARTY_APPROVED → CONTACT_DETAILS_SHARED
      if (newStatus === "SECOND_PARTY_APPROVED") {
        const firstPartyApproved =
          await tx.suggestionStatusHistory.findFirst({
            where: {
              suggestionId,
              status: "FIRST_PARTY_APPROVED",
            },
          });

        if (firstPartyApproved) {
          await tx.matchSuggestion.update({
            where: { id: suggestionId },
            data: {
              status: "CONTACT_DETAILS_SHARED",
              lastStatusChange: new Date(),
            },
          });

          await tx.suggestionStatusHistory.create({
            data: {
              suggestionId,
              status: "CONTACT_DETAILS_SHARED",
              notes: "שני הצדדים אישרו - פרטי קשר שותפו",
            },
          });
        }
      }

      return updated;
    });

    console.log(
      `[mobile/suggestions/${suggestionId}/respond] User ${userId} responded: ${response}, new status: ${newStatus}`
    );

    const messageMap = {
      approve: "ההצעה אושרה בהצלחה",
      decline: "ההצעה נדחתה",
      interested: "ההצעה נשמרה ברשימת ההמתנה",
    };

    return corsJson(req, {
      success: true,
      message: messageMap[response],
      data: {
        id: updatedSuggestion.id,
        status: updatedSuggestion.status,
        lastStatusChange: updatedSuggestion.lastStatusChange,
      },
    });
  } catch (error) {
    console.error("[mobile/suggestions/[id]/respond] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/active/route.ts
// הצעות שידוך פעילות - למובייל
// UPDATED: Added FIRST_PARTY_INTERESTED support + firstPartyRank

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import {
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions,
} from "@/lib/mobile-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (
    monthDiff < 0 ||
    (monthDiff === 0 && today.getDate() < birth.getDate())
  ) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);

    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: userId,
            status: {
              in: [
                "PENDING_FIRST_PARTY",
                "FIRST_PARTY_APPROVED",
                "FIRST_PARTY_INTERESTED", // ← NEW
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            },
          },
          {
            secondPartyId: userId,
            status: {
              in: [
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            },
          },
        ],
      },
      include: {
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                height: true,
                about: true,
              },
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
                height: true,
                about: true,
              },
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true },
            },
          },
        },
      },
      orderBy: [
        { firstPartyRank: "asc" }, // INTERESTED suggestions sorted by rank
        { createdAt: "desc" },
      ],
    });

    const suggestions = activeSuggestions.map((suggestion) => {
      const isFirstParty = suggestion.firstPartyId === userId;
      const otherParty = isFirstParty
        ? suggestion.secondParty
        : suggestion.firstParty;
      const notes = isFirstParty
        ? suggestion.firstPartyNotes
        : suggestion.secondPartyNotes;

      return {
        id: suggestion.id,
        status: suggestion.status,
        priority: suggestion.priority,
        matchingReason: suggestion.matchingReason,
        notes: notes,
        matchmaker: suggestion.matchmaker,
        createdAt: suggestion.createdAt,
        updatedAt: suggestion.updatedAt,
        decisionDeadline: suggestion.decisionDeadline,
        isFirstParty,
        // NEW: rank fields for INTERESTED suggestions
        firstPartyRank: suggestion.firstPartyRank,
        firstPartyInterestedAt: suggestion.firstPartyInterestedAt,
        otherParty: {
          id: otherParty.id,
          firstName: otherParty.firstName,
          lastName: otherParty.lastName,
          age: calculateAge(otherParty.profile?.birthDate),
          city: otherParty.profile?.city,
          occupation: otherParty.profile?.occupation,
          height: otherParty.profile?.height,
          about: otherParty.profile?.about,
          image: otherParty.images?.[0]?.url || null,
        },
      };
    });

    console.log(
      `[mobile/suggestions/active] Found ${suggestions.length} active suggestions for user ${userId}`
    );

    return corsJson(req, {
      success: true,
      suggestions,
    });
  } catch (error) {
    console.error("[mobile/suggestions/active] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/history/route.ts
// היסטוריית הצעות שידוך - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions
} from "@/lib/mobile-auth";

function calculateAge(birthDate: Date | null | undefined): number | null {
  if (!birthDate) return null;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function GET(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);
    
    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { 
            firstPartyId: userId, 
            status: { 
              in: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] 
            } 
          },
          { 
            secondPartyId: userId, 
            status: { 
              in: ["SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] 
            } 
          },
        ],
      },
      include: {
        matchmaker: { 
          select: { 
            firstName: true, 
            lastName: true 
          } 
        },
        firstParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
        secondParty: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                birthDate: true,
                city: true,
                occupation: true,
              }
            },
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true }
            }
          }
        },
      },
      orderBy: { updatedAt: "desc" },
    });

    const suggestions = historySuggestions.map(suggestion => {
      const isFirstParty = suggestion.firstPartyId === userId;
      const otherParty = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
      
      return {
        id: suggestion.id,
        status: suggestion.status,
        matchmaker: suggestion.matchmaker,
        createdAt: suggestion.createdAt,
        updatedAt: suggestion.updatedAt,
        closedAt: suggestion.closedAt,
        isFirstParty,
        otherParty: {
          id: otherParty.id,
          firstName: otherParty.firstName,
          lastName: otherParty.lastName,
          age: calculateAge(otherParty.profile?.birthDate),
          city: otherParty.profile?.city,
          occupation: otherParty.profile?.occupation,
          image: otherParty.images?.[0]?.url || null,
        }
      };
    });

    console.log(`[mobile/suggestions/history] Found ${suggestions.length} history suggestions for user ${userId}`);

    return corsJson(req, {
      success: true,
      suggestions,
    });

  } catch (error) {
    console.error("[mobile/suggestions/history] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\interested
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\interested\rank
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\mobile\suggestions\interested\rank\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/mobile/suggestions/interested/rank/route.ts
// עדכון סדר עדיפויות של הצעות INTERESTED - למובייל

import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import {
  verifyMobileToken,
  corsJson,
  corsError,
  corsOptions,
} from "@/lib/mobile-auth";

export async function OPTIONS(req: NextRequest) {
  return corsOptions(req);
}

export async function PUT(req: NextRequest) {
  try {
    const auth = await verifyMobileToken(req);

    if (!auth) {
      return corsError(req, "Unauthorized", 401);
    }

    const userId = auth.userId;
    const body = await req.json();
    const { rankedSuggestionIds } = body as { rankedSuggestionIds: string[] };

    if (
      !rankedSuggestionIds ||
      !Array.isArray(rankedSuggestionIds) ||
      rankedSuggestionIds.length === 0
    ) {
      return corsError(req, "rankedSuggestionIds is required", 400);
    }

    // Verify all suggestions belong to this user and are INTERESTED
    const suggestions = await prisma.matchSuggestion.findMany({
      where: {
        id: { in: rankedSuggestionIds },
        firstPartyId: userId,
        status: "FIRST_PARTY_INTERESTED",
      },
      select: { id: true },
    });

    const validIds = new Set(suggestions.map((s) => s.id));
    const invalidIds = rankedSuggestionIds.filter((id) => !validIds.has(id));

    if (invalidIds.length > 0) {
      return corsError(req, "Some suggestions are not valid for ranking", 400);
    }

    // Update ranks in transaction
    await prisma.$transaction(
      rankedSuggestionIds.map((id, index) =>
        prisma.matchSuggestion.update({
          where: { id },
          data: {
            firstPartyRank: index + 1,
            lastActivity: new Date(),
          },
        })
      )
    );

    console.log(
      `[mobile/suggestions/interested/rank] User ${userId} reordered ${rankedSuggestionIds.length} suggestions`
    );

    return corsJson(req, {
      success: true,
      message: "Ranks updated successfully",
      count: rankedSuggestionIds.length,
    });
  } catch (error) {
    console.error("[mobile/suggestions/interested/rank] Error:", error);
    return corsError(req, "Internal server error", 500);
  }
}
--- End of Content for route.ts ---

