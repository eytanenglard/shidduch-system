################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker
# Generated on: 2026-01-25 15:07:18
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\alerts
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\alerts\route.ts
--------------------------------------------------------------------------------
Content:
// =============================================================================
// ğŸ“ src/app/api/matchmaker/alerts/route.ts
// =============================================================================
// ğŸ¯ Alerts Management API V1.0 - NeshamaTech
// =============================================================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import alertsService, { type AlertSeverity, type AlertType } from "@/lib/services/alertsService";
import { UserRole } from "@prisma/client";

// =============================================================================
// Types
// =============================================================================

interface SessionUser {
  id: string;
  role: UserRole;
}

// =============================================================================
// GET - ×§×‘×œ×ª ×”×ª×¨××•×ª
// =============================================================================

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const user = session.user as SessionUser;
    if (user.role !== UserRole.MATCHMAKER && user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { error: "Access denied" },
        { status: 403 }
      );
    }
    
    const searchParams = request.nextUrl.searchParams;
    
    // ×¤×¨××˜×¨×™×
    const severity = searchParams.get('severity') as AlertSeverity | null;
    const type = searchParams.get('type') as AlertType | null;
    const limit = parseInt(searchParams.get('limit') || '50');
    const includeRead = searchParams.get('includeRead') === 'true';
    const userId = searchParams.get('userId');
    const summary = searchParams.get('summary') === 'true';
    
    // ×× ××‘×§×©×™× ×¡×™×›×•×
    if (summary) {
      const alertsSummary = await alertsService.getAlertsSummary();
      return NextResponse.json(alertsSummary);
    }
    
    // ×× ××‘×§×©×™× ×”×ª×¨××•×ª ×œ××©×ª××© ×¡×¤×¦×™×¤×™
    if (userId) {
      const userAlerts = await alertsService.getAlertsForUser(userId);
      return NextResponse.json({ alerts: userAlerts });
    }
    
    // ×”×ª×¨××•×ª ×›×œ×œ×™×•×ª
    const alerts = await alertsService.getActiveAlerts({
      severity: severity || undefined,
      type: type || undefined,
      limit,
      includeRead,
    });
    
    return NextResponse.json({ 
      alerts,
      count: alerts.length,
    });
    
  } catch (error) {
    console.error("[Alerts API] Error:", error);
    
    return NextResponse.json(
      { error: "Failed to fetch alerts" },
      { status: 500 }
    );
  }
}

// =============================================================================
// POST - ×¤×¢×•×œ×•×ª ×¢×œ ×”×ª×¨××•×ª
// =============================================================================

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const user = session.user as SessionUser;
    if (user.role !== UserRole.MATCHMAKER && user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { error: "Access denied" },
        { status: 403 }
      );
    }
    
    const currentUserId = user.id;
    const body = await request.json();
    const { action, alertId, alertIds, reason } = body;
    
    switch (action) {
      case 'mark_read': {
        if (alertId) {
          await alertsService.markAlertAsRead(alertId);
          return NextResponse.json({ success: true });
        }
        if (alertIds && Array.isArray(alertIds)) {
          const count = await alertsService.markAlertsAsRead(alertIds);
          return NextResponse.json({ success: true, count });
        }
        return NextResponse.json(
          { error: "alertId or alertIds required" },
          { status: 400 }
        );
      }
        
      case 'dismiss': {
        if (alertId) {
          await alertsService.dismissAlert(alertId, currentUserId, reason);
          return NextResponse.json({ success: true });
        }
        if (alertIds && Array.isArray(alertIds)) {
          const count = await alertsService.dismissAlerts(alertIds, currentUserId, reason);
          return NextResponse.json({ success: true, count });
        }
        return NextResponse.json(
          { error: "alertId or alertIds required" },
          { status: 400 }
        );
      }
        
      case 'generate': {
        // ×™×¦×™×¨×ª ×”×ª×¨××•×ª ×—×“×©×•×ª
        const result = await alertsService.generateAllAlerts();
        return NextResponse.json({ 
          success: true, 
          ...result 
        });
      }
        
      case 'cleanup': {
        // × ×™×§×•×™ ×”×ª×¨××•×ª ×™×©× ×•×ª
        const daysOld = body.daysOld || 30;
        const deleted = await alertsService.cleanupOldAlerts(daysOld);
        return NextResponse.json({ 
          success: true, 
          deleted 
        });
      }
        
      case 'create': {
        // ×™×¦×™×¨×ª ×”×ª×¨××” ×™×“× ×™×ª
        const { userId: targetUserId, type, severity, title, message, data } = body;
        
        if (!targetUserId || !type || !severity || !title || !message) {
          return NextResponse.json(
            { error: "Missing required fields" },
            { status: 400 }
          );
        }
        
        const newAlertId = await alertsService.createAlert({
          userId: targetUserId,
          type,
          severity,
          title,
          message,
          data,
        });
        
        return NextResponse.json({ 
          success: true, 
          alertId: newAlertId 
        });
      }
        
      default:
        return NextResponse.json(
          { error: "Unknown action" },
          { status: 400 }
        );
    }
    
  } catch (error) {
    console.error("[Alerts API] POST Error:", error);
    
    return NextResponse.json(
      { error: "Action failed" },
      { status: 500 }
    );
  }
}

// =============================================================================
// DELETE - ××—×™×§×ª ×”×ª×¨××•×ª
// =============================================================================

export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const user = session.user as SessionUser;
    if (user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { error: "Admin access required" },
        { status: 403 }
      );
    }
    
    const searchParams = request.nextUrl.searchParams;
    const daysOld = parseInt(searchParams.get('daysOld') || '30');
    
    const deleted = await alertsService.cleanupOldAlerts(daysOld);
    
    return NextResponse.json({ 
      success: true, 
      deleted 
    });
    
  } catch (error) {
    console.error("[Alerts API] DELETE Error:", error);
    
    return NextResponse.json(
      { error: "Delete failed" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
# Generated on: 2026-01-25 11:45:44
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';

export const dynamic = 'force-dynamic';

const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
   // ×—×¤×© ××ª ×”×©×•×¨×” ×¡×‘×™×‘ 13 ×‘×ª×•×š prisma.user.findMany
const users = await prisma.user.findMany({
  where: {
    status: { notIn: ['BLOCKED', 'INACTIVE'] },
    role: 'CANDIDATE',
    profile: { isNot: null },
  },
  select: {
    id: true,
    email: true,
    firstName: true,
    lastName: true,
    phone: true,
    status: true,
    source: true,
    createdAt: true,
    isVerified: true,
    isProfileComplete: true,
    images: {
      select: { id: true, url: true, isMain: true },
      orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
    },
    // ×©×™× ×•×™ ×›××Ÿ: ×-profile: true ×œ××‘× ×” include
    profile: {
      include: {
        testimonials: {
          where: { status: 'APPROVED' } // ×‘×¨×©×™××” ×”×›×œ×œ×™×ª × ×¨×¦×” ××•×œ×™ ×¨×§ ×××•×©×¨×•×ª
        }
      }
    },
  },
});

    // ================== ğŸš¨ START SERVER DEBUG: LINOY ğŸš¨ ==================
    const targetEmail = 'linoyreznik032@gmail.com';
    const foundUser = users.find(u => u.email === targetEmail);

    console.log('\n-----------------------------------------------------');
    console.log(`ğŸ” [API DEBUG] Checking for user: ${targetEmail}`);
    
    if (foundUser) {
        console.log('âœ… SUCCESS: User exists in the API response list.');
        console.log('   User Data:', JSON.stringify({
            id: foundUser.id,
            status: foundUser.status,
            role: 'CANDIDATE (verified by query)',
            hasProfile: !!foundUser.profile,
            gender: foundUser.profile?.gender,
            birthDate: foundUser.profile?.birthDate
        }, null, 2));
    } else {
        console.log('âŒ FAILURE: User is MISSING from the main list.');
        console.log('   Running direct DB check to investigate why...');

        // ×‘×“×™×§×” ×™×©×™×¨×” ××•×œ ×”×“××˜×” ×‘×™×™×¡ ×œ×œ× ×¤×™×œ×˜×¨×™×
        const directCheck = await prisma.user.findUnique({
            where: { email: targetEmail },
            include: { profile: true }
        });

        if (!directCheck) {
            console.log('   ğŸ’€ FATAL: User does not exist in the Database at all.');
        } else {
            console.log('   ğŸ§ DIAGNOSIS - Why was she filtered out?');
            console.log(`   1. Email: ${directCheck.email}`);
            
            // ×‘×“×™×§×ª ×¡×˜×˜×•×¡
            const statusOk = !['BLOCKED', 'INACTIVE'].includes(directCheck.status);
            console.log(`   2. Status: ${directCheck.status} [${statusOk ? 'OK' : 'FAIL - Blocked or Inactive'}]`);
            
            // ×‘×“×™×§×ª ×ª×¤×§×™×“
            const roleOk = directCheck.role === 'CANDIDATE';
            console.log(`   3. Role: ${directCheck.role} [${roleOk ? 'OK' : 'FAIL - Must be CANDIDATE'}]`);
            
            // ×‘×“×™×§×ª ×¤×¨×•×¤×™×œ
            const profileExists = !!directCheck.profile;
            console.log(`   4. Profile Exists: ${profileExists} [${profileExists ? 'OK' : 'FAIL - Profile is null'}]`);

            if (profileExists) {
                console.log('      Profile Details:', JSON.stringify(directCheck.profile, null, 2));
            }
        }
    }
    console.log('-----------------------------------------------------\n');
    // ================== ğŸš¨ END SERVER DEBUG ğŸš¨ ==================


    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
// Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
              // --- ×”×•×¡×¤×”: ×”×–×¨×§×ª ×¤×¨×˜×™ ×”××©×ª××© ×œ×ª×•×š ×”×¤×¨×•×¤×™×œ ×¢×‘×•×¨ ProfileCard ---
              user: {
                id: user.id,
                firstName: user.firstName,
                lastName: user.lastName,
                email: user.email,
                phone: user.phone, // <--- ×”× ×” ×”×˜×œ×¤×•×Ÿ ×©×”×™×” ×—×¡×¨ ×‘×§×•××¤×•× × ×˜×”
              }
              // -----------------------------------------------------------
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      // console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        // console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile, generateNarrativeProfile } from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import { Locale } from "../../../../../../i18n-config";
import { emailService } from "@/lib/email/emailService";

export const dynamic = 'force-dynamic';

/**
 * GET: ××—×–×•×¨ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“ ×¡×¤×¦×™×¤×™.
 * × ×’×™×© ×œ×©×“×›× ×™× ×•×× ×”×œ×™×.
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params;
    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: {
          include: {
            testimonials: true
          }
        },
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

/**
 * PATCH: ×¢×“×›×•×Ÿ ×¤×¨×˜×™ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“.
 * ××‘×¦×¢ ×¢×“×›×•×Ÿ ×‘-DB ×•××™×“ ×œ××—×¨ ××›×Ÿ ××¤×¢×™×œ ×ª×”×œ×™×š ×¨×§×¢ ×œ×¢×“×›×•×Ÿ ×”×•×•×§×˜×•×¨ ×•×¡×™×›×•× ×”-AI.
 */
export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const url = new URL(req.url);
    const locale = (url.searchParams.get('locale') as Locale) || 'he';

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true, firstName: true, lastName: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const params = await props.params;
    const { id: candidateIdToUpdate } = params;

    const candidateToUpdate = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true, email: true, firstName: true, lastName: true }
    });

    if (!candidateToUpdate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateToUpdate.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const incomingData = await req.json();

    // --- ×—×™×œ×•×¥ ×©×“×•×ª User (×©× ×¤×¨×˜×™/××©×¤×—×”) ---
    const { firstName, lastName, ...profileDataRaw } = incomingData;

    // ×¢×“×›×•×Ÿ ×˜×‘×œ×ª User ×× × ×©×œ×—×• ×©××•×ª
    if (firstName || lastName) {
      await prisma.user.update({
        where: { id: candidateIdToUpdate },
        data: {
          firstName: firstName || undefined,
          lastName: lastName || undefined,
        },
      });
    }

    // ×”×›× ×ª × ×ª×•× ×™× ×œ×¢×“×›×•×Ÿ ×˜×‘×œ×ª Profile
    const originalProfile = await prisma.profile.findUnique({
        where: { userId: candidateIdToUpdate },
        select: { manualEntryText: true }
    });
    
    const dataForUpdate: Prisma.ProfileUpdateInput = {};

    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation', 'manualEntryText', 'about', 'profileHeadline'];
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious',  'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible', 'birthDateIsApproximate'];
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    const dateFields = ['birthDate'];

    for (const key in profileDataRaw) {
      if (Object.prototype.hasOwnProperty.call(profileDataRaw, key)) {
        const value = profileDataRaw[key];

        if (numericFields.includes(key)) {
            if (value === "" || value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else {
                const parsed = parseInt(String(value), 10);
                dataForUpdate[key] = isNaN(parsed) ? null : parsed;
            }
        } else if (stringAndEnumFields.includes(key)) {
            dataForUpdate[key] = (value === "" || value === undefined) ? null : value;
        } else if (booleanFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else if (typeof value === 'boolean') {
                dataForUpdate[key] = value;
            } else {
                dataForUpdate[key] = value === 'true';
            }
        } else if (arrayFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = [];
            } else if (Array.isArray(value)) {
                dataForUpdate[key] = value;
            }
        } else if (dateFields.includes(key)) {
            if (value) {
                const date = new Date(value);
                if (!isNaN(date.getTime())) {
                    dataForUpdate[key] = date;
                }
            } else {
                dataForUpdate[key] = null;
            }
        }
      }
    }
    
    let updatedProfile: any = null;

    // ×‘×™×¦×•×¢ ×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ
    if (Object.keys(dataForUpdate).length > 0) {
        updatedProfile = await prisma.profile.update({
          where: { userId: candidateIdToUpdate },
          data: {
            ...dataForUpdate,
            updatedAt: new Date(),
            lastActive: new Date(),
            needsAiProfileUpdate: true, // ××¡×× ×™× ×–×× ×™×ª ×©×¦×¨×™×š ×¢×“×›×•×Ÿ, ×¢×“ ×©×ª×”×œ×™×š ×”×¨×§×¢ ×™×¡×ª×™×™×
          }
        });

        // ×‘×“×™×§×” ×× ×”×©×ª× ×” ×”-manualEntryText ×œ×©×œ×™×—×ª ×”×ª×¨××”
        const newSummaryText = incomingData.manualEntryText;
        const oldSummaryText = originalProfile?.manualEntryText;

        if (newSummaryText !== undefined && newSummaryText.trim() !== '' && newSummaryText !== oldSummaryText) {
            try {
                await emailService.sendProfileSummaryUpdateEmail({
                    locale,
                    email: candidateToUpdate.email,
                    firstName: candidateToUpdate.firstName,
                    matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š"
                });
                console.log(`[Email Notification] Profile summary update email sent successfully to ${candidateToUpdate.email}.`);
            } catch (emailError) {
                console.error(`[Email Notification] Failed to send profile summary update email`, emailError);
            }
        }

        // =================================================================================
        // ğŸ”¥ ×¢×“×›×•×Ÿ ×¨×§×¢ (Background Process) - ×•×•×§×˜×•×¨ + ×¡×™×›×•× AI ğŸ”¥
        // =================================================================================
        // ×× ×—× ×• ××¨×™×¦×™× ××ª ×”×¤×•× ×§×¦×™×” ×”×–×• ×œ×œ× await ×›×“×™ ×œ× ×œ×¢×›×‘ ××ª ×”×ª×©×•×‘×” ×œ×œ×§×•×—
        (async () => {
            try {
                console.log(`[Background Update] Starting full AI update for user ${candidateIdToUpdate}...`);
                
                // 1. ×¢×“×›×•×Ÿ ×•×•×§×˜×•×¨ (×¢×‘×•×¨ ×× ×•×¢ ×”×—×™×¤×•×©)
                await updateUserAiProfile(candidateIdToUpdate);
                console.log(`[Background Update] Vector updated successfully.`);

                // 2. ×¢×“×›×•×Ÿ ×¡×™×›×•× ×¤×¨×•×¤×™×œ (AI Summary)
                // ×©×œ×‘ ×': ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘ ×”××™×œ×•×œ×™ ×”××¢×•×“×›×Ÿ
                const narrative = await generateNarrativeProfile(candidateIdToUpdate);
                
                if (narrative) {
                    // ×©×œ×‘ ×‘': ×©×œ×™×—×” ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
                    const summary = await aiService.generateProfileSummary(narrative);
                    
                    if (summary) {
                        // ×©×œ×‘ ×’': ×©××™×¨×” ×‘-DB ×•×›×™×‘×•×™ ×”×“×’×œ
                        await prisma.profile.update({
                            where: { userId: candidateIdToUpdate },
                            data: { 
                                aiProfileSummary: summary as any, // ×”××¨×” ×œ×¤×•×¨××˜ JSON ×©×œ ×¤×¨×™×–××”
                                needsAiProfileUpdate: false 
                            }
                        });
                        console.log(`[Background Update] AI Summary updated and saved successfully.`);
                    } else {
                        console.warn(`[Background Update] AI returned null summary.`);
                    }
                } else {
                    console.warn(`[Background Update] Failed to generate narrative.`);
                }
            } catch (err) {
                console.error(`[Background Update] Failed for candidate ${candidateIdToUpdate}:`, err);
            }
        })();
        // =================================================================================
    }

    // ×× ×œ× ×¢×•×“×›×Ÿ ×¤×¨×•×¤×™×œ (×œ××©×œ ×¨×§ ×©× ××©×ª××©), × ×©×œ×•×£ ××ª ×”×§×™×™×
    if (!updatedProfile) {
        updatedProfile = await prisma.profile.findUnique({ where: { userId: candidateIdToUpdate } });
    }

    return NextResponse.json({
        success: true,
        profile: updatedProfile,
        user: {
            firstName: firstName || candidateToUpdate.firstName,
            lastName: lastName || candidateToUpdate.lastName
        }
    });

  } catch (error) {
    console.error("Error updating candidate profile:", error);
    
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `×©×’×™××”: × ×¨××” ×©××—×“ ×”×©×“×•×ª ×©×”×–× ×ª (×›××• ××™×™×œ ××• ×˜×œ×¤×•×Ÿ) ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "×”×¤×¨×•×¤×™×œ ×œ× × ××¦×.";
            statusCode = 404;
        } else {
            errorMessage = `×©×’×™××ª ××¡×“ × ×ª×•× ×™× (×§×•×“ ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        errorMessage = `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘× ×ª×•× ×™×.`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

/**
 * DELETE: ××—×™×§×ª ××•×¢××“.
 * × ×’×™×© ×œ×× ×”×œ×™× ×‘×œ×‘×“.
 */
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const timestamp = new Date().toISOString();
  
  const params = await props.params;
  const candidateIdToDelete = params.id;
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role.`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. ×œ× ×–×•×”×ª×” ×¡×©×Ÿ ×¤×¢×™×œ ××• ×”×¨×©××”.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. × ×“×¨×©×ª ×”×¨×©××ª ××“××™×Ÿ.' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    return NextResponse.json(
        { success: false, error: '××–×”×” ××•×¢××“ (candidateId) ×—×¡×¨.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    return NextResponse.json(
        { success: false, error: '×× ×”×œ ××™× ×• ×™×›×•×œ ×œ××—×•×§ ××ª ×—×©×‘×•× ×• ×”××™×©×™ ×“×¨×š ×××©×§ ×–×”.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      return NextResponse.json(
        { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.' },
        { status: 404 }
      );
    }

    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '×”××•×¢××“ × ××—×§ ×‘×”×¦×œ×—×”.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            return NextResponse.json(
                { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.'},
                { status: 404 }
            );
        }
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘××—×™×§×ª ×”××•×¢××“ (×§×•×“: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘××—×™×§×ª ×”××•×¢××“.`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '×©×’×™××” ×œ× ×™×“×•×¢×”.';
    return NextResponse.json(
      {
        success: false,
        error: '××™×¨×¢×” ×©×’×™××” ×‘××—×™×§×ª ×”××•×¢××“.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    // Await params before destructuring
    const params = await props.params;
    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/main/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const imageToSetMain = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    await prisma.$transaction([
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId }
        },
        data: { isMain: false }
      }),
      
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';

export async function POST(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    const params = await props.params;
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×ª×§×™× ×” ×”×™× ×©×“×” ×—×•×‘×”." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    const expiresInHours = 72;
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    await prisma.$transaction(async (tx) => {
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id },
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    const expiresInText = locale === 'he' ? '3 ×™××™×' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale,
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    return NextResponse.json({ success: true, message: "×”×–×× ×” ×œ×”×’×“×¨×ª ×—×©×‘×•×Ÿ × ×©×œ×—×” ×‘×”×¦×œ×—×”." });

  } catch (error) {
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ××©×•×™×›×ª ×œ×—×©×‘×•×Ÿ ××—×¨." },
          { status: 409 }
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×ª ×”×”×–×× ×”.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const heightStr = formData.get('height') as string | null;
    
    // --- START: Added Religious Level ---
    const religiousLevel = formData.get('religiousLevel') as string | null;
    // --- END: Added Religious Level ---

    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---
    let height: number | null = null;
    if (heightStr && heightStr.trim() !== '') {
        const parsedHeight = parseInt(heightStr, 10);
        if (!isNaN(parsedHeight)) {
            height = parsedHeight;
        }
    }

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
      isProfileVisible: true, 
      height: height,
      religiousLevel: religiousLevel, // Add to Prisma Create Object
    };

    // --- START: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for candidates_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';

export const dynamic = 'force-dynamic';

const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
   // ×—×¤×© ××ª ×”×©×•×¨×” ×¡×‘×™×‘ 13 ×‘×ª×•×š prisma.user.findMany
const users = await prisma.user.findMany({
  where: {
    status: { notIn: ['BLOCKED', 'INACTIVE'] },
    role: 'CANDIDATE',
    profile: { isNot: null },
  },
  select: {
    id: true,
    email: true,
    firstName: true,
    lastName: true,
    phone: true,
    status: true,
    source: true,
    createdAt: true,
    isVerified: true,
    isProfileComplete: true,
images: {
  select: { 
    id: true, 
    url: true, 
    isMain: true,
    cloudinaryPublicId: true // <--- ×”×•×¡×£ ×©×•×¨×” ×–×•
  },
  orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
},
    // ×©×™× ×•×™ ×›××Ÿ: ×-profile: true ×œ××‘× ×” include
    profile: {
      include: {
        testimonials: {
          where: { status: 'APPROVED' } // ×‘×¨×©×™××” ×”×›×œ×œ×™×ª × ×¨×¦×” ××•×œ×™ ×¨×§ ×××•×©×¨×•×ª
        }
      }
    },
  },
});

    // ================== ğŸš¨ START SERVER DEBUG: LINOY ğŸš¨ ==================
    const targetEmail = 'linoyreznik032@gmail.com';
    const foundUser = users.find(u => u.email === targetEmail);

    console.log('\n-----------------------------------------------------');
    console.log(`ğŸ” [API DEBUG] Checking for user: ${targetEmail}`);
    
    if (foundUser) {
        console.log('âœ… SUCCESS: User exists in the API response list.');
        console.log('   User Data:', JSON.stringify({
            id: foundUser.id,
            status: foundUser.status,
            role: 'CANDIDATE (verified by query)',
            hasProfile: !!foundUser.profile,
            gender: foundUser.profile?.gender,
            birthDate: foundUser.profile?.birthDate
        }, null, 2));
    } else {
        console.log('âŒ FAILURE: User is MISSING from the main list.');
        console.log('   Running direct DB check to investigate why...');

        // ×‘×“×™×§×” ×™×©×™×¨×” ××•×œ ×”×“××˜×” ×‘×™×™×¡ ×œ×œ× ×¤×™×œ×˜×¨×™×
        const directCheck = await prisma.user.findUnique({
            where: { email: targetEmail },
            include: { profile: true }
        });

        if (!directCheck) {
            console.log('   ğŸ’€ FATAL: User does not exist in the Database at all.');
        } else {
            console.log('   ğŸ§ DIAGNOSIS - Why was she filtered out?');
            console.log(`   1. Email: ${directCheck.email}`);
            
            // ×‘×“×™×§×ª ×¡×˜×˜×•×¡
            const statusOk = !['BLOCKED', 'INACTIVE'].includes(directCheck.status);
            console.log(`   2. Status: ${directCheck.status} [${statusOk ? 'OK' : 'FAIL - Blocked or Inactive'}]`);
            
            // ×‘×“×™×§×ª ×ª×¤×§×™×“
            const roleOk = directCheck.role === 'CANDIDATE';
            console.log(`   3. Role: ${directCheck.role} [${roleOk ? 'OK' : 'FAIL - Must be CANDIDATE'}]`);
            
            // ×‘×“×™×§×ª ×¤×¨×•×¤×™×œ
            const profileExists = !!directCheck.profile;
            console.log(`   4. Profile Exists: ${profileExists} [${profileExists ? 'OK' : 'FAIL - Profile is null'}]`);

            if (profileExists) {
                console.log('      Profile Details:', JSON.stringify(directCheck.profile, null, 2));
            }
        }
    }
    console.log('-----------------------------------------------------\n');
    // ================== ğŸš¨ END SERVER DEBUG ğŸš¨ ==================


    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
// Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
              // --- ×”×•×¡×¤×”: ×”×–×¨×§×ª ×¤×¨×˜×™ ×”××©×ª××© ×œ×ª×•×š ×”×¤×¨×•×¤×™×œ ×¢×‘×•×¨ ProfileCard ---
              user: {
                id: user.id,
                firstName: user.firstName,
                lastName: user.lastName,
                email: user.email,
                phone: user.phone, // <--- ×”× ×” ×”×˜×œ×¤×•×Ÿ ×©×”×™×” ×—×¡×¨ ×‘×§×•××¤×•× × ×˜×”
              }
              // -----------------------------------------------------------
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      // console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        // console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile, generateNarrativeProfile } from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import { Locale } from "../../../../../../i18n-config";
import { emailService } from "@/lib/email/emailService";

export const dynamic = 'force-dynamic';

/**
 * GET: ××—×–×•×¨ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“ ×¡×¤×¦×™×¤×™.
 * × ×’×™×© ×œ×©×“×›× ×™× ×•×× ×”×œ×™×.
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params;
    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: {
          include: {
            testimonials: true
          }
        },
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

/**
 * PATCH: ×¢×“×›×•×Ÿ ×¤×¨×˜×™ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“.
 * ××‘×¦×¢ ×¢×“×›×•×Ÿ ×‘-DB ×•××™×“ ×œ××—×¨ ××›×Ÿ ××¤×¢×™×œ ×ª×”×œ×™×š ×¨×§×¢ ×œ×¢×“×›×•×Ÿ ×”×•×•×§×˜×•×¨ ×•×¡×™×›×•× ×”-AI.
 */
export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const url = new URL(req.url);
    const locale = (url.searchParams.get('locale') as Locale) || 'he';

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true, firstName: true, lastName: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const params = await props.params;
    const { id: candidateIdToUpdate } = params;

    const candidateToUpdate = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true, email: true, firstName: true, lastName: true }
    });

    if (!candidateToUpdate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateToUpdate.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const incomingData = await req.json();

    // --- ×—×™×œ×•×¥ ×©×“×•×ª User (×©× ×¤×¨×˜×™/××©×¤×—×”) ---
    const { firstName, lastName, ...profileDataRaw } = incomingData;

    // ×¢×“×›×•×Ÿ ×˜×‘×œ×ª User ×× × ×©×œ×—×• ×©××•×ª
    if (firstName || lastName) {
      await prisma.user.update({
        where: { id: candidateIdToUpdate },
        data: {
          firstName: firstName || undefined,
          lastName: lastName || undefined,
        },
      });
    }

    // ×”×›× ×ª × ×ª×•× ×™× ×œ×¢×“×›×•×Ÿ ×˜×‘×œ×ª Profile
    const originalProfile = await prisma.profile.findUnique({
        where: { userId: candidateIdToUpdate },
        select: { manualEntryText: true }
    });
    
    const dataForUpdate: Prisma.ProfileUpdateInput = {};

    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation', 'manualEntryText', 'about', 'profileHeadline'];
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious',  'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible', 'birthDateIsApproximate'];
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    const dateFields = ['birthDate'];

    for (const key in profileDataRaw) {
      if (Object.prototype.hasOwnProperty.call(profileDataRaw, key)) {
        const value = profileDataRaw[key];

        if (numericFields.includes(key)) {
            if (value === "" || value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else {
                const parsed = parseInt(String(value), 10);
                dataForUpdate[key] = isNaN(parsed) ? null : parsed;
            }
        } else if (stringAndEnumFields.includes(key)) {
            dataForUpdate[key] = (value === "" || value === undefined) ? null : value;
        } else if (booleanFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else if (typeof value === 'boolean') {
                dataForUpdate[key] = value;
            } else {
                dataForUpdate[key] = value === 'true';
            }
        } else if (arrayFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = [];
            } else if (Array.isArray(value)) {
                dataForUpdate[key] = value;
            }
        } else if (dateFields.includes(key)) {
            if (value) {
                const date = new Date(value);
                if (!isNaN(date.getTime())) {
                    dataForUpdate[key] = date;
                }
            } else {
                dataForUpdate[key] = null;
            }
        }
      }
    }
    
    let updatedProfile: any = null;

    // ×‘×™×¦×•×¢ ×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ
    if (Object.keys(dataForUpdate).length > 0) {
        updatedProfile = await prisma.profile.update({
          where: { userId: candidateIdToUpdate },
          data: {
            ...dataForUpdate,
            updatedAt: new Date(),
            lastActive: new Date(),
            needsAiProfileUpdate: true, // ××¡×× ×™× ×–×× ×™×ª ×©×¦×¨×™×š ×¢×“×›×•×Ÿ, ×¢×“ ×©×ª×”×œ×™×š ×”×¨×§×¢ ×™×¡×ª×™×™×
          }
        });

        // ×‘×“×™×§×” ×× ×”×©×ª× ×” ×”-manualEntryText ×œ×©×œ×™×—×ª ×”×ª×¨××”
        const newSummaryText = incomingData.manualEntryText;
        const oldSummaryText = originalProfile?.manualEntryText;

        if (newSummaryText !== undefined && newSummaryText.trim() !== '' && newSummaryText !== oldSummaryText) {
            try {
                await emailService.sendProfileSummaryUpdateEmail({
                    locale,
                    email: candidateToUpdate.email,
                    firstName: candidateToUpdate.firstName,
                    matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š"
                });
                console.log(`[Email Notification] Profile summary update email sent successfully to ${candidateToUpdate.email}.`);
            } catch (emailError) {
                console.error(`[Email Notification] Failed to send profile summary update email`, emailError);
            }
        }

        // =================================================================================
        // ğŸ”¥ ×¢×“×›×•×Ÿ ×¨×§×¢ (Background Process) - ×•×•×§×˜×•×¨ + ×¡×™×›×•× AI ğŸ”¥
        // =================================================================================
        // ×× ×—× ×• ××¨×™×¦×™× ××ª ×”×¤×•× ×§×¦×™×” ×”×–×• ×œ×œ× await ×›×“×™ ×œ× ×œ×¢×›×‘ ××ª ×”×ª×©×•×‘×” ×œ×œ×§×•×—
        (async () => {
            try {
                console.log(`[Background Update] Starting full AI update for user ${candidateIdToUpdate}...`);
                
                // 1. ×¢×“×›×•×Ÿ ×•×•×§×˜×•×¨ (×¢×‘×•×¨ ×× ×•×¢ ×”×—×™×¤×•×©)
                await updateUserAiProfile(candidateIdToUpdate);
                console.log(`[Background Update] Vector updated successfully.`);

                // 2. ×¢×“×›×•×Ÿ ×¡×™×›×•× ×¤×¨×•×¤×™×œ (AI Summary)
                // ×©×œ×‘ ×': ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘ ×”××™×œ×•×œ×™ ×”××¢×•×“×›×Ÿ
                const narrative = await generateNarrativeProfile(candidateIdToUpdate);
                
                if (narrative) {
                    // ×©×œ×‘ ×‘': ×©×œ×™×—×” ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
                    const summary = await aiService.generateProfileSummary(narrative);
                    
                    if (summary) {
                        // ×©×œ×‘ ×’': ×©××™×¨×” ×‘-DB ×•×›×™×‘×•×™ ×”×“×’×œ
                        await prisma.profile.update({
                            where: { userId: candidateIdToUpdate },
                            data: { 
                                aiProfileSummary: summary as any, // ×”××¨×” ×œ×¤×•×¨××˜ JSON ×©×œ ×¤×¨×™×–××”
                                needsAiProfileUpdate: false 
                            }
                        });
                        console.log(`[Background Update] AI Summary updated and saved successfully.`);
                    } else {
                        console.warn(`[Background Update] AI returned null summary.`);
                    }
                } else {
                    console.warn(`[Background Update] Failed to generate narrative.`);
                }
            } catch (err) {
                console.error(`[Background Update] Failed for candidate ${candidateIdToUpdate}:`, err);
            }
        })();
        // =================================================================================
    }

    // ×× ×œ× ×¢×•×“×›×Ÿ ×¤×¨×•×¤×™×œ (×œ××©×œ ×¨×§ ×©× ××©×ª××©), × ×©×œ×•×£ ××ª ×”×§×™×™×
    if (!updatedProfile) {
        updatedProfile = await prisma.profile.findUnique({ where: { userId: candidateIdToUpdate } });
    }

    return NextResponse.json({
        success: true,
        profile: updatedProfile,
        user: {
            firstName: firstName || candidateToUpdate.firstName,
            lastName: lastName || candidateToUpdate.lastName
        }
    });

  } catch (error) {
    console.error("Error updating candidate profile:", error);
    
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `×©×’×™××”: × ×¨××” ×©××—×“ ×”×©×“×•×ª ×©×”×–× ×ª (×›××• ××™×™×œ ××• ×˜×œ×¤×•×Ÿ) ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "×”×¤×¨×•×¤×™×œ ×œ× × ××¦×.";
            statusCode = 404;
        } else {
            errorMessage = `×©×’×™××ª ××¡×“ × ×ª×•× ×™× (×§×•×“ ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        errorMessage = `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘× ×ª×•× ×™×.`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

/**
 * DELETE: ××—×™×§×ª ××•×¢××“.
 * × ×’×™×© ×œ×× ×”×œ×™× ×‘×œ×‘×“.
 */
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const timestamp = new Date().toISOString();
  
  const params = await props.params;
  const candidateIdToDelete = params.id;
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role.`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. ×œ× ×–×•×”×ª×” ×¡×©×Ÿ ×¤×¢×™×œ ××• ×”×¨×©××”.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. × ×“×¨×©×ª ×”×¨×©××ª ××“××™×Ÿ.' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    return NextResponse.json(
        { success: false, error: '××–×”×” ××•×¢××“ (candidateId) ×—×¡×¨.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    return NextResponse.json(
        { success: false, error: '×× ×”×œ ××™× ×• ×™×›×•×œ ×œ××—×•×§ ××ª ×—×©×‘×•× ×• ×”××™×©×™ ×“×¨×š ×××©×§ ×–×”.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      return NextResponse.json(
        { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.' },
        { status: 404 }
      );
    }

    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '×”××•×¢××“ × ××—×§ ×‘×”×¦×œ×—×”.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            return NextResponse.json(
                { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.'},
                { status: 404 }
            );
        }
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘××—×™×§×ª ×”××•×¢××“ (×§×•×“: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘××—×™×§×ª ×”××•×¢××“.`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '×©×’×™××” ×œ× ×™×“×•×¢×”.';
    return NextResponse.json(
      {
        success: false,
        error: '××™×¨×¢×” ×©×’×™××” ×‘××—×™×§×ª ×”××•×¢××“.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    // Await params before destructuring
    const params = await props.params;
    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/main/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const imageToSetMain = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    await prisma.$transaction([
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId }
        },
        data: { isMain: false }
      }),
      
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';

export async function POST(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    const params = await props.params;
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×ª×§×™× ×” ×”×™× ×©×“×” ×—×•×‘×”." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    const expiresInHours = 72;
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    await prisma.$transaction(async (tx) => {
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id },
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    const expiresInText = locale === 'he' ? '3 ×™××™×' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale,
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    return NextResponse.json({ success: true, message: "×”×–×× ×” ×œ×”×’×“×¨×ª ×—×©×‘×•×Ÿ × ×©×œ×—×” ×‘×”×¦×œ×—×”." });

  } catch (error) {
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ××©×•×™×›×ª ×œ×—×©×‘×•×Ÿ ××—×¨." },
          { status: 409 }
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×ª ×”×”×–×× ×”.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const heightStr = formData.get('height') as string | null;
    
    // --- START: Added Religious Level ---
    const religiousLevel = formData.get('religiousLevel') as string | null;
    // --- END: Added Religious Level ---

    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---
    let height: number | null = null;
    if (heightStr && heightStr.trim() !== '') {
        const parsedHeight = parseInt(heightStr, 10);
        if (!isNaN(parsedHeight)) {
            height = parsedHeight;
        }
    }

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
      isProfileVisible: true, 
      height: height,
      religiousLevel: religiousLevel, // Add to Prisma Create Object
    };

    // --- START: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\dashboard
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\dashboard\route.ts
--------------------------------------------------------------------------------
Content:
// =============================================================================
// ğŸ“ src/app/api/matchmaker/dashboard/route.ts
// =============================================================================
// ğŸ¯ Matchmaker Dashboard API V1.0 - NeshamaTech
// =============================================================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import dashboardService from "@/lib/services/dashboardService";
import { UserRole } from "@prisma/client";

// =============================================================================
// Types
// =============================================================================

type PriorityCategory = 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';

interface SessionUser {
  id: string;
  role: UserRole;
}

// =============================================================================
// GET - ×§×‘×œ×ª × ×ª×•× ×™ ×”×“×©×‘×•×¨×“
// =============================================================================

export async function GET(request: NextRequest) {
  try {
    // ××™××•×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    // ×‘×“×™×§×” ×©×”××©×ª××© ×”×•× ×©×“×›×Ÿ
    const user = session.user as SessionUser;
    if (user.role !== UserRole.MATCHMAKER && user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { error: "Access denied. Matchmaker role required." },
        { status: 403 }
      );
    }
    
    // ×¤×¨××˜×¨×™× ××•×¤×¦×™×•× ×œ×™×™×
    const searchParams = request.nextUrl.searchParams;
    const section = searchParams.get('section'); // stats, priority, alerts, activity
    
    // ×× ××‘×§×©×™× ×¨×§ ×—×œ×§ ××¡×•×™×
    if (section) {
      switch (section) {
        case 'stats': {
          const stats = await dashboardService.getStats();
          return NextResponse.json({ stats });
        }
          
        case 'quick': {
          const quickStats = await dashboardService.getQuickStats();
          return NextResponse.json(quickStats);
        }
          
        case 'activity': {
          const limit = parseInt(searchParams.get('limit') || '10');
          const activity = await dashboardService.getRecentActivity(limit);
          return NextResponse.json({ activity });
        }
          
        case 'chart': {
          const days = parseInt(searchParams.get('days') || '30');
          const chartData = await dashboardService.getMatchesOverTime(days);
          return NextResponse.json({ chartData });
        }
          
        case 'priority': {
          const category = searchParams.get('category') as PriorityCategory | null;
          const priorityLimit = parseInt(searchParams.get('limit') || '20');
          if (category) {
            const users = await dashboardService.getUsersByPriorityCategory(
              category, 
              priorityLimit
            );
            return NextResponse.json({ users });
          }
          break;
        }
        
        default:
          // Fall through to default behavior
          break;
      }
    }
    
    // ×‘×¨×™×¨×ª ××—×“×œ - ×›×œ ×”× ×ª×•× ×™×
    const dashboardData = await dashboardService.getDashboardData();
    
    return NextResponse.json(dashboardData);
    
  } catch (error) {
    console.error("[Dashboard API] Error:", error);
    
    return NextResponse.json(
      { 
        error: "Failed to fetch dashboard data",
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// POST - ×¤×¢×•×œ×•×ª ×¢×œ ×”×“×©×‘×•×¨×“
// =============================================================================

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const user = session.user as SessionUser;
    if (user.role !== UserRole.MATCHMAKER && user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { error: "Access denied" },
        { status: 403 }
      );
    }
    
    const body = await request.json();
    const { action } = body;
    
    switch (action) {
      case 'refresh_priority': {
        // ×¢×“×›×•×Ÿ Priority ×œ×›×œ ×”××©×ª××©×™×
        const { updateAllUsersPriorityInDB } = await import("@/lib/services/priorityService");
        const result = await updateAllUsersPriorityInDB();
        return NextResponse.json({ 
          success: true, 
          message: `Updated ${result.updated} users`,
          ...result 
        });
      }
        
      case 'generate_alerts': {
        // ×™×¦×™×¨×ª ×”×ª×¨××•×ª ×—×“×©×•×ª
        const { generateAllAlerts } = await import("@/lib/services/alertsService");
        const alertsResult = await generateAllAlerts();
        return NextResponse.json({ 
          success: true, 
          message: `Generated ${alertsResult.generated} alerts`,
          ...alertsResult 
        });
      }
        
      default:
        return NextResponse.json(
          { error: "Unknown action" },
          { status: 400 }
        );
    }
    
  } catch (error) {
    console.error("[Dashboard API] POST Error:", error);
    
    return NextResponse.json(
      { 
        error: "Action failed",
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\hidden-candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\hidden-candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/hidden-candidates/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export const dynamic = 'force-dynamic';

// =============================================================================
// GET - ×§×‘×œ×ª ×¨×©×™××ª ×”××•×¢××“×™× ×”××•×¡×ª×¨×™× ×©×œ ×”×©×“×›×Ÿ
// =============================================================================
export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Not logged in' },
        { status: 401 }
      );
    }

    // ×•×™×“×•× ×©×”××©×ª××© ×”×•× ×©×“×›×Ÿ ××• ××“××™×Ÿ
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Matchmaker or Admin access required' },
        { status: 403 }
      );
    }

    // ×©×œ×™×¤×ª ×”××•×¢××“×™× ×”××•×¡×ª×¨×™× ×¢× ×¤×¨×˜×™ ×”××•×¢××“
    const hiddenCandidates = await prisma.hiddenCandidate.findMany({
      where: {
        matchmakerId: session.user.id,
      },
      include: {
        candidate: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true,
            images: {
              where: { isMain: true },
              take: 1,
              select: { url: true },
            },
            profile: {
              select: {
                gender: true,
                city: true,
                religiousLevel: true,
                availabilityStatus: true,
              },
            },
          },
        },
      },
      orderBy: {
        hiddenAt: 'desc',
      },
    });

    // ×¤×•×¨××˜ ×”×ª×•×¦××•×ª
    const formattedCandidates = hiddenCandidates.map((hc) => ({
      id: hc.id,
      candidateId: hc.candidateId,
      reason: hc.reason,
      hiddenAt: hc.hiddenAt,
      candidate: {
        id: hc.candidate.id,
        firstName: hc.candidate.firstName,
        lastName: hc.candidate.lastName,
        phone: hc.candidate.phone,
        mainImage: hc.candidate.images[0]?.url || null,
        gender: hc.candidate.profile?.gender || null,
        city: hc.candidate.profile?.city || null,
        religiousLevel: hc.candidate.profile?.religiousLevel || null,
        availabilityStatus: hc.candidate.profile?.availabilityStatus || null,
      },
    }));

    return NextResponse.json({
      success: true,
      hiddenCandidates: formattedCandidates,
      count: formattedCandidates.length,
    });

  } catch (error) {
    console.error('Error fetching hidden candidates:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch hidden candidates' },
      { status: 500 }
    );
  }
}

// =============================================================================
// POST - ×”×•×¡×¤×ª ××•×¢××“ ×œ×¨×©×™××ª ×”××•×¡×ª×¨×™×
// =============================================================================
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Not logged in' },
        { status: 401 }
      );
    }

    // ×•×™×“×•× ×©×”××©×ª××© ×”×•× ×©×“×›×Ÿ ××• ××“××™×Ÿ
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Matchmaker or Admin access required' },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { candidateId, reason } = body;

    if (!candidateId) {
      return NextResponse.json(
        { success: false, error: 'candidateId is required' },
        { status: 400 }
      );
    }

    // ×‘×“×™×§×” ×©×”××•×¢××“ ×§×™×™×
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
      select: { id: true, firstName: true, lastName: true },
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: 'Candidate not found' },
        { status: 404 }
      );
    }

    // ×™×¦×™×¨×ª ×¨×©×•××” (upsert ×œ×× ×™×¢×ª ×›×¤×™×œ×•×™×•×ª)
    const hiddenCandidate = await prisma.hiddenCandidate.upsert({
      where: {
        matchmakerId_candidateId: {
          matchmakerId: session.user.id,
          candidateId: candidateId,
        },
      },
      update: {
        reason: reason || null,
        hiddenAt: new Date(), // ×¢×“×›×•×Ÿ ×ª××¨×™×š ×× ×›×‘×¨ ×§×™×™×
      },
      create: {
        matchmakerId: session.user.id,
        candidateId: candidateId,
        reason: reason || null,
      },
    });

    return NextResponse.json({
      success: true,
      message: `${candidate.firstName} ${candidate.lastName} ×”×•×¡×ª×¨/×” ××¨×©×™××ª ×”×”×¦×¢×•×ª`,
      hiddenCandidate: {
        id: hiddenCandidate.id,
        candidateId: hiddenCandidate.candidateId,
        reason: hiddenCandidate.reason,
        hiddenAt: hiddenCandidate.hiddenAt,
      },
    });

  } catch (error) {
    console.error('Error hiding candidate:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to hide candidate' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\hidden-candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\hidden-candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/hidden-candidates/[id]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export const dynamic = 'force-dynamic';

// =============================================================================
// DELETE - ×”×¡×¨×ª ××•×¢××“ ××¨×©×™××ª ×”××•×¡×ª×¨×™×
// =============================================================================
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Not logged in' },
        { status: 401 }
      );
    }

    // ×•×™×“×•× ×©×”××©×ª××© ×”×•× ×©×“×›×Ÿ ××• ××“××™×Ÿ
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Matchmaker or Admin access required' },
        { status: 403 }
      );
    }

    const { id } = await params;

    if (!id) {
      return NextResponse.json(
        { success: false, error: 'Hidden candidate ID is required' },
        { status: 400 }
      );
    }

    // ×‘×“×™×§×” ×©×”×¨×©×•××” ×§×™×™××ª ×•×©×™×™×›×ª ×œ×©×“×›×Ÿ ×”× ×•×›×—×™
    const hiddenCandidate = await prisma.hiddenCandidate.findUnique({
      where: { id },
      include: {
        candidate: {
          select: { firstName: true, lastName: true },
        },
      },
    });

    if (!hiddenCandidate) {
      return NextResponse.json(
        { success: false, error: 'Hidden candidate record not found' },
        { status: 404 }
      );
    }

    // ×•×™×“×•× ×©×–×” ×”×©×“×›×Ÿ ×©×”×¡×ª×™×¨ ××ª ×”××•×¢××“
    if (hiddenCandidate.matchmakerId !== session.user.id) {
      return NextResponse.json(
        { success: false, error: 'You can only unhide candidates you have hidden' },
        { status: 403 }
      );
    }

    // ××—×™×§×ª ×”×¨×©×•××”
    await prisma.hiddenCandidate.delete({
      where: { id },
    });

    return NextResponse.json({
      success: true,
      message: `${hiddenCandidate.candidate.firstName} ${hiddenCandidate.candidate.lastName} ×”×•×—×–×¨/×” ×œ×¨×©×™××ª ×”×”×¦×¢×•×ª`,
      candidateId: hiddenCandidate.candidateId,
    });

  } catch (error) {
    console.error('Error unhiding candidate:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to unhide candidate' },
      { status: 500 }
    );
  }
}

// =============================================================================
// PATCH - ×¢×“×›×•×Ÿ ×¡×™×‘×ª ×”×”×¡×ª×¨×”
// =============================================================================
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Not logged in' },
        { status: 401 }
      );
    }

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized - Matchmaker or Admin access required' },
        { status: 403 }
      );
    }

    const { id } = await params;
    const body = await request.json();
    const { reason } = body;

    // ×‘×“×™×§×” ×©×”×¨×©×•××” ×§×™×™××ª ×•×©×™×™×›×ª ×œ×©×“×›×Ÿ ×”× ×•×›×—×™
    const hiddenCandidate = await prisma.hiddenCandidate.findUnique({
      where: { id },
    });

    if (!hiddenCandidate) {
      return NextResponse.json(
        { success: false, error: 'Hidden candidate record not found' },
        { status: 404 }
      );
    }

    if (hiddenCandidate.matchmakerId !== session.user.id) {
      return NextResponse.json(
        { success: false, error: 'You can only update your own hidden candidates' },
        { status: 403 }
      );
    }

    // ×¢×“×›×•×Ÿ ×”×¡×™×‘×”
    const updated = await prisma.hiddenCandidate.update({
      where: { id },
      data: { reason: reason || null },
    });

    return NextResponse.json({
      success: true,
      message: 'Reason updated successfully',
      hiddenCandidate: {
        id: updated.id,
        reason: updated.reason,
      },
    });

  } catch (error) {
    console.error('Error updating hidden candidate:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to update hidden candidate' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export const dynamic = 'force-dynamic';

export async function GET(
  req: Request,
  props: { params: Promise<{ id: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized - Not logged in" }, { status: 401 });
    }

    const performingUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
        return NextResponse.json(
            { error: 'Unauthorized - Matchmaker or Admin access required to view this inquiry' },
            { status: 403 }
        );
    }
    
    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    if (!inquiry) {
        return NextResponse.json({ error: "Inquiry not found or access denied" }, { status: 404 });
    }
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    let message = "Failed to fetch inquiry";
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/respond/route.ts

import { type NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

type RouteSegment<T> = (
  request: NextRequest,
  props: { params: Promise<T> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) => Promise<NextResponse> | NextResponse;

const handler: RouteSegment<{ id: string }> = async (req, { params: paramsPromise }) => {
  try {
    const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    const { isAvailable, note } = await req.json();

    if (typeof isAvailable !== 'boolean') {
        return NextResponse.json({ success: false, error: "Bad Request: 'isAvailable' must be a boolean." }, { status: 400 });
    }

    const params = await paramsPromise; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await

    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note,
      locale: locale,
    });

    return NextResponse.json({ success: true, inquiry: updatedInquiry });

  } catch (error) {
    console.error("Error updating inquiry response:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Failed to update response";
    
    return NextResponse.json(
      { 
        success: false,
        error: errorMessage
      },
      { status: 500 }
    );
  }
};

export const POST = handler;
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\potential-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\potential-matches\route.ts
--------------------------------------------------------------------------------
Content:
// =============================================================================
// src/app/api/matchmaker/potential-matches/route.ts
// API ×œ×©×œ×™×¤×ª ×”×ª×××•×ª ×¤×•×˜× ×¦×™××œ×™×•×ª - ×›×•×œ×œ ×ª×™×§×•×Ÿ ×—×™×¤×•×© ×©×¨×ª
// =============================================================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole, PotentialMatchStatus, Prisma } from "@prisma/client";
import prisma from "@/lib/prisma";

export const dynamic = 'force-dynamic';

// =============================================================================
// CONSTANTS
// =============================================================================

const DEFAULT_PAGE_SIZE = 20;
const MAX_PAGE_SIZE = 100;

// ×¡×˜×˜×•×¡×™× ×©×—×•×¡××™× ×”×¦×¢×•×ª ×—×“×©×•×ª
const BLOCKING_SUGGESTION_STATUSES = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
  'ENGAGED',
  'MARRIED',
];

// ×¡×˜×˜×•×¡×™× ×©×œ ×”×¦×¢×•×ª ×××ª×™× ×•×ª
const PENDING_SUGGESTION_STATUSES = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

// =============================================================================
// GET - ×©×œ×™×¤×ª ×”×ª×××•×ª ×¤×•×˜× ×¦×™××œ×™×•×ª
// =============================================================================

export async function GET(req: NextRequest): Promise<NextResponse> {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Forbidden" }, { status: 403 });
    }

    // 2. ×¤×¨×¡×•×¨ Query Parameters
    const { searchParams } = new URL(req.url);
    
    const page = Math.max(1, parseInt(searchParams.get('page') || '1'));
    const pageSize = Math.min(MAX_PAGE_SIZE, Math.max(1, parseInt(searchParams.get('pageSize') || String(DEFAULT_PAGE_SIZE))));
    
    const status = searchParams.get('status') || 'all';
    const minScore = parseFloat(searchParams.get('minScore') || '0');
    const maxScore = parseFloat(searchParams.get('maxScore') || '100');
    const sortBy = searchParams.get('sortBy') || 'score_desc';
    const hasWarning = searchParams.get('hasWarning'); // 'true', 'false', or null
    const religiousLevel = searchParams.get('religiousLevel');
    const city = searchParams.get('city');
    
    // âœ… ×§×‘×œ×ª ××™×œ×ª ×”×—×™×¤×•×© ××”×œ×§×•×—
// ×§×•×“ ××ª×•×§×Ÿ
const searchTerm = searchParams.get('searchTerm');
    // 3. ×‘× ×™×™×ª Where clause
    const where: Prisma.PotentialMatchWhereInput = {
      aiScore: {
        gte: minScore,
        lte: maxScore,
      }
    };

    // âœ… ×œ×•×’×™×§×” ×œ×—×™×¤×•×© ×˜×§×¡×˜×•××œ×™ ×‘×¨××ª ×”-DB
    if (searchTerm) {
      const term = searchTerm.trim();
      where.OR = [
        // ×—×™×¤×•×© ×‘×¦×“ ×”×’×‘×¨
        { male: { firstName: { contains: term, mode: 'insensitive' } } },
        { male: { lastName: { contains: term, mode: 'insensitive' } } },
        { male: { phone: { contains: term } } }, // ×—×™×¤×•×© ×’× ×‘×˜×œ×¤×•×Ÿ
        // ×—×™×¤×•×© ×‘×¦×“ ×”××™×©×”
        { female: { firstName: { contains: term, mode: 'insensitive' } } },
        { female: { lastName: { contains: term, mode: 'insensitive' } } },
        { female: { phone: { contains: term } } }, // ×—×™×¤×•×© ×’× ×‘×˜×œ×¤×•×Ÿ
        // ×—×™×¤×•×© ×‘× ×™××•×§
        { shortReasoning: { contains: term, mode: 'insensitive' } }
      ];
    }

    // ×¡×™× ×•×Ÿ ×œ×¤×™ ×¡×˜×˜×•×¡
    if (status !== 'all') {
      if (status === 'with_warnings' || status === 'no_warnings') {
        // ×¡×™× ×•×Ÿ ×–×” ××ª×‘×¦×¢ ××—×¨×™ ×”×©×œ×™×¤×” ×›×™ ×”×•× ×ª×œ×•×™ ×‘×˜×‘×œ×” ××—×¨×ª,
        // ××‘×œ ×× ×¨×•×¦×™× ×œ×©×¤×¨ ×‘×™×¦×•×¢×™× ×‘×¢×ª×™×“, ×¦×¨×™×š ×œ×¢×©×•×ª ×–××ª ×“×¨×š Include ××• Join.
        // ×›×¨×’×¢ × ×©××™×¨ ××•×ª×• ×œ×¤×•×¡×˜-×¤×¨×•×¡×¡×™× ×’ ×›×“×™ ×œ× ×œ×©×‘×•×¨ ×œ×•×’×™×§×” ×§×™×™××ª, 
        // ××œ× ×× ×›×Ÿ × ×“×¨×© ××—×¨×ª.
      } else {
        where.status = status.toUpperCase() as PotentialMatchStatus;
      }
    }

    // ×¡×™× ×•×Ÿ ×œ×¤×™ ×¨××” ×“×ª×™×ª (×‘×¨××ª ×”-DB)
    if (religiousLevel) {
      where.AND = [
        ...(Array.isArray(where.AND) ? where.AND : []),
        {
          OR: [
            { male: { profile: { religiousLevel: religiousLevel } } },
            { female: { profile: { religiousLevel: religiousLevel } } }
          ]
        }
      ] as Prisma.PotentialMatchWhereInput['AND'];
    }

    // ×¡×™× ×•×Ÿ ×œ×¤×™ ×¢×™×¨ (×‘×¨××ª ×”-DB)
    if (city) {
      where.AND = [
        ...(Array.isArray(where.AND) ? where.AND : []),
        {
          OR: [
            { male: { profile: { city: { contains: city, mode: 'insensitive' } } } },
            { female: { profile: { city: { contains: city, mode: 'insensitive' } } } }
          ]
        }
      ] as Prisma.PotentialMatchWhereInput['AND'];
    }

    // 4. ×‘× ×™×™×ª Order By
    let orderBy: Prisma.PotentialMatchOrderByWithRelationInput = {};
    switch (sortBy) {
      case 'score_desc':
        orderBy = { aiScore: 'desc' };
        break;
      case 'score_asc':
        orderBy = { aiScore: 'asc' };
        break;
      case 'date_desc':
        orderBy = { scannedAt: 'desc' };
        break;
      case 'date_asc':
        orderBy = { scannedAt: 'asc' };
        break;
      default:
        orderBy = { aiScore: 'desc' };
    }

    // 5. ×©×œ×™×¤×ª ×”×”×ª×××•×ª
    const [matches, totalCount] = await Promise.all([
      prisma.potentialMatch.findMany({
        where,
        orderBy,
        skip: (page - 1) * pageSize,
        take: pageSize,
        include: {
          male: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              phone: true,
              isVerified: true,
              isProfileComplete: true,
              createdAt: true,
              images: {
                where: { isMain: true },
                select: { url: true },
                take: 1,
              },
              profile: {
                select: {
                  gender: true,
                  birthDate: true,
                  city: true,
                  religiousLevel: true,
                  occupation: true,
                  availabilityStatus: true,
                  lastActive: true,
                }
              }
            }
          },
          female: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              phone: true,
              isVerified: true,
              isProfileComplete: true,
              createdAt: true,
              images: {
                where: { isMain: true },
                select: { url: true },
                take: 1,
              },
              profile: {
                select: {
                  gender: true,
                  birthDate: true,
                  city: true,
                  religiousLevel: true,
                  occupation: true,
                  availabilityStatus: true,
                  lastActive: true,
                }
              }
            }
          }
        }
      }),
      prisma.potentialMatch.count({ where })
    ]);

    // 6. ×©×œ×™×¤×ª ×”×¦×¢×•×ª ×¤×¢×™×œ×•×ª ×¢×‘×•×¨ ×›×œ ×”××•×¢××“×™×
    const allUserIds = new Set<string>();
    for (const match of matches) {
      allUserIds.add(match.maleUserId);
      allUserIds.add(match.femaleUserId);
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: Array.from(allUserIds) } },
          { secondPartyId: { in: Array.from(allUserIds) } },
        ],
        status: { in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES] as any }
      },
      select: {
        id: true,
        status: true,
        firstPartyId: true,
        secondPartyId: true,
        firstParty: { select: { firstName: true, lastName: true } },
        secondParty: { select: { firstName: true, lastName: true } },
        createdAt: true,
      }
    });

    // ×™×¦×™×¨×ª ××¤×” ×©×œ ×”×¦×¢×•×ª ×¤×¢×™×œ×•×ª
    const activeSuggestionMap = new Map<string, {
      suggestionId: string;
      status: string;
      withCandidateName: string;
      withCandidateId: string;
      createdAt: Date;
      isBlocking: boolean;
    }>();

    for (const suggestion of activeSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(suggestion.status);
      
      // ×¢×‘×•×¨ ×”×¦×“ ×”×¨××©×•×Ÿ
      const existingFirst = activeSuggestionMap.get(suggestion.firstPartyId);
      if (!existingFirst || (isBlocking && !existingFirst.isBlocking)) {
        activeSuggestionMap.set(suggestion.firstPartyId, {
          suggestionId: suggestion.id,
          status: suggestion.status,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
          withCandidateId: suggestion.secondPartyId,
          createdAt: suggestion.createdAt,
          isBlocking,
        });
      }

      // ×¢×‘×•×¨ ×”×¦×“ ×”×©× ×™
      const existingSecond = activeSuggestionMap.get(suggestion.secondPartyId);
      if (!existingSecond || (isBlocking && !existingSecond.isBlocking)) {
        activeSuggestionMap.set(suggestion.secondPartyId, {
          suggestionId: suggestion.id,
          status: suggestion.status,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
          withCandidateId: suggestion.firstPartyId,
          createdAt: suggestion.createdAt,
          isBlocking,
        });
      }
    }

    // 7. ×¢×™×‘×•×“ ×”×ª×•×¦××•×ª
    const processedMatches = matches.map(match => {
      const maleAge = calculateAge(match.male.profile?.birthDate);
      const femaleAge = calculateAge(match.female.profile?.birthDate);

      const maleActiveSuggestion = activeSuggestionMap.get(match.maleUserId) || null;
      const femaleActiveSuggestion = activeSuggestionMap.get(match.femaleUserId) || null;

      const hasActiveWarning = !!(
        (maleActiveSuggestion?.isBlocking) || 
        (femaleActiveSuggestion?.isBlocking)
      );

      return {
        id: match.id,
        
        male: {
          id: match.male.id,
          firstName: match.male.firstName,
          lastName: match.male.lastName,
          age: maleAge,
          phone: match.male.phone, 
          city: match.male.profile?.city || null,
          religiousLevel: match.male.profile?.religiousLevel || null,
          occupation: match.male.profile?.occupation || null,
          mainImage: match.male.images[0]?.url || null,
          isVerified: match.male.isVerified,
          isProfileComplete: match.male.isProfileComplete,
          availabilityStatus: match.male.profile?.availabilityStatus || 'AVAILABLE',
          lastActive: match.male.profile?.lastActive,
          registeredAt: match.male.createdAt,
        },

        female: {
          id: match.female.id,
          firstName: match.female.firstName,
          lastName: match.female.lastName,
          age: femaleAge,
          phone: match.female.phone,
          city: match.female.profile?.city || null,
          religiousLevel: match.female.profile?.religiousLevel || null,
          occupation: match.female.profile?.occupation || null,
          mainImage: match.female.images[0]?.url || null,
          isVerified: match.female.isVerified,
          isProfileComplete: match.female.isProfileComplete,
          availabilityStatus: match.female.profile?.availabilityStatus || 'AVAILABLE',
          lastActive: match.female.profile?.lastActive,
          registeredAt: match.female.createdAt,
        },

        aiScore: match.aiScore,
        firstPassScore: match.firstPassScore,
        scoreBreakdown: match.scoreBreakdown,
        shortReasoning: match.shortReasoning,
        detailedReasoning: match.detailedReasoning,
        backgroundCompatibility: match.backgroundCompatibility,
        backgroundMultiplier: match.backgroundMultiplier,

        status: match.status,
        scannedAt: match.scannedAt,
        reviewedAt: match.reviewedAt,
        suggestionId: match.suggestionId,

        maleActiveSuggestion,
        femaleActiveSuggestion,
        hasActiveWarning,
      };
    });

    // 8. ×¡×™× ×•×Ÿ × ×•×¡×£ ×œ×¤×™ ××–×”×¨×•×ª (××‘×•×¦×¢ ×‘×–×™×›×¨×•×Ÿ ×›×™ ×–×” ×©×“×” ××—×•×©×‘)
    // ×”×¢×¨×”: ×”×—×™×¤×•×© ×”×˜×§×¡×˜×•××œ×™ ×›×‘×¨ ×‘×•×¦×¢ ×œ××¢×œ×” ×‘-DB, ××– ××™×Ÿ ×¦×•×¨×š ×œ×¡× ×Ÿ ××•×ª×• ×›××Ÿ ×©×•×‘.
    let filteredMatches = processedMatches;
    if (hasWarning === 'true') {
      filteredMatches = processedMatches.filter(m => m.hasActiveWarning);
    } else if (hasWarning === 'false') {
      filteredMatches = processedMatches.filter(m => !m.hasActiveWarning);
    }

    // 9. ×—×™×©×•×‘ ×¡×˜×˜×™×¡×˜×™×§×•×ª
    const stats = await calculateStats();

    // 10. ×©×œ×™×¤×ª ××™×“×¢ ×¢×œ ×”×¡×¨×™×§×” ×”××—×¨×•× ×”
    const lastScan = await prisma.nightlyScanLog.findFirst({
      where: { status: { in: ['completed', 'partial'] } },
      orderBy: { completedAt: 'desc' },
      select: {
        id: true,
        startedAt: true,
        completedAt: true,
        status: true,
        totalCandidates: true,
        candidatesScanned: true,
        matchesFound: true,
        newMatches: true,
        durationMs: true,
      }
    });

    // 11. ×”×—×–×¨×ª ×”×ª×•×¦××•×ª
    return NextResponse.json({
      success: true,
      matches: filteredMatches,
      pagination: {
        total: totalCount,
        page,
        pageSize,
        totalPages: Math.ceil(totalCount / pageSize),
      },
      stats,
      lastScanInfo: lastScan ? {
        id: lastScan.id,
        startedAt: lastScan.startedAt,
        completedAt: lastScan.completedAt,
        status: lastScan.status,
        totalCandidates: lastScan.totalCandidates,
        candidatesScanned: lastScan.candidatesScanned,
        matchesFound: lastScan.matchesFound,
        newMatches: lastScan.newMatches,
        durationMs: lastScan.durationMs,
      } : null,
    });

  } catch (error) {
    console.error('[PotentialMatches] GET Error:', error);
    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      message: error instanceof Error ? error.message : 'Unknown error',
    }, { status: 500 });
  }
}

// =============================================================================
// POST - ×¤×¢×•×œ×•×ª ×¢×œ ×”×ª×××” ×¤×•×˜× ×¦×™××œ×™×ª
// =============================================================================

export async function POST(req: NextRequest): Promise<NextResponse> {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Forbidden" }, { status: 403 });
    }

    // 2. ×¤×¨×¡×•×¨ ×”×‘×§×©×”
    const body = await req.json();
    const { matchId, action, reason, suggestionData } = body;

    if (!matchId || !action) {
      return NextResponse.json({ 
        success: false, 
        error: "matchId and action are required" 
      }, { status: 400 });
    }

    // 3. ×©×œ×™×¤×ª ×”×”×ª×××”
    const match = await prisma.potentialMatch.findUnique({
      where: { id: matchId },
      include: {
        male: { select: { id: true, firstName: true, lastName: true } },
        female: { select: { id: true, firstName: true, lastName: true } },
      }
    });

    if (!match) {
      return NextResponse.json({ success: false, error: "Match not found" }, { status: 404 });
    }

    // 4. ×‘×™×¦×•×¢ ×”×¤×¢×•×œ×”
    switch (action) {
      case 'review': {
        await prisma.potentialMatch.update({
          where: { id: matchId },
          data: {
            status: 'REVIEWED',
            reviewedAt: new Date(),
            reviewedBy: session.user.id,
          }
        });

        return NextResponse.json({
          success: true,
          message: '×”×”×ª×××” ×¡×•×× ×” ×›× ×‘×“×§×”',
        });
      }

      case 'save': {
        await prisma.potentialMatch.update({
          where: { id: matchId },
          data: {
            status: 'SHORTLISTED',
            reviewedAt: new Date(),
            reviewedBy: session.user.id,
          }
        });

        return NextResponse.json({
          success: true,
          message: '×”×”×ª×××” × ×©××¨×” ×‘×¦×“',
        });
      }

      case 'dismiss': {
        await prisma.potentialMatch.update({
          where: { id: matchId },
          data: {
            status: 'DISMISSED',
            dismissedAt: new Date(),
            reviewedBy: session.user.id,
            dismissReason: reason || null,
          }
        });

        return NextResponse.json({
          success: true,
          message: '×”×”×ª×××” × ×“×—×ª×”',
        });
      }

      case 'restore': {
        await prisma.potentialMatch.update({
          where: { id: matchId },
          data: {
            status: 'PENDING',
            dismissedAt: null,
            dismissReason: null,
          }
        });

        return NextResponse.json({
          success: true,
          message: '×”×”×ª×××” ×©×•×—×–×¨×”',
        });
      }

      case 'create_suggestion': {
        // ×‘×“×™×§×” ×©×œ× ×§×™×™××ª ×›×‘×¨ ×”×¦×¢×”
        const existingSuggestion = await prisma.matchSuggestion.findFirst({
          where: {
            OR: [
              { firstPartyId: match.maleUserId, secondPartyId: match.femaleUserId },
              { firstPartyId: match.femaleUserId, secondPartyId: match.maleUserId },
            ],
            status: { notIn: ['FIRST_PARTY_DECLINED', 'SECOND_PARTY_DECLINED', 'CLOSED', 'CANCELLED'] }
          }
        });

        if (existingSuggestion) {
          return NextResponse.json({
            success: false,
            error: '×›×‘×¨ ×§×™×™××ª ×”×¦×¢×” ×¤×¢×™×œ×” ×‘×™×Ÿ ×©× ×™ ×”××•×¢××“×™×',
            suggestionId: existingSuggestion.id,
          }, { status: 400 });
        }

        // ×™×¦×™×¨×ª ×”×¦×¢×” ×—×“×©×”
        const suggestion = await prisma.matchSuggestion.create({
          data: {
            firstPartyId: match.maleUserId,
            secondPartyId: match.femaleUserId,
            matchmakerId: session.user.id,
            status: 'DRAFT',
            priority: suggestionData?.priority || 'MEDIUM',
            matchingReason: suggestionData?.matchingReason || match.shortReasoning || `×”×ª×××ª AI - ×¦×™×•×Ÿ ${match.aiScore}`,
            firstPartyNotes: suggestionData?.firstPartyNotes || '',
            secondPartyNotes: suggestionData?.secondPartyNotes || '',
            internalNotes: `× ×•×¦×¨ ××”×ª×××” ×¤×•×˜× ×¦×™××œ×™×ª #${match.id}`,
          }
        });

        // ×¢×“×›×•×Ÿ ×”×”×ª×××” ×”×¤×•×˜× ×¦×™××œ×™×ª
        await prisma.potentialMatch.update({
          where: { id: matchId },
          data: {
            status: 'SENT',
            sentAt: new Date(),
            suggestionId: suggestion.id,
          }
        });

        return NextResponse.json({
          success: true,
          message: '×”×¦×¢×” × ×•×¦×¨×” ×‘×”×¦×œ×—×”',
          suggestionId: suggestion.id,
        });
      }

      default:
        return NextResponse.json({
          success: false,
          error: `Unknown action: ${action}`,
        }, { status: 400 });
    }

  } catch (error) {
    console.error('[PotentialMatches] POST Error:', error);
    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      message: error instanceof Error ? error.message : 'Unknown error',
    }, { status: 500 });
  }
}

// =============================================================================
// DELETE - ×¤×¢×•×œ×•×ª ××¨×•×‘×•×ª (bulk actions)
// =============================================================================

export async function DELETE(req: NextRequest): Promise<NextResponse> {
  try {
    // 1. ××™××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Forbidden" }, { status: 403 });
    }

    // 2. ×¤×¨×¡×•×¨ ×”×‘×§×©×”
    const body = await req.json();
    const { matchIds, action, reason } = body;

    if (!matchIds || !Array.isArray(matchIds) || matchIds.length === 0) {
      return NextResponse.json({ 
        success: false, 
        error: "matchIds array is required" 
      }, { status: 400 });
    }

    // 3. ×‘×™×¦×•×¢ ×¤×¢×•×œ×” ××¨×•×‘×”
    let updateData: any = {};
    
    switch (action) {
      case 'dismiss':
        updateData = {
          status: 'DISMISSED',
          dismissedAt: new Date(),
          reviewedBy: session.user.id,
          dismissReason: reason || '×“×—×™×™×” ××¨×•×‘×”',
        };
        break;
        
      case 'review':
        updateData = {
          status: 'REVIEWED',
          reviewedAt: new Date(),
          reviewedBy: session.user.id,
        };
        break;
        
      case 'restore':
        updateData = {
          status: 'PENDING',
          dismissedAt: null,
          dismissReason: null,
        };
        break;
        
      default:
        return NextResponse.json({
          success: false,
          error: `Unknown bulk action: ${action}`,
        }, { status: 400 });
    }

    const result = await prisma.potentialMatch.updateMany({
      where: { id: { in: matchIds } },
      data: updateData,
    });

    return NextResponse.json({
      success: true,
      processed: result.count,
      message: `${result.count} ×”×ª×××•×ª ×¢×•×“×›× ×• ×‘×”×¦×œ×—×”`,
    });

  } catch (error) {
    console.error('[PotentialMatches] DELETE Error:', error);
    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      message: error instanceof Error ? error.message : 'Unknown error',
    }, { status: 500 });
  }
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

function calculateAge(birthDate: Date | null | undefined): number {
  if (!birthDate) return 0;
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

async function calculateStats() {
  const [statusCounts, avgScoreResult, scoreTiers] = await Promise.all([
    // ×¡×¤×™×¨×” ×œ×¤×™ ×¡×˜×˜×•×¡
    prisma.potentialMatch.groupBy({
      by: ['status'],
      _count: { id: true }
    }),
    
    // ×¦×™×•×Ÿ ×××•×¦×¢
    prisma.potentialMatch.aggregate({
      where: { status: { in: ['PENDING', 'REVIEWED'] } },
      _avg: { aiScore: true }
    }),
    
    // ×”×ª×¤×œ×’×•×ª ×¦×™×•× ×™×
    prisma.$queryRaw`
      SELECT 
        CASE 
          WHEN "aiScore" >= 85 THEN 'high'
          WHEN "aiScore" >= 70 THEN 'medium'
          ELSE 'low'
        END as tier,
        COUNT(*) as count
      FROM "PotentialMatch"
      WHERE status IN ('PENDING', 'REVIEWED')
      GROUP BY tier
    ` as Promise<Array<{ tier: string; count: bigint }>>
  ]);

  const stats: any = {
    total: 0,
    pending: 0,
    reviewed: 0,
    sent: 0,
    dismissed: 0,
    expired: 0,
    withWarnings: 0, // ×™×—×•×©×‘ ×‘× ×¤×¨×“ ×× × ×“×¨×©, ××š ×›××Ÿ ×”×•× ×¨×§ placeholder
    avgScore: Math.round((avgScoreResult._avg.aiScore || 0) * 10) / 10,
    highScore: 0,
    mediumScore: 0,
  };

  for (const item of statusCounts) {
    const status = item.status.toLowerCase();
    if (status in stats) {
      stats[status] = item._count.id;
    }
    stats.total += item._count.id;
  }

  for (const tier of scoreTiers) {
    if (tier.tier === 'high') stats.highScore = Number(tier.count);
    if (tier.tier === 'medium') stats.mediumScore = Number(tier.count);
  }

  return stats;
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\rejection-feedback
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\rejection-feedback\route.ts
--------------------------------------------------------------------------------
Content:
// =============================================================================
// ğŸ“ src/app/api/matchmaker/rejection-feedback/route.ts
// =============================================================================
// ğŸ¯ Rejection Feedback API V1.0 - NeshamaTech
// =============================================================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import rejectionFeedbackService, { 
  type RejectionCategory,
  REJECTION_CATEGORY_INFO 
} from "@/lib/services/rejectionFeedbackService";
import { UserRole } from "@prisma/client";

// =============================================================================
// Types
// =============================================================================

interface SessionUser {
  id: string;
  role: UserRole;
}

// =============================================================================
// GET - ×§×‘×œ×ª × ×ª×•× ×™ ×“×—×™×•×ª
// =============================================================================

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const user = session.user as SessionUser;
    if (user.role !== UserRole.MATCHMAKER && user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { error: "Access denied" },
        { status: 403 }
      );
    }
    
    const searchParams = request.nextUrl.searchParams;
    const action = searchParams.get('action');
    const userId = searchParams.get('userId');
    const userId1 = searchParams.get('userId1');
    const userId2 = searchParams.get('userId2');
    
    switch (action) {
      case 'categories': {
        // ×”×—×–×¨×ª ×§×˜×’×•×¨×™×•×ª ×”×“×—×™×™×”
        const categories = Object.entries(REJECTION_CATEGORY_INFO).map(([key, info]) => ({
          value: key,
          label: info.labelHe,
          labelEn: info.label,
          group: info.group,
          description: info.description,
        }));
        
        // ××™×•×Ÿ ×œ×¤×™ groups
        const groupedCategories = {
          objective: categories.filter(c => c.group === 'objective'),
          subjective: categories.filter(c => c.group === 'subjective'),
          timing: categories.filter(c => c.group === 'timing'),
          red_flag: categories.filter(c => c.group === 'red_flag'),
          other: categories.filter(c => c.group === 'other'),
        };
        
        return NextResponse.json({ 
          categories, 
          grouped: groupedCategories 
        });
      }
        
      case 'stats': {
        // ×¡×˜×˜×™×¡×˜×™×§×•×ª ×›×œ×œ×™×•×ª
        const dateFromParam = searchParams.get('dateFrom');
        const dateToParam = searchParams.get('dateTo');
        
        const dateFrom = dateFromParam ? new Date(dateFromParam) : undefined;
        const dateTo = dateToParam ? new Date(dateToParam) : undefined;
          
        const stats = await rejectionFeedbackService.getRejectionStats(dateFrom, dateTo);
        return NextResponse.json(stats);
      }
        
      case 'user_profile': {
        // ×¤×¨×•×¤×™×œ ×“×—×™×•×ª ×œ××©×ª××©
        if (!userId) {
          return NextResponse.json(
            { error: "userId required" },
            { status: 400 }
          );
        }
        
        const userProfile = await rejectionFeedbackService.getUserRejectionProfile(userId);
        return NextResponse.json(userProfile);
      }
        
      case 'pair_history': {
        // ×”×™×¡×˜×•×¨×™×” ×‘×™×Ÿ ×©× ×™ ××©×ª××©×™×
        if (!userId1 || !userId2) {
          return NextResponse.json(
            { error: "userId1 and userId2 required" },
            { status: 400 }
          );
        }
        
        const pairHistory = await rejectionFeedbackService.getPairRejectionHistory(
          userId1, 
          userId2
        );
        return NextResponse.json(pairHistory);
      }
        
      case 'insights': {
        // ×ª×•×‘× ×•×ª ×× ×™×ª×•×— ×”×“×—×™×•×ª
        const insights = await rejectionFeedbackService.getRejectionInsights();
        return NextResponse.json({ insights });
      }
        
      default: {
        // ×‘×¨×™×¨×ª ××—×“×œ - ×¡×˜×˜×™×¡×˜×™×§×•×ª
        const defaultStats = await rejectionFeedbackService.getRejectionStats();
        return NextResponse.json(defaultStats);
      }
    }
    
  } catch (error) {
    console.error("[RejectionFeedback API] Error:", error);
    
    return NextResponse.json(
      { error: "Failed to fetch rejection data" },
      { status: 500 }
    );
  }
}

// =============================================================================
// POST - ×©××™×¨×ª ×¤×™×“×‘×§ ×“×—×™×™×”
// =============================================================================

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const user = session.user as SessionUser;
    if (user.role !== UserRole.MATCHMAKER && user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { error: "Access denied" },
        { status: 403 }
      );
    }
    
    const matchmakerId = user.id;
    const body = await request.json();
    
    const {
      rejectedUserId,
      rejectingUserId,
      suggestionId,
      potentialMatchId,
      category,
      subcategory,
      freeText,
      wasExpected,
    } = body;
    
    // ×•×•×œ×™×“×¦×™×”
    if (!rejectedUserId || !rejectingUserId || !category) {
      return NextResponse.json(
        { error: "rejectedUserId, rejectingUserId, and category are required" },
        { status: 400 }
      );
    }
    
    // ×‘×“×™×§×” ×©×”×§×˜×’×•×¨×™×” ×ª×§×™× ×”
    if (!REJECTION_CATEGORY_INFO[category as RejectionCategory]) {
      return NextResponse.json(
        { error: "Invalid rejection category" },
        { status: 400 }
      );
    }
    
    // ×©××™×¨×”
    const feedbackId = await rejectionFeedbackService.saveRejectionFeedback({
      rejectedUserId,
      rejectingUserId,
      suggestionId,
      potentialMatchId,
      category: category as RejectionCategory,
      subcategory,
      freeText,
      recordedBy: matchmakerId,
      wasExpected,
    });
    
    return NextResponse.json({ 
      success: true, 
      feedbackId 
    });
    
  } catch (error) {
    console.error("[RejectionFeedback API] POST Error:", error);
    
    return NextResponse.json(
      { error: "Failed to save rejection feedback" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { MatchSuggestionStatus, Prisma, UserRole } from '@prisma/client';
import { suggestionService } from '@/components/matchmaker/suggestions/services/suggestions/SuggestionService';
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import type { CreateSuggestionData } from '@/types/suggestions';
// ========================= ×©×™× ×•×™ ××¨×›×–×™ 1: ×™×™×‘×•× ×˜×™×¤×•×¡ ×”××™×œ×•×Ÿ =========================
import type { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';
export const dynamic = 'force-dynamic';



/**
 * ××—×©×‘ ××ª ×”×§×˜×’×•×¨×™×” ×©×œ ×”×”×¦×¢×” ×‘×”×ª×‘×¡×¡ ×¢×œ ×”×¡×˜×˜×•×¡ ×©×œ×”.
 */
const getSuggestionCategory = (status: MatchSuggestionStatus) => {
  switch (status) {
    case 'DRAFT':
    case 'AWAITING_MATCHMAKER_APPROVAL':
    case 'PENDING_FIRST_PARTY':
    case 'PENDING_SECOND_PARTY':
      return 'PENDING';

    case 'FIRST_PARTY_DECLINED':
    case 'SECOND_PARTY_DECLINED':
    case 'MATCH_DECLINED':
    case 'ENDED_AFTER_FIRST_DATE':
    case 'ENGAGED':
    case 'MARRIED':
    case 'EXPIRED':
    case 'CLOSED':
    case 'CANCELLED':
      return 'HISTORY';

    default:
      return 'ACTIVE';
  }
};

/**
 * POST: ×™×•×¦×¨ ×”×¦×¢×ª ×©×™×“×•×š ×—×“×©×”.
 */
export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const allowedRolesToCreate: UserRole[] = [
      UserRole.MATCHMAKER,
      UserRole.ADMIN,
    ];
    if (!allowedRolesToCreate.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        {
          error:
            'Unauthorized - Matchmaker or Admin access required to create suggestions',
        },
        { status: 403 }
      );
    }

    const data = await req.json();

    if (!data.firstPartyId || !data.secondPartyId || !data.decisionDeadline) {
      return NextResponse.json(
        { error: 'Invalid input: Missing required fields.' },
        { status: 400 }
      );
    }
    
    // ========================= ×©×™× ×•×™ ××¨×›×–×™ 3: ×˜×¢×™× ×ª ×”×ª×¨×’×•××™× =========================
    const url = new URL(req.url);
const rawLocale = url.searchParams.get('locale');
const locale: 'he' | 'en' = (rawLocale === 'en' || rawLocale === 'he') ? rawLocale : 'he';    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email; // ×—×™×œ×•×¥ ×”×—×œ×§ ×©×œ ×”××™×™×œ×™×

    if (!emailDict) {
        // ×‘××§×¨×” ×—×™×¨×•× ×©×”××™×œ×•×Ÿ ×œ× × ×˜×¢×Ÿ ×›×¨××•×™
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    // ×‘×“×™×§×” ×•×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ×™ AI
    try {
      const [firstParty, secondParty] = await Promise.all([
        prisma.user.findUnique({
          where: { id: data.firstPartyId },
          include: { profile: true },
        }),
        prisma.user.findUnique({
          where: { id: data.secondPartyId },
          include: { profile: true },
        }),
      ]);

      if (!firstParty || !secondParty) {
        return NextResponse.json(
          { error: 'One or both candidates not found.' },
          { status: 404 }
        );
      }

      const profilesToUpdate: { userId: string; profileId: string }[] = [];
      if (firstParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: firstParty.id,
          profileId: firstParty.profile.id,
        });
      }
      if (secondParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: secondParty.id,
          profileId: secondParty.profile.id,
        });
      }

      if (profilesToUpdate.length > 0) {
        console.log(
          `[AI Update Trigger] Updating AI profiles for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')} before creating suggestion.`
        );
        await Promise.all(
          profilesToUpdate.map((p) => updateUserAiProfile(p.userId))
        );
        await prisma.profile.updateMany({
          where: { id: { in: profilesToUpdate.map((p) => p.profileId) } },
          data: { needsAiProfileUpdate: false },
        });
        console.log(
          `[AI Update Trigger] Flags reset for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')}.`
        );
      }
    } catch (aiUpdateError) {
      console.error('Failed during pre-suggestion AI profile update:', aiUpdateError);
      return NextResponse.json(
        { error: 'Failed to update AI profiles for candidates. Please try again.' },
        { status: 500 }
      );
    }

    // ×™×¦×™×¨×ª ×”×”×¦×¢×” ×•×”×¢×‘×¨×ª ×”××™×œ×•×Ÿ ×œ×©×™×¨×•×ª
    const suggestionData: CreateSuggestionData = {
      ...data,
      matchmakerId: session.user.id,
    };
    
    // ========================= ×©×™× ×•×™ ××¨×›×–×™ 4: ×”×¢×‘×¨×ª ×”××™×œ×•×Ÿ ×œ×©×™×¨×•×ª =========================
    const newSuggestion = await suggestionService.createSuggestion(suggestionData, emailDict);

    return NextResponse.json(newSuggestion, { status: 201 });
  } catch (error) {
    console.error('Error creating suggestion:', error);
    let message = 'Failed to create suggestion';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/**
 * GET: ×××—×–×¨ ×¨×©×™××” ×©×œ ×”×¦×¢×•×ª ×©×™×“×•×š.
 */
export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(req.url);
    const status = searchParams.get('status');
    const priority = searchParams.get('priority');
    const timeframe = searchParams.get('timeframe');

    const where: Prisma.MatchSuggestionWhereInput = {};

    if (session.user.role === UserRole.MATCHMAKER) {
      where.matchmakerId = session.user.id;
    } else if (session.user.role === UserRole.CANDIDATE) {
      where.OR = [
        { firstPartyId: session.user.id },
        { secondPartyId: session.user.id },
      ];
    }

    if (status) where.status = status as MatchSuggestionStatus;
    if (priority)
      where.priority =
        priority as Prisma.EnumPriorityFieldUpdateOperationsInput['set'];

    if (timeframe) {
      const date = new Date();
      switch (timeframe) {
        case 'today':
          date.setHours(0, 0, 0, 0);
          where.createdAt = { gte: date };
          break;
        case 'week':
          date.setDate(date.getDate() - 7);
          where.createdAt = { gte: date };
          break;
        case 'month':
          date.setMonth(date.getMonth() - 1);
          where.createdAt = { gte: date };
          break;
      }
    }

    const suggestions = await prisma.matchSuggestion.findMany({
      where,
      include: {
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true, role: true },
        },
        statusHistory: { orderBy: { createdAt: 'desc' } },
        meetings: { orderBy: { createdAt: 'desc' } },
        inquiries: {
          include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
          },
          orderBy: { createdAt: 'asc' },
        },
      },
      orderBy: { lastActivity: 'desc' },
    });

    const formattedSuggestions = suggestions.map((suggestion) => ({
      ...suggestion,
      category: getSuggestionCategory(suggestion.status),
      // Formatting logic remains the same...
    }));

    console.log(
      `[API GET /suggestions] User: ${session.user.id} (Role: ${
        session.user.role
      }). Found ${suggestions.length} suggestions matching query.`
    );

    return NextResponse.json(formattedSuggestions);
  } catch (error) {
    console.error('Error fetching suggestions:', error);
    let message = 'Failed to fetch suggestions';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { SuggestionService } from "@/components/matchmaker/suggestions/services/suggestions/SuggestionService";

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const params = await props.params;
    const suggestionId = params.id;
    const data = await req.json();
    
    const suggestionService = SuggestionService.getInstance();
    
    try {
      const updatedSuggestion = await suggestionService.updateSuggestion(
        suggestionId,
        session.user.id,
        {
          id: suggestionId,
          priority: data.priority,
          notes: {
            internal: data.internalNotes,
            forFirstParty: data.firstPartyNotes,
            forSecondParty: data.secondPartyNotes,
            matchingReason: data.matchingReason,
            followUpNotes: data.followUpNotes
          },
          decisionDeadline: data.decisionDeadline ? new Date(data.decisionDeadline) : undefined,
          responseDeadline: data.responseDeadline ? new Date(data.responseDeadline) : undefined
        }
      );
      
      return NextResponse.json({
        success: true,
        data: updatedSuggestion
      });
      
    } catch (serviceError: unknown) {
        console.error("Error from suggestion service:", serviceError);
        
        if (serviceError instanceof Error) {
          return NextResponse.json(
            { success: false, error: serviceError.message || "Failed to update suggestion" },
            { status: serviceError.message.includes("Unauthorized") ? 403 : 400 }
          );
        }
        
        return NextResponse.json(
          { success: false, error: "Failed to update suggestion" },
          { status: 400 }
        );
      }
  } catch (error) {
    console.error("Error updating suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const params = await props.params;
    const suggestionId = params.id;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to delete this suggestion" },
        { status: 403 }
      );
    }

    await prisma.suggestionStatusHistory.deleteMany({
      where: { suggestionId }
    });

    await prisma.dateFeedback.deleteMany({
      where: { suggestionId }
    });

    await prisma.meeting.deleteMany({
      where: { suggestionId }
    });

    await prisma.suggestionInquiry.deleteMany({
      where: { suggestionId }
    });

    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        approvedBy: { set: [] },
        reviewedBy: { set: [] }
      }
    });

    await prisma.matchSuggestion.delete({
      where: { id: suggestionId }
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully"
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete suggestion", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/message/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';
import { notificationService } from '@/components/matchmaker/suggestions/services/notification/NotificationService';
import { initNotificationService } from '@/components/matchmaker/suggestions/services/notification/initNotifications';
import { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';

initNotificationService();

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    const params = await props.params;
    const suggestionId = params.id;

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: 'Unauthorized - Invalid session' }, { status: 401 });
    }

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: 'Unauthorized - Matchmaker or Admin access required' }, { status: 403 });
    }

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /message] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    const body = await req.json();
    const { partyType, customMessage, channels } = body;

    if (!partyType || !customMessage || !channels) {
      return NextResponse.json({ error: 'Invalid input: Missing required fields.' }, { status: 400 });
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: 'Suggestion not found' }, { status: 404 });
    }

    await notificationService.handleSuggestionStatusChange(
      suggestion, 
      emailDict,
      {
        channels: channels,
        notifyParties: [partyType],
        customMessage: customMessage
      }
    );

    return NextResponse.json({ success: true, message: 'Message sent successfully.' }, { status: 200 });

  } catch (error) {
    console.error('Error sending message for suggestion:', error);
    const message = (error instanceof Error) ? error.message : 'Failed to send message';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/remind/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { initNotificationService } from "@/components/matchmaker/suggestions/services/notification/initNotifications";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

const notificationService = initNotificationService();

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const params = await props.params;
    const suggestionId = params.id;
    const { partyType } = await req.json();

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /remind] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict || !emailDict.notifications?.customMessage?.reminderText) {
        throw new Error(`Email dictionary for locale '${locale}' is missing required notification templates.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to send reminders for this suggestion" }, { status: 403 });
    }
    
    const notifyParties: ('first' | 'second')[] = [];
    if ((partyType === "first" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_FIRST_PARTY) {
      notifyParties.push('first');
    }
    if ((partyType === "second" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_SECOND_PARTY) {
      notifyParties.push('second');
    }
    
    if (notifyParties.length === 0) {
      return NextResponse.json({ success: false, error: "No applicable recipients for reminder in current status" }, { status: 400 });
    }

    const reminderTemplateText = emailDict.notifications.customMessage.reminderText;
    const reminderContent = reminderTemplateText
        .replace('{{matchmakerName}}', `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`);

    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: { lastActivity: new Date() },
    });

    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId,
        status: suggestion.status,
        notes: `×ª×–×›×•×¨×ª × ×©×œ×—×” ×œ${partyType === "first" ? "×¦×“ ×¨××©×•×Ÿ" : partyType === "second" ? "×¦×“ ×©× ×™" : "×©× ×™ ×”×¦×“×“×™×"} ×¢×œ ×™×“×™ ${session.user.firstName} ${session.user.lastName}`,
      },
    });
    
    await notificationService.handleSuggestionStatusChange(
      suggestion,
      emailDict,
      {
        channels: ['email', 'whatsapp'],
        notifyParties,
        customMessage: reminderContent
      }
    );
    
    return NextResponse.json({
      success: true,
      message: "Reminder sent successfully",
      recipientCount: notifyParties.length
    });
  } catch (error) {
    console.error("Error sending reminder:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send reminder" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/resend/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const params = await props.params;
    const suggestionId = params.id;
    const { partyType } = await req.json();

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /resend] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to resend this suggestion" }, { status: 403 });
    }

    let updatedSuggestion = suggestion;
    const transitionNotes = `×”×¦×¢×” × ×©×œ×—×” ××—×“×© ×¢"×™ ${session.user.firstName} ${session.user.lastName}`;
    
    if (partyType === "both" || partyType === "first") {
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_FIRST_PARTY,
        emailDict,
        `${transitionNotes} - ×œ×¦×“ ×¨××©×•×Ÿ`,
        {
          sendNotifications: true,
          notifyParties: ['first']
        }
      );
      
      if (partyType === "first") {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            firstPartySent: new Date(),
            lastActivity: new Date()
          }
        });
      }
    }
    
    if (partyType === "both" || partyType === "second") {
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        emailDict,
        `${transitionNotes} - ×œ×¦×“ ×©× ×™`,
        {
          sendNotifications: true,
          notifyParties: ['second']
        }
      );
      
      await prisma.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          secondPartySent: new Date(),
          lastActivity: new Date()
        }
      });
    }

    return NextResponse.json({
      success: true,
      message: `Suggestion successfully resent to ${partyType === "first" ? "first party" : partyType === "second" ? "second party" : "both parties"}`,
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error resending suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to resend suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/share-contact/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const params = await props.params;
    const suggestionId = params.id;

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /share-contact] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to share contact details for this suggestion" }, { status: 403 });
    }
    
    if (suggestion.status !== MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      return NextResponse.json({
        success: false,
        error: "Cannot share contacts until both parties have approved the suggestion."
      }, { status: 400 });
    }
    
    const updatedSuggestion = await statusTransitionService.transitionStatus(
      suggestion,
      MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
      emailDict,
      `×¤×¨×˜×™ ×§×©×¨ ×©×•×ª×¤×• ×‘×™×Ÿ ${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} ×œ${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} ×¢"×™ ${session.user.firstName} ${session.user.lastName}`,
      {
        sendNotifications: true,
        notifyParties: ['first', 'second', 'matchmaker']
      }
    );

    return NextResponse.json({
      success: true,
      message: "Contact details shared successfully",
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error sharing contact details:", error);
    return NextResponse.json(
      { success: false, error: "Failed to share contact details" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { z } from "zod";

const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const body = await req.json();
    console.log("Received status update request:", body);
    
    const validationResult = updateStatusSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error:", validationResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid request data", 
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }
    
    const { status, notes } = validationResult.data;
    const params = await props.params;
    const suggestionId = params.id;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to update this suggestion" },
        { status: 403 }
      );
    }

    const getCategory = (status: MatchSuggestionStatus) => {
      switch (status) {
        case "DRAFT":
        case "AWAITING_MATCHMAKER_APPROVAL":
        case "PENDING_FIRST_PARTY":
        case "PENDING_SECOND_PARTY":
          return "PENDING";
        
        case "FIRST_PARTY_DECLINED":
        case "SECOND_PARTY_DECLINED":
        case "MATCH_DECLINED":
        case "ENDED_AFTER_FIRST_DATE":
        case "ENGAGED":
        case "MARRIED":
        case "EXPIRED":
        case "CLOSED":
        case "CANCELLED":
          return "HISTORY";
        
        default:
          return "ACTIVE";
      }
    };

    const result = await prisma.$transaction(async (tx) => {
      const previousStatus = suggestion.status;
      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status,
          previousStatus: previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          category: getCategory(status),
          ...(status === MatchSuggestionStatus.CLOSED ? { closedAt: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_FIRST_PARTY ? { firstPartySent: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY ? { secondPartySent: new Date() } : {}),
        },
      });

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes: notes || `×¡×˜×˜×•×¡ ×©×•× ×” ×œ-${status} ×¢×œ ×™×“×™ ${session.user.firstName} ${session.user.lastName}`,
        },
      });

      return updatedSuggestion;
    });

    return NextResponse.json({
      success: true,
      message: "Status updated successfully",
      suggestion: {
        id: result.id,
        status: result.status,
        previousStatus: result.previousStatus,
        lastStatusChange: result.lastStatusChange,
        category: result.category,
      },
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to update status", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const params = await props.params;
    const searchParams = new URL(req.url).searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 50;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        matchmakerId: true,
        firstPartyId: true,
        secondPartyId: true,
      }
    });
    
    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return NextResponse.json({ error: "Not authorized to view this suggestion" }, { status: 403 });
    }
    
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(startDate && {
          createdAt: {
            gte: new Date(startDate),
            ...(endDate && {
              lte: new Date(endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: { id: true, firstName: true, lastName: true },
            },
            secondParty: {
              select: { id: true, firstName: true, lastName: true },
            },
            matchmaker: {
              select: { id: true, firstName: true, lastName: true },
            },
          },
        },
      },
      orderBy: { createdAt: "desc" as const },
      take: limit,
    };

    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { error: "Failed to fetch history", details: errorMessage },
      { status: 500 }
    );
  }
}

export async function HEAD(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new Response(null, { status: 401 });
    }

    const params = await props.params;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      }
    });

    if (!suggestion) {
      return new Response(null, { status: 404 });
    }

    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return new Response(null, { status: 403 });
    }

    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}
--- End of Content for route.ts ---

